
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { w as writable, S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, e as element, t as text, a as space, c as claim_element, b as children, f as claim_text, g as detach_dev, h as claim_space, j as add_location, k as attr_dev, l as insert_hydration_dev, m as append_hydration_dev, n as noop, o as toggle_class, p as listen_dev, q as is_function, r as validate_each_argument, u as null_to_empty, x as destroy_each, y as add_render_callback, z as push, A as create_component, B as claim_component, C as mount_component, D as group_outros, E as transition_out, F as check_outros, G as transition_in, H as destroy_component, I as run_all, J as set_data_dev, K as get_store_value, L as axios, R as Router, M as validate_store, N as component_subscribe, O as wrap, P as onMount, Q as replace, T as globals, U as prevent_default, V as empty, W as set_input_value, X as src_url_equal, Y as onDestroy, Z as query_selector_all, _ as prop_dev, $ as to_number, a0 as location, a1 as svguitar, a2 as SVGuitarChord, a3 as bubble, a4 as select_value, a5 as select_option, a6 as createEventDispatcher, a7 as stop_propagation, a8 as binding_callbacks, a9 as bind, aa as add_flush_callback } from './vendor-afb041c5.js';

const spotifyToken = writable();

const db = writable(
  window.indexedDB ||
    window.mozIndexedDB ||
    window.webkitIndexedDB ||
    window.msIndexedDB || { onerror: null }
);

/* src/pages/Home/index.svelte generated by Svelte v3.47.0 */

const file$k = "src/pages/Home/index.svelte";

function create_fragment$k(ctx) {
	let h1;
	let t0;
	let t1;
	let p0;
	let t2;
	let t3;
	let section;
	let h2;
	let t4;
	let t5;
	let p1;
	let t6;
	let a;
	let t7;
	let t8;
	let t9;
	let p2;
	let t10;
	let t11;
	let p3;
	let t12;
	let t13;
	let div;

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("Rad Guitar Practice Tool");
			t1 = space();
			p0 = element("p");
			t2 = text("Welcome to Raguprato. This rad guitar practice tool will help you improve your guitar\n  skills.");
			t3 = space();
			section = element("section");
			h2 = element("h2");
			t4 = text("How to use");
			t5 = space();
			p1 = element("p");
			t6 = text("This tool was designed to be as simple as possible. Just head over to the ");
			a = element("a");
			t7 = text("new lessons page");
			t8 = text(" to create a lesson for yourself and start practicing.");
			t9 = space();
			p2 = element("p");
			t10 = text("You can add videos, chords and strumming patterns to every lesson you create.");
			t11 = space();
			p3 = element("p");
			t12 = text("You don't need an account or a credit card. We value your privacy and safe your\n    lessons only locally in your browser.");
			t13 = space();
			div = element("div");
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Rad Guitar Practice Tool");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			p0 = claim_element(nodes, "P", { class: true });
			var p0_nodes = children(p0);
			t2 = claim_text(p0_nodes, "Welcome to Raguprato. This rad guitar practice tool will help you improve your guitar\n  skills.");
			p0_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			section = claim_element(nodes, "SECTION", {});
			var section_nodes = children(section);
			h2 = claim_element(section_nodes, "H2", {});
			var h2_nodes = children(h2);
			t4 = claim_text(h2_nodes, "How to use");
			h2_nodes.forEach(detach_dev);
			t5 = claim_space(section_nodes);
			p1 = claim_element(section_nodes, "P", { class: true });
			var p1_nodes = children(p1);
			t6 = claim_text(p1_nodes, "This tool was designed to be as simple as possible. Just head over to the ");
			a = claim_element(p1_nodes, "A", { class: true, href: true });
			var a_nodes = children(a);
			t7 = claim_text(a_nodes, "new lessons page");
			a_nodes.forEach(detach_dev);
			t8 = claim_text(p1_nodes, " to create a lesson for yourself and start practicing.");
			p1_nodes.forEach(detach_dev);
			t9 = claim_space(section_nodes);
			p2 = claim_element(section_nodes, "P", { class: true });
			var p2_nodes = children(p2);
			t10 = claim_text(p2_nodes, "You can add videos, chords and strumming patterns to every lesson you create.");
			p2_nodes.forEach(detach_dev);
			t11 = claim_space(section_nodes);
			p3 = claim_element(section_nodes, "P", { class: true });
			var p3_nodes = children(p3);
			t12 = claim_text(p3_nodes, "You don't need an account or a credit card. We value your privacy and safe your\n    lessons only locally in your browser.");
			p3_nodes.forEach(detach_dev);
			t13 = claim_space(section_nodes);
			div = claim_element(section_nodes, "DIV", { id: true });
			children(div).forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$k, 0, 0, 0);
			attr_dev(p0, "class", "svelte-1pfs4fl");
			add_location(p0, file$k, 2, 0, 35);
			add_location(h2, file$k, 8, 2, 155);
			attr_dev(a, "class", "fancy-link");
			attr_dev(a, "href", "#/new-lesson");
			add_location(a, file$k, 11, 78, 260);
			attr_dev(p1, "class", "svelte-1pfs4fl");
			add_location(p1, file$k, 10, 2, 178);
			attr_dev(p2, "class", "svelte-1pfs4fl");
			add_location(p2, file$k, 15, 2, 398);
			attr_dev(p3, "class", "svelte-1pfs4fl");
			add_location(p3, file$k, 16, 2, 485);
			attr_dev(div, "id", "chart");
			add_location(div, file$k, 21, 2, 625);
			add_location(section, file$k, 7, 0, 143);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, h1, anchor);
			append_hydration_dev(h1, t0);
			insert_hydration_dev(target, t1, anchor);
			insert_hydration_dev(target, p0, anchor);
			append_hydration_dev(p0, t2);
			insert_hydration_dev(target, t3, anchor);
			insert_hydration_dev(target, section, anchor);
			append_hydration_dev(section, h2);
			append_hydration_dev(h2, t4);
			append_hydration_dev(section, t5);
			append_hydration_dev(section, p1);
			append_hydration_dev(p1, t6);
			append_hydration_dev(p1, a);
			append_hydration_dev(a, t7);
			append_hydration_dev(p1, t8);
			append_hydration_dev(section, t9);
			append_hydration_dev(section, p2);
			append_hydration_dev(p2, t10);
			append_hydration_dev(section, t11);
			append_hydration_dev(section, p3);
			append_hydration_dev(p3, t12);
			append_hydration_dev(section, t13);
			append_hydration_dev(section, div);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(p0);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(section);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$k($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Home', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Home> was created with unknown prop '${key}'`);
	});

	return [];
}

class Home extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$k, create_fragment$k, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Home",
			options,
			id: create_fragment$k.name
		});
	}
}

/* src/pages/404/index.svelte generated by Svelte v3.47.0 */

const file$j = "src/pages/404/index.svelte";

function create_fragment$j(ctx) {
	let h1;
	let t0;
	let t1;
	let div;

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("Page not found");
			t1 = space();
			div = element("div");
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Page not found");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { id: true, class: true });
			children(div).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h1, "class", "svelte-e79gxq");
			add_location(h1, file$j, 0, 0, 0);
			attr_dev(div, "id", "not-found");
			attr_dev(div, "class", "svelte-e79gxq");
			add_location(div, file$j, 1, 0, 24);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, h1, anchor);
			append_hydration_dev(h1, t0);
			insert_hydration_dev(target, t1, anchor);
			insert_hydration_dev(target, div, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$j($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('_404', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<_404> was created with unknown prop '${key}'`);
	});

	return [];
}

class _404 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$j, create_fragment$j, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "_404",
			options,
			id: create_fragment$j.name
		});
	}
}

/* src/pages/Error/index.svelte generated by Svelte v3.47.0 */

const file$i = "src/pages/Error/index.svelte";

function create_fragment$i(ctx) {
	let h1;
	let t0;
	let t1;
	let p;
	let t2;

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("Error");
			t1 = space();
			p = element("p");
			t2 = text("Sorry, Something went wrong. We are working on it.");
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Error");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t2 = claim_text(p_nodes, "Sorry, Something went wrong. We are working on it.");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h1, "class", "svelte-1s7oguc");
			add_location(h1, file$i, 0, 0, 0);
			add_location(p, file$i, 1, 0, 15);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, h1, anchor);
			append_hydration_dev(h1, t0);
			insert_hydration_dev(target, t1, anchor);
			insert_hydration_dev(target, p, anchor);
			append_hydration_dev(p, t2);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$i($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Error', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Error> was created with unknown prop '${key}'`);
	});

	return [];
}

class Error$2 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$i, create_fragment$i, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Error",
			options,
			id: create_fragment$i.name
		});
	}
}

/* src/components/Navigation.svelte generated by Svelte v3.47.0 */

const file$h = "src/components/Navigation.svelte";

// (9:4) {#if !show}
function create_if_block$8(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "nav-button-line svelte-gtup2w");
			add_location(div, file$h, 9, 6, 222);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$8.name,
		type: "if",
		source: "(9:4) {#if !show}",
		ctx
	});

	return block;
}

function create_fragment$h(ctx) {
	let button;
	let div2;
	let div0;
	let t0;
	let t1;
	let div1;
	let mounted;
	let dispose;
	let if_block = !/*show*/ ctx[0] && create_if_block$8(ctx);

	const block = {
		c: function create() {
			button = element("button");
			div2 = element("div");
			div0 = element("div");
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			div1 = element("div");
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { "aria-label": true, class: true });
			var button_nodes = children(button);
			div2 = claim_element(button_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			children(div0).forEach(detach_dev);
			t0 = claim_space(div2_nodes);
			if (if_block) if_block.l(div2_nodes);
			t1 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			children(div1).forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "nav-button-line svelte-gtup2w");
			add_location(div0, file$h, 7, 4, 168);
			attr_dev(div1, "class", "nav-button-line svelte-gtup2w");
			add_location(div1, file$h, 11, 4, 268);
			attr_dev(div2, "class", "svelte-gtup2w");
			toggle_class(div2, "close", /*show*/ ctx[0]);
			add_location(div2, file$h, 6, 2, 139);
			attr_dev(button, "aria-label", "Navigation Button");
			attr_dev(button, "class", "nav-button svelte-gtup2w");
			add_location(button, file$h, 5, 0, 60);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, button, anchor);
			append_hydration_dev(button, div2);
			append_hydration_dev(div2, div0);
			append_hydration_dev(div2, t0);
			if (if_block) if_block.m(div2, null);
			append_hydration_dev(div2, t1);
			append_hydration_dev(div2, div1);

			if (!mounted) {
				dispose = listen_dev(
					button,
					"click",
					function () {
						if (is_function(/*toggle*/ ctx[1])) /*toggle*/ ctx[1].apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (!/*show*/ ctx[0]) {
				if (if_block) ; else {
					if_block = create_if_block$8(ctx);
					if_block.c();
					if_block.m(div2, t1);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*show*/ 1) {
				toggle_class(div2, "close", /*show*/ ctx[0]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$h($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Navigation', slots, []);
	let { show } = $$props;
	let { toggle } = $$props;
	const writable_props = ['show', 'toggle'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Navigation> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('show' in $$props) $$invalidate(0, show = $$props.show);
		if ('toggle' in $$props) $$invalidate(1, toggle = $$props.toggle);
	};

	$$self.$capture_state = () => ({ show, toggle });

	$$self.$inject_state = $$props => {
		if ('show' in $$props) $$invalidate(0, show = $$props.show);
		if ('toggle' in $$props) $$invalidate(1, toggle = $$props.toggle);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [show, toggle];
}

class Navigation extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$h, create_fragment$h, safe_not_equal, { show: 0, toggle: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Navigation",
			options,
			id: create_fragment$h.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*show*/ ctx[0] === undefined && !('show' in props)) {
			console.warn("<Navigation> was created without expected prop 'show'");
		}

		if (/*toggle*/ ctx[1] === undefined && !('toggle' in props)) {
			console.warn("<Navigation> was created without expected prop 'toggle'");
		}
	}

	get show() {
		throw new Error("<Navigation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show(value) {
		throw new Error("<Navigation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggle() {
		throw new Error("<Navigation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toggle(value) {
		throw new Error("<Navigation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/NavItems.svelte generated by Svelte v3.47.0 */

const file$g = "src/components/NavItems.svelte";

function get_each_context$6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i].name;
	child_ctx[5] = list[i].path;
	child_ctx[6] = list[i].icon;
	return child_ctx;
}

// (14:2) {#each links as { name, path, icon }}
function create_each_block$6(ctx) {
	let li;
	let a;
	let i;
	let t0;
	let t1_value = /*name*/ ctx[4] + "";
	let t1;
	let a_class_value;
	let t2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			i = element("i");
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", {});
			var li_nodes = children(li);

			a = claim_element(li_nodes, "A", {
				"aria-label": true,
				href: true,
				class: true
			});

			var a_nodes = children(a);
			i = claim_element(a_nodes, "I", { class: true });
			children(i).forEach(detach_dev);
			t0 = claim_space(a_nodes);
			t1 = claim_text(a_nodes, t1_value);
			a_nodes.forEach(detach_dev);
			t2 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(i, "class", "" + (null_to_empty(`fa fa-${/*icon*/ ctx[6]}`) + " svelte-skl5ol"));
			add_location(i, file$g, 20, 8, 592);
			attr_dev(a, "aria-label", /*name*/ ctx[4]);
			attr_dev(a, "href", /*path*/ ctx[5]);
			attr_dev(a, "class", a_class_value = "" + (null_to_empty(`${/*header*/ ctx[0] ? "" : "fancy-link"} ${/*close*/ ctx[1] ? "modal-nav" : ""}`) + " svelte-skl5ol"));
			add_location(a, file$g, 15, 6, 423);
			add_location(li, file$g, 14, 4, 412);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, li, anchor);
			append_hydration_dev(li, a);
			append_hydration_dev(a, i);
			append_hydration_dev(a, t0);
			append_hydration_dev(a, t1);
			append_hydration_dev(li, t2);

			if (!mounted) {
				dispose = listen_dev(a, "click", /*click_handler*/ ctx[3], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*header, close*/ 3 && a_class_value !== (a_class_value = "" + (null_to_empty(`${/*header*/ ctx[0] ? "" : "fancy-link"} ${/*close*/ ctx[1] ? "modal-nav" : ""}`) + " svelte-skl5ol"))) {
				attr_dev(a, "class", a_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$6.name,
		type: "each",
		source: "(14:2) {#each links as { name, path, icon }}",
		ctx
	});

	return block;
}

function create_fragment$g(ctx) {
	let ul;
	let ul_class_value;
	let each_value = /*links*/ ctx[2];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", ul_class_value = "" + (null_to_empty(/*header*/ ctx[0] ? "header" : "") + " svelte-skl5ol"));
			add_location(ul, file$g, 12, 0, 332);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*links, header, close*/ 7) {
				each_value = /*links*/ ctx[2];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$6(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$6(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*header*/ 1 && ul_class_value !== (ul_class_value = "" + (null_to_empty(/*header*/ ctx[0] ? "header" : "") + " svelte-skl5ol"))) {
				attr_dev(ul, "class", ul_class_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$g($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('NavItems', slots, []);
	let { header = false } = $$props;
	let { close = null } = $$props;

	const links = [
		{ name: "Home", path: "/", icon: "home" },
		{
			name: "Lessons",
			path: "#/lessons",
			icon: "guitar"
		},
		{
			name: "Create new Lesson",
			path: "#/new-lesson",
			icon: "plus"
		},
		{
			name: "Links",
			path: "#/links",
			icon: "link"
		}
	];

	const writable_props = ['header', 'close'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NavItems> was created with unknown prop '${key}'`);
	});

	const click_handler = () => close?.();

	$$self.$$set = $$props => {
		if ('header' in $$props) $$invalidate(0, header = $$props.header);
		if ('close' in $$props) $$invalidate(1, close = $$props.close);
	};

	$$self.$capture_state = () => ({ header, close, links });

	$$self.$inject_state = $$props => {
		if ('header' in $$props) $$invalidate(0, header = $$props.header);
		if ('close' in $$props) $$invalidate(1, close = $$props.close);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [header, close, links, click_handler];
}

class NavItems extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$g, create_fragment$g, safe_not_equal, { header: 0, close: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "NavItems",
			options,
			id: create_fragment$g.name
		});
	}

	get header() {
		throw new Error("<NavItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set header(value) {
		throw new Error("<NavItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get close() {
		throw new Error("<NavItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set close(value) {
		throw new Error("<NavItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Header.svelte generated by Svelte v3.47.0 */
const file$f = "src/components/Header.svelte";

// (14:4) {#if windowSize > 830}
function create_if_block_1$4(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("Rad Guitar Practice Tool");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, "Rad Guitar Practice Tool");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "svelte-19rok34");
			add_location(span, file$f, 14, 6, 373);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$4.name,
		type: "if",
		source: "(14:4) {#if windowSize > 830}",
		ctx
	});

	return block;
}

// (20:2) {:else}
function create_else_block$4(ctx) {
	let navigation;
	let current;

	navigation = new Navigation({
			props: {
				show: /*showNav*/ ctx[1],
				toggle: /*func*/ ctx[4]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(navigation.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(navigation.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(navigation, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const navigation_changes = {};
			if (dirty & /*showNav*/ 2) navigation_changes.show = /*showNav*/ ctx[1];
			if (dirty & /*showNav*/ 2) navigation_changes.toggle = /*func*/ ctx[4];
			navigation.$set(navigation_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(navigation.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(navigation.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(navigation, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$4.name,
		type: "else",
		source: "(20:2) {:else}",
		ctx
	});

	return block;
}

// (18:2) {#if windowSize > 750}
function create_if_block$7(ctx) {
	let navitems;
	let current;
	navitems = new NavItems({ props: { header: true }, $$inline: true });

	const block = {
		c: function create() {
			create_component(navitems.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(navitems.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(navitems, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(navitems.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(navitems.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(navitems, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$7.name,
		type: "if",
		source: "(18:2) {#if windowSize > 750}",
		ctx
	});

	return block;
}

function create_fragment$f(ctx) {
	let header;
	let div;
	let i;
	let t0;
	let button;
	let t1;
	let t2;
	let t3;
	let current_block_type_index;
	let if_block1;
	let t4;
	let nav;
	let navitems;
	let current;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowresize*/ ctx[2]);
	let if_block0 = /*windowSize*/ ctx[0] > 830 && create_if_block_1$4(ctx);
	const if_block_creators = [create_if_block$7, create_else_block$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*windowSize*/ ctx[0] > 750) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	navitems = new NavItems({
			props: { close: /*func_1*/ ctx[5] },
			$$inline: true
		});

	const block = {
		c: function create() {
			header = element("header");
			div = element("div");
			i = element("i");
			t0 = space();
			button = element("button");
			t1 = text("raguprato");
			t2 = space();
			if (if_block0) if_block0.c();
			t3 = space();
			if_block1.c();
			t4 = space();
			nav = element("nav");
			create_component(navitems.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			header = claim_element(nodes, "HEADER", { class: true });
			var header_nodes = children(header);
			div = claim_element(header_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			i = claim_element(div_nodes, "I", { class: true });
			children(i).forEach(detach_dev);
			t0 = claim_space(div_nodes);
			button = claim_element(div_nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t1 = claim_text(button_nodes, "raguprato");
			button_nodes.forEach(detach_dev);
			t2 = claim_space(div_nodes);
			if (if_block0) if_block0.l(div_nodes);
			div_nodes.forEach(detach_dev);
			t3 = claim_space(header_nodes);
			if_block1.l(header_nodes);
			header_nodes.forEach(detach_dev);
			t4 = claim_space(nodes);
			nav = claim_element(nodes, "NAV", { class: true });
			var nav_nodes = children(nav);
			claim_component(navitems.$$.fragment, nav_nodes);
			nav_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(i, "class", "fa fa-guitar svelte-19rok34");
			add_location(i, file$f, 11, 4, 234);
			attr_dev(button, "class", "naked-button svelte-19rok34");
			add_location(button, file$f, 12, 4, 265);
			attr_dev(div, "class", "slogan svelte-19rok34");
			add_location(div, file$f, 10, 2, 209);
			attr_dev(header, "class", "svelte-19rok34");
			add_location(header, file$f, 9, 0, 198);
			attr_dev(nav, "class", "svelte-19rok34");
			toggle_class(nav, "show", /*showNav*/ ctx[1]);
			add_location(nav, file$f, 24, 0, 585);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, header, anchor);
			append_hydration_dev(header, div);
			append_hydration_dev(div, i);
			append_hydration_dev(div, t0);
			append_hydration_dev(div, button);
			append_hydration_dev(button, t1);
			append_hydration_dev(div, t2);
			if (if_block0) if_block0.m(div, null);
			append_hydration_dev(header, t3);
			if_blocks[current_block_type_index].m(header, null);
			insert_hydration_dev(target, t4, anchor);
			insert_hydration_dev(target, nav, anchor);
			mount_component(navitems, nav, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(window, "resize", /*onwindowresize*/ ctx[2]),
					listen_dev(button, "click", /*click_handler*/ ctx[3], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*windowSize*/ ctx[0] > 830) {
				if (if_block0) ; else {
					if_block0 = create_if_block_1$4(ctx);
					if_block0.c();
					if_block0.m(div, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				} else {
					if_block1.p(ctx, dirty);
				}

				transition_in(if_block1, 1);
				if_block1.m(header, null);
			}

			const navitems_changes = {};
			if (dirty & /*showNav*/ 2) navitems_changes.close = /*func_1*/ ctx[5];
			navitems.$set(navitems_changes);

			if (dirty & /*showNav*/ 2) {
				toggle_class(nav, "show", /*showNav*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			transition_in(navitems.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			transition_out(navitems.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(header);
			if (if_block0) if_block0.d();
			if_blocks[current_block_type_index].d();
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(nav);
			destroy_component(navitems);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$f($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Header', slots, []);
	let windowSize;
	let showNav = false;
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Header> was created with unknown prop '${key}'`);
	});

	function onwindowresize() {
		$$invalidate(0, windowSize = window.innerWidth);
	}

	const click_handler = () => push("/");
	const func = () => $$invalidate(1, showNav = !showNav);
	const func_1 = () => $$invalidate(1, showNav = false);

	$$self.$capture_state = () => ({
		push,
		Navigation,
		NavItems,
		windowSize,
		showNav
	});

	$$self.$inject_state = $$props => {
		if ('windowSize' in $$props) $$invalidate(0, windowSize = $$props.windowSize);
		if ('showNav' in $$props) $$invalidate(1, showNav = $$props.showNav);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [windowSize, showNav, onwindowresize, click_handler, func, func_1];
}

class Header extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$f, create_fragment$f, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Header",
			options,
			id: create_fragment$f.name
		});
	}
}

/* src/components/Footer.svelte generated by Svelte v3.47.0 */

const file$e = "src/components/Footer.svelte";

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i].link;
	child_ctx[2] = list[i].symbol;
	return child_ctx;
}

// (26:4) {#each socialIcons as { link, symbol }}
function create_each_block$5(ctx) {
	let li;
	let a;
	let i;
	let t;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			i = element("i");
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", {});
			var li_nodes = children(li);

			a = claim_element(li_nodes, "A", {
				"aria-label": true,
				target: true,
				href: true,
				key: true,
				class: true
			});

			var a_nodes = children(a);
			i = claim_element(a_nodes, "I", { class: true });
			children(i).forEach(detach_dev);
			a_nodes.forEach(detach_dev);
			t = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(i, "class", "" + (null_to_empty(`fab fa-${/*symbol*/ ctx[2]}`) + " svelte-1ob7gv2"));
			add_location(i, file$e, 28, 10, 845);
			attr_dev(a, "aria-label", /*symbol*/ ctx[2]);
			attr_dev(a, "target", "_blank");
			attr_dev(a, "href", /*link*/ ctx[1]);
			attr_dev(a, "key", /*symbol*/ ctx[2]);
			attr_dev(a, "class", "svelte-1ob7gv2");
			add_location(a, file$e, 27, 8, 770);
			add_location(li, file$e, 26, 6, 757);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, li, anchor);
			append_hydration_dev(li, a);
			append_hydration_dev(a, i);
			append_hydration_dev(li, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$5.name,
		type: "each",
		source: "(26:4) {#each socialIcons as { link, symbol }}",
		ctx
	});

	return block;
}

function create_fragment$e(ctx) {
	let footer;
	let div;
	let span;
	let t0;
	let a0;
	let t1;
	let t2;
	let a1;
	let t3;
	let t4;
	let ul;
	let each_value = /*socialIcons*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			footer = element("footer");
			div = element("div");
			span = element("span");
			t0 = text("Created by\n      ");
			a0 = element("a");
			t1 = text("Gh05d");
			t2 = space();
			a1 = element("a");
			t3 = text("Down Arrow icon by Icons8");
			t4 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			footer = claim_element(nodes, "FOOTER", { class: true });
			var footer_nodes = children(footer);
			div = claim_element(footer_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			span = claim_element(div_nodes, "SPAN", {});
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, "Created by\n      ");
			a0 = claim_element(span_nodes, "A", { class: true, href: true });
			var a0_nodes = children(a0);
			t1 = claim_text(a0_nodes, "Gh05d");
			a0_nodes.forEach(detach_dev);
			span_nodes.forEach(detach_dev);
			t2 = claim_space(div_nodes);
			a1 = claim_element(div_nodes, "A", { href: true, class: true });
			var a1_nodes = children(a1);
			t3 = claim_text(a1_nodes, "Down Arrow icon by Icons8");
			a1_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			t4 = claim_space(footer_nodes);
			ul = claim_element(footer_nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			footer_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a0, "class", "fancy-link svelte-1ob7gv2");
			attr_dev(a0, "href", "https://github.com/Gh05d");
			add_location(a0, file$e, 20, 6, 528);
			add_location(span, file$e, 18, 4, 498);
			attr_dev(a1, "href", "https://icons8.com/icon/45289/down-arrow");
			attr_dev(a1, "class", "svelte-1ob7gv2");
			add_location(a1, file$e, 22, 4, 608);
			attr_dev(div, "class", "svelte-1ob7gv2");
			add_location(div, file$e, 17, 2, 488);
			attr_dev(ul, "class", "svelte-1ob7gv2");
			add_location(ul, file$e, 24, 2, 702);
			attr_dev(footer, "class", "svelte-1ob7gv2");
			add_location(footer, file$e, 16, 0, 477);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, footer, anchor);
			append_hydration_dev(footer, div);
			append_hydration_dev(div, span);
			append_hydration_dev(span, t0);
			append_hydration_dev(span, a0);
			append_hydration_dev(a0, t1);
			append_hydration_dev(div, t2);
			append_hydration_dev(div, a1);
			append_hydration_dev(a1, t3);
			append_hydration_dev(footer, t4);
			append_hydration_dev(footer, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*socialIcons*/ 1) {
				each_value = /*socialIcons*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$5(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$5(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(footer);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$e($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Footer', slots, []);

	const socialIcons = [
		{
			link: "https://github.com/Gh05d",
			symbol: "github"
		},
		{
			link: "https://www.freecodecamp.org/gh05d",
			symbol: "free-code-camp"
		},
		{
			link: "https://www.linkedin.com/in/pascal-clanget-545956ba/",
			symbol: "linkedin"
		},
		{
			link: "https://stackoverflow.com/users/7490871/gh05d",
			symbol: "stack-overflow"
		},
		{
			link: "https://www.instagram.com/gh05d/?hl=de",
			symbol: "instagram"
		}
	];

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Footer> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ socialIcons });
	return [socialIcons];
}

class Footer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$e, create_fragment$e, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Footer",
			options,
			id: create_fragment$e.name
		});
	}
}

/* src/components/Loading.svelte generated by Svelte v3.47.0 */

const file$d = "src/components/Loading.svelte";

function create_fragment$d(ctx) {
	let div;
	let span;
	let t0;
	let t1;
	let i;

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			t0 = text(/*text*/ ctx[0]);
			t1 = space();
			i = element("i");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			span = claim_element(div_nodes, "SPAN", {});
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, /*text*/ ctx[0]);
			span_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			i = claim_element(div_nodes, "I", { class: true });
			children(i).forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(span, file$d, 5, 2, 78);
			attr_dev(i, "class", "fa fa-spinner fa-spin");
			add_location(i, file$d, 5, 22, 98);
			attr_dev(div, "class", "loading svelte-fp2n7");
			add_location(div, file$d, 4, 0, 54);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, span);
			append_hydration_dev(span, t0);
			append_hydration_dev(div, t1);
			append_hydration_dev(div, i);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*text*/ 1) set_data_dev(t0, /*text*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$d($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Loading', slots, []);
	let { text = "Loading..." } = $$props;
	const writable_props = ['text'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Loading> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('text' in $$props) $$invalidate(0, text = $$props.text);
	};

	$$self.$capture_state = () => ({ text });

	$$self.$inject_state = $$props => {
		if ('text' in $$props) $$invalidate(0, text = $$props.text);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [text];
}

class Loading extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$d, create_fragment$d, safe_not_equal, { text: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Loading",
			options,
			id: create_fragment$d.name
		});
	}

	get text() {
		throw new Error("<Loading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<Loading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/**
 * Returns a function, that, as long as it continues to be invoked, will not
 * be triggered. The function will be called after it stops being called for
 * N milliseconds.
 *
 * @param {function} fn - The function to be executed
 * @param {number} [wait] - The time after which the function should be executed. Defaults to 300ms
 * @returns {fn} - The debounced function
 */
function debounce(callback, wait = 300) {
  let timeout;

  return (...args) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => callback.apply(this, args), wait);
  };
}

const apiCall = async (url, params, method = "GET") => {
  try {
    const { data } = await axios({ method, url, params });

    return data;
  } catch (error) {
    throw new Error(error);
  }
};

const createID = () => Math.random().toString(36).substring(7);

/**
 * Takes an array of artists and concats their names
 * @param {Object[]} artists
 *
 * @returns {string} Names separated by commas
 */
const getArtists = artists =>
  artists?.map(artist => artist.name).join(", ") || "John Doe";

async function authenticateSpotify() {
  try {
    // Needed as content-type means that the server expects tuples
    const params = new URLSearchParams();
    params.append("grant_type", "client_credentials");

    const credentials = await axios.post(
      "https://accounts.spotify.com/api/token",
      params,
      {
        headers: {
          "Content-type": "application/x-www-form-urlencoded",
          Authorization: `Basic ${btoa("aca42c0dc02c41989527bbd4735022b9" + ":" + "4e5a491e12284f2690bd5bad7f5a4181")}`,
        },
      }
    );

    return credentials;
  } catch (err) {
    console.error(err);
  }
}

/**
 * Creates a promise to update the database
 * @function
 * @exports
 *
 * @param {string} query - The operation to perform
 * @param {(string|object)} [params]
 * @param {string} [type=readonly] - Like readonly (default), readwrite, ...
 */
function transaction(query, params = null, type = "readonly") {
  return new Promise((resolve, reject) => {
    const database = get_store_value(db);

    const transaction = database.transaction(["lessons"], type);
    const objectStore = transaction.objectStore("lessons");
    const request = objectStore[query](params);

    request.onerror = event => {
      reject(Error(event?.target?.error || "Something bad happened"));
    };

    request.onsuccess = () => resolve(request.result);
  });
}

// Keys
const ARROW_SRC =
  "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAABmJLR0QA/wD/AP+gvaeTAAABnUlEQVRoge3ZzUqVQRzH8U/iRbQweiCigjBcJEVBh6QwDILASNy2aNUtdAVeRVfRsstoEUgUKIEW5kvvLR6VGXmac44554wwX5jFMH+e+X2fd2aoVLJwJtNxp/Am6F/INE92GvwJWnYmRjHJKKgipVFFSqOKlEYVKY0qUhpVpDSqSGlUkdKoIqVRRUqjipTGMCKTWMG5TFmm8TLTsQ+ZwCvtYtuq/iuHjeEW6Gbwab925bghB2FeHOw9LibqG4OL3MBmUPsDV/8vbprn+BVMuJaYsDGYyG18Ceq+4fHJxE3zTCyzjmsddY3+InewJZZ4dLJx0yxpL/9BgA3MHqlppEXmsROMb+N+nrhpnuB7EOQzbgbjjX+LLGA3GPuKubxx0zzE3pFAd/fHGt0ii+ITsIXeSNL24YH47G7jnm6Rp+JbclP7xiqGnvih3cMLscgyfgb9DVwfQ9a+9MQyv8UiYT/12i6CW+JvQlf7gEvjCjgMs9rbpkti1SnbFA3/mw7aO5wfZ6jjcgUftRJvtdvVp5bLeI2z4w5SqVQq5fEXMTOSwvhqgGAAAAAASUVORK5CYII=";
const DB_NAME = "RagupratoDatabase";
const DB_VERSION = 1;

const chords = {
  A: {
    fingers: [
      [2, 2, "3"],
      [3, 2, "2"],
      [4, 2, "1"],
      [6, "x"],
    ],
    barre: null,
  },
  Am: {
    fingers: [
      [2, 1, "3"],
      [3, 2, "2"],
      [4, 2, "1"],
      [6, "x"],
    ],
    barre: null,
  },
  B: {
    fingers: [
      [2, 4, "3"],
      [3, 4, "3"],
      [4, 4, "3"],
    ],
    barre: {
      fromString: 6,
      toString: 1,
      fret: 2,
      text: "1",
    },
  },
  Bm: {
    fingers: [
      [2, 3, "2"],
      [3, 4, "4"],
      [4, 4, "3"],
      [6, "x"],
    ],
    barre: {
      fromString: 5,
      toString: 1,
      fret: 2,
      text: "1",
    },
  },
  C: {
    fingers: [
      [2, 1, "1"],
      [4, 2, "2"],
      [5, 3, "3"],
      [6, "x"],
    ],
    barre: null,
  },
  Cm: {
    fingers: [
      [2, 2, "2"],
      [3, 3, "4"],
      [4, 3, "3"],
      [6, "x"],
    ],
    barre: {
      fromString: 5,
      toString: 1,
      fret: 1,
      text: "1",
    },
    position: 3,
  },
  D: {
    fingers: [
      [1, 2, "2"],
      [2, 3, "3"],
      [3, 2, "1"],
      [5, "x"],
      [6, "x"],
    ],
    barre: null,
  },
  Dm: {
    fingers: [
      [1, 1, "1"],
      [2, 3, "3"],
      [3, 2, "2"],
      [5, "x"],
      [6, "x"],
    ],
    barre: null,
  },
  E: {
    fingers: [
      [3, 1, "3"],
      [4, 2, "2"],
      [5, 2, "1"],
    ],
    barre: null,
  },
  Em: {
    fingers: [
      [4, 2, "2"],
      [5, 2, "1"],
    ],
    barre: null,
  },
  F: {
    fingers: [
      [3, 2, "2"],
      [4, 3, "3"],
      [5, 3, "4"],
    ],
    barre: {
      fromString: 6,
      toString: 1,
      fret: 1,
      text: "1",
    },
  },
  Fm: {
    fingers: [
      [4, 3, "3"],
      [5, 3, "4"],
    ],
    barre: {
      fromString: 6,
      toString: 1,
      fret: 1,
      text: "1",
    },
  },
  G: {
    fingers: [
      [1, 3, "4"],
      [2, 3, "3"],
      [5, 2, "1"],
      [6, 3, "2"],
    ],
    barre: null,
  },
  Gm: {
    fingers: [
      [4, 3, "3"],
      [5, 3, "4"],
    ],
    barre: {
      fromString: 6,
      toString: 1,
      fret: 1,
      text: "1",
    },
    position: 3,
  },
};

/* src/App.svelte generated by Svelte v3.47.0 */

const { console: console_1$4 } = globals;
const file$c = "src/App.svelte";

function create_fragment$c(ctx) {
	let div;
	let header;
	let t0;
	let main;
	let router;
	let t1;
	let footer;
	let current;
	header = new Header({ $$inline: true });

	router = new Router({
			props: { routes: /*routes*/ ctx[0] },
			$$inline: true
		});

	router.$on("conditionsFailed", /*conditionsFailed*/ ctx[1]);
	footer = new Footer({ $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(header.$$.fragment);
			t0 = space();
			main = element("main");
			create_component(router.$$.fragment);
			t1 = space();
			create_component(footer.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(header.$$.fragment, div_nodes);
			t0 = claim_space(div_nodes);
			main = claim_element(div_nodes, "MAIN", { class: true });
			var main_nodes = children(main);
			claim_component(router.$$.fragment, main_nodes);
			main_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			claim_component(footer.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(main, "class", "svelte-kyx5z5");
			add_location(main, file$c, 102, 2, 2909);
			attr_dev(div, "class", "wrapper svelte-kyx5z5");
			add_location(div, file$c, 99, 0, 2871);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			mount_component(header, div, null);
			append_hydration_dev(div, t0);
			append_hydration_dev(div, main);
			mount_component(router, main, null);
			append_hydration_dev(div, t1);
			mount_component(footer, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(header.$$.fragment, local);
			transition_in(router.$$.fragment, local);
			transition_in(footer.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header.$$.fragment, local);
			transition_out(router.$$.fragment, local);
			transition_out(footer.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(header);
			destroy_component(router);
			destroy_component(footer);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$c($$self, $$props, $$invalidate) {
	let $db;
	validate_store(db, 'db');
	component_subscribe($$self, db, $$value => $$invalidate(2, $db = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('App', slots, []);

	const routes = {
		"/": Home,
		"/links": wrap({
			asyncComponent: () => Promise.resolve().then(function () { return index$3; })
		}),
		"/lessons": wrap({
			asyncComponent: () => Promise.resolve().then(function () { return index$2; }),
			conditions: [initialized],
			loadingComponent: Loading,
			loadingParams: { text: "Loading lessons..." }
		}),
		"/lesson/:id": wrap({
			asyncComponent: () => Promise.resolve().then(function () { return index$1; }),
			conditions: [initialized],
			loadingComponent: Loading,
			loadingParams: { text: "Loading lesson..." }
		}),
		"/new-lesson": wrap({
			asyncComponent: () => Promise.resolve().then(function () { return index; })
		}),
		"/error": Error$2,
		"*": _404
	};

	async function initDB(event) {
		await db.update(d => {
			d = event.target.result;
			d.onerror = e => console.error("IndexedDB Error: ", e?.target);
			d.initialized = true;
			return d;
		});
	}

	async function initialized() {
		try {
			if (!$db.initialized) {
				await loadFromIndexedDB();
			}

			return true;
		} catch(error) {
			console.error(error.message);
			return false;
		}
	}

	function loadFromIndexedDB() {
		return new Promise((resolve, reject) => {
				const dbRequest = window.indexedDB.open(DB_NAME, DB_VERSION);
				dbRequest.onerror = event => reject(Error$2(event?.target?.error || "Something bad happened"));

				dbRequest.onupgradeneeded = event => {
					const newDB = event.target.result;
					const objectStore = newDB.createObjectStore("lessons", { keyPath: "id" });
					objectStore.createIndex("title", "title", { unique: false });
					objectStore.createIndex("artist", "artist", { unique: false });
					console.info(`Initiated / Upgraded database ${DB_NAME} to version ${DB_VERSION}`);
				};

				dbRequest.onsuccess = async event => {
					await initDB(event);
					resolve();
				};
			});
	}

	function conditionsFailed(event) {
		console.error("conditionsFailed event", event.detail);

		// Perform any action, for example replacing the current route
		replace("/error");
	}

	onMount(() => {
		(async function init() {
			try {
				await loadFromIndexedDB();
			} catch(error) {
				console.error(error.message);
			}
		})();
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$4.warn(`<App> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		db,
		onMount,
		Router,
		replace,
		wrap,
		Home,
		NotFound: _404,
		Error: Error$2,
		Header,
		Footer,
		Loading,
		DB_NAME,
		DB_VERSION,
		routes,
		initDB,
		initialized,
		loadFromIndexedDB,
		conditionsFailed,
		$db
	});

	return [routes, conditionsFailed];
}

class App extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$c, create_fragment$c, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "App",
			options,
			id: create_fragment$c.name
		});
	}
}

const app = new App({
  target: document.body,
  hydrate: true,
});

/* src/pages/Links/index.svelte generated by Svelte v3.47.0 */

const file$b = "src/pages/Links/index.svelte";

function create_fragment$b(ctx) {
	let h1;
	let t0;
	let t1;
	let ul;
	let li0;
	let t2;
	let a0;
	let t3;
	let t4;
	let t5;
	let li1;
	let t6;
	let a1;
	let t7;
	let t8;
	let t9;
	let li2;
	let a2;
	let t10;
	let t11;
	let t12;
	let li3;
	let a3;
	let t13;
	let t14;
	let t15;
	let li4;
	let a4;
	let t16;
	let t17;
	let t18;
	let li5;
	let t19;
	let em;
	let t20;
	let t21;
	let a5;
	let t22;
	let t23;
	let t24;
	let li6;
	let t25;
	let a6;
	let t26;
	let t27;

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("Links to great guitar learning resources");
			t1 = space();
			ul = element("ul");
			li0 = element("li");
			t2 = text("Marty Schwartz is an awesome teacher and also has some fun non-educational videos. ");
			a0 = element("a");
			t3 = text("Here");
			t4 = text(" is his Youtube channel.");
			t5 = space();
			li1 = element("li");
			t6 = text("Justin Sandercoe is another great teacher and is especially helpful if you are a\n    beginner guitarist. Check out his ");
			a1 = element("a");
			t7 = text("channel");
			t8 = text(".");
			t9 = space();
			li2 = element("li");
			a2 = element("a");
			t10 = text("Paul Davids");
			t11 = text(" is more for entertainment\n    than for learning, but he often breaks down stuff for his viewers and is a great player.");
			t12 = space();
			li3 = element("li");
			a3 = element("a");
			t13 = text("Epic Guitar Instruction");
			t14 = text(" is\n    also a great channel for beginners. Tons of easy to follow tutorials for the beginning\n    and intermediate guitar player.");
			t15 = space();
			li4 = element("li");
			a4 = element("a");
			t16 = text("Rick Beato");
			t17 = text(" is like Paul Davids more for\n    entertainment than for learning, but he offers some great content, like breaking down song\n    structures and explaining why they work.");
			t18 = space();
			li5 = element("li");
			t19 = text("If you are from ");
			em = element("em");
			t20 = text("Germany");
			t21 = text(", make sure to check out Till from\n    ");
			a5 = element("a");
			t22 = text("GitarrenTunes");
			t23 = text(", probably the\n    best youtube teacher who speaks German.");
			t24 = space();
			li6 = element("li");
			t25 = text("The same goes for the spanish speaking crowd, check out ");
			a6 = element("a");
			t26 = text("Cifra Club");
			t27 = text(".");
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Links to great guitar learning resources");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			ul = claim_element(nodes, "UL", {});
			var ul_nodes = children(ul);
			li0 = claim_element(ul_nodes, "LI", { class: true });
			var li0_nodes = children(li0);
			t2 = claim_text(li0_nodes, "Marty Schwartz is an awesome teacher and also has some fun non-educational videos. ");
			a0 = claim_element(li0_nodes, "A", { href: true });
			var a0_nodes = children(a0);
			t3 = claim_text(a0_nodes, "Here");
			a0_nodes.forEach(detach_dev);
			t4 = claim_text(li0_nodes, " is his Youtube channel.");
			li0_nodes.forEach(detach_dev);
			t5 = claim_space(ul_nodes);
			li1 = claim_element(ul_nodes, "LI", { class: true });
			var li1_nodes = children(li1);
			t6 = claim_text(li1_nodes, "Justin Sandercoe is another great teacher and is especially helpful if you are a\n    beginner guitarist. Check out his ");
			a1 = claim_element(li1_nodes, "A", { href: true });
			var a1_nodes = children(a1);
			t7 = claim_text(a1_nodes, "channel");
			a1_nodes.forEach(detach_dev);
			t8 = claim_text(li1_nodes, ".");
			li1_nodes.forEach(detach_dev);
			t9 = claim_space(ul_nodes);
			li2 = claim_element(ul_nodes, "LI", { class: true });
			var li2_nodes = children(li2);
			a2 = claim_element(li2_nodes, "A", { href: true });
			var a2_nodes = children(a2);
			t10 = claim_text(a2_nodes, "Paul Davids");
			a2_nodes.forEach(detach_dev);
			t11 = claim_text(li2_nodes, " is more for entertainment\n    than for learning, but he often breaks down stuff for his viewers and is a great player.");
			li2_nodes.forEach(detach_dev);
			t12 = claim_space(ul_nodes);
			li3 = claim_element(ul_nodes, "LI", { class: true });
			var li3_nodes = children(li3);
			a3 = claim_element(li3_nodes, "A", { href: true });
			var a3_nodes = children(a3);
			t13 = claim_text(a3_nodes, "Epic Guitar Instruction");
			a3_nodes.forEach(detach_dev);
			t14 = claim_text(li3_nodes, " is\n    also a great channel for beginners. Tons of easy to follow tutorials for the beginning\n    and intermediate guitar player.");
			li3_nodes.forEach(detach_dev);
			t15 = claim_space(ul_nodes);
			li4 = claim_element(ul_nodes, "LI", { class: true });
			var li4_nodes = children(li4);
			a4 = claim_element(li4_nodes, "A", { href: true });
			var a4_nodes = children(a4);
			t16 = claim_text(a4_nodes, "Rick Beato");
			a4_nodes.forEach(detach_dev);
			t17 = claim_text(li4_nodes, " is like Paul Davids more for\n    entertainment than for learning, but he offers some great content, like breaking down song\n    structures and explaining why they work.");
			li4_nodes.forEach(detach_dev);
			t18 = claim_space(ul_nodes);
			li5 = claim_element(ul_nodes, "LI", { class: true });
			var li5_nodes = children(li5);
			t19 = claim_text(li5_nodes, "If you are from ");
			em = claim_element(li5_nodes, "EM", {});
			var em_nodes = children(em);
			t20 = claim_text(em_nodes, "Germany");
			em_nodes.forEach(detach_dev);
			t21 = claim_text(li5_nodes, ", make sure to check out Till from\n    ");
			a5 = claim_element(li5_nodes, "A", { href: true });
			var a5_nodes = children(a5);
			t22 = claim_text(a5_nodes, "GitarrenTunes");
			a5_nodes.forEach(detach_dev);
			t23 = claim_text(li5_nodes, ", probably the\n    best youtube teacher who speaks German.");
			li5_nodes.forEach(detach_dev);
			t24 = claim_space(ul_nodes);
			li6 = claim_element(ul_nodes, "LI", { class: true });
			var li6_nodes = children(li6);
			t25 = claim_text(li6_nodes, "The same goes for the spanish speaking crowd, check out ");
			a6 = claim_element(li6_nodes, "A", { href: true });
			var a6_nodes = children(a6);
			t26 = claim_text(a6_nodes, "Cifra Club");
			a6_nodes.forEach(detach_dev);
			t27 = claim_text(li6_nodes, ".");
			li6_nodes.forEach(detach_dev);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$b, 0, 0, 0);
			attr_dev(a0, "href", "https://www.youtube.com/c/martymusic");
			add_location(a0, file$b, 4, 87, 150);
			attr_dev(li0, "class", "svelte-1lsadx0");
			add_location(li0, file$b, 3, 2, 58);
			attr_dev(a1, "href", "https://www.youtube.com/c/justinguitar");
			add_location(a1, file$b, 10, 38, 375);
			attr_dev(li1, "class", "svelte-1lsadx0");
			add_location(li1, file$b, 8, 2, 247);
			attr_dev(a2, "href", "https://www.youtube.com/c/PaulDavids");
			add_location(a2, file$b, 16, 4, 469);
			attr_dev(li2, "class", "svelte-1lsadx0");
			add_location(li2, file$b, 15, 2, 460);
			attr_dev(a3, "href", "https://www.youtube.com/c/EpicGuitarInstruction");
			add_location(a3, file$b, 21, 4, 671);
			attr_dev(li3, "class", "svelte-1lsadx0");
			add_location(li3, file$b, 20, 2, 662);
			attr_dev(a4, "href", "https://www.youtube.com/c/RickBeato");
			add_location(a4, file$b, 27, 4, 907);
			attr_dev(li4, "class", "svelte-1lsadx0");
			add_location(li4, file$b, 26, 2, 898);
			add_location(em, file$b, 33, 20, 1173);
			attr_dev(a5, "href", "https://www.youtube.com/c/GitarrentunesDe");
			add_location(a5, file$b, 34, 4, 1228);
			attr_dev(li5, "class", "svelte-1lsadx0");
			add_location(li5, file$b, 32, 2, 1148);
			attr_dev(a6, "href", "https://www.youtube.com/c/cifraclub");
			add_location(a6, file$b, 39, 60, 1432);
			attr_dev(li6, "class", "svelte-1lsadx0");
			add_location(li6, file$b, 38, 2, 1367);
			add_location(ul, file$b, 2, 0, 51);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, h1, anchor);
			append_hydration_dev(h1, t0);
			insert_hydration_dev(target, t1, anchor);
			insert_hydration_dev(target, ul, anchor);
			append_hydration_dev(ul, li0);
			append_hydration_dev(li0, t2);
			append_hydration_dev(li0, a0);
			append_hydration_dev(a0, t3);
			append_hydration_dev(li0, t4);
			append_hydration_dev(ul, t5);
			append_hydration_dev(ul, li1);
			append_hydration_dev(li1, t6);
			append_hydration_dev(li1, a1);
			append_hydration_dev(a1, t7);
			append_hydration_dev(li1, t8);
			append_hydration_dev(ul, t9);
			append_hydration_dev(ul, li2);
			append_hydration_dev(li2, a2);
			append_hydration_dev(a2, t10);
			append_hydration_dev(li2, t11);
			append_hydration_dev(ul, t12);
			append_hydration_dev(ul, li3);
			append_hydration_dev(li3, a3);
			append_hydration_dev(a3, t13);
			append_hydration_dev(li3, t14);
			append_hydration_dev(ul, t15);
			append_hydration_dev(ul, li4);
			append_hydration_dev(li4, a4);
			append_hydration_dev(a4, t16);
			append_hydration_dev(li4, t17);
			append_hydration_dev(ul, t18);
			append_hydration_dev(ul, li5);
			append_hydration_dev(li5, t19);
			append_hydration_dev(li5, em);
			append_hydration_dev(em, t20);
			append_hydration_dev(li5, t21);
			append_hydration_dev(li5, a5);
			append_hydration_dev(a5, t22);
			append_hydration_dev(li5, t23);
			append_hydration_dev(ul, t24);
			append_hydration_dev(ul, li6);
			append_hydration_dev(li6, t25);
			append_hydration_dev(li6, a6);
			append_hydration_dev(a6, t26);
			append_hydration_dev(li6, t27);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(ul);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Links', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Links> was created with unknown prop '${key}'`);
	});

	return [];
}

class Links extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Links",
			options,
			id: create_fragment$b.name
		});
	}
}

var index$3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': Links
});

/* src/components/Error.svelte generated by Svelte v3.47.0 */

const { Error: Error_1$2, console: console_1$3 } = globals;
const file$a = "src/components/Error.svelte";

function create_fragment$a(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(/*errorMessage*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, /*errorMessage*/ ctx[0]);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svelte-3sgp1q");
			toggle_class(div, "show", /*error*/ ctx[1]);
			add_location(div, file$a, 7, 0, 152);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*errorMessage*/ 1) set_data_dev(t, /*errorMessage*/ ctx[0]);

			if (dirty & /*error*/ 2) {
				toggle_class(div, "show", /*error*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Error', slots, []);
	let { errorMessage = "Sorry, something went wrong " } = $$props;
	let { error = null } = $$props;
	const writable_props = ['errorMessage', 'error'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$3.warn(`<Error> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('errorMessage' in $$props) $$invalidate(0, errorMessage = $$props.errorMessage);
		if ('error' in $$props) $$invalidate(1, error = $$props.error);
	};

	$$self.$capture_state = () => ({ errorMessage, error });

	$$self.$inject_state = $$props => {
		if ('errorMessage' in $$props) $$invalidate(0, errorMessage = $$props.errorMessage);
		if ('error' in $$props) $$invalidate(1, error = $$props.error);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*error*/ 2) {
			error ? console.error(error) : null;
		}
	};

	return [errorMessage, error];
}

class Error$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { errorMessage: 0, error: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Error",
			options,
			id: create_fragment$a.name
		});
	}

	get errorMessage() {
		throw new Error_1$2("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errorMessage(value) {
		throw new Error_1$2("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get error() {
		throw new Error_1$2("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set error(value) {
		throw new Error_1$2("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/pages/Lessons/index.svelte generated by Svelte v3.47.0 */

const { Object: Object_1$1 } = globals;
const file$9 = "src/pages/Lessons/index.svelte";

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i].id;
	child_ctx[17] = list[i].title;
	child_ctx[18] = list[i].totalTime;
	child_ctx[19] = list[i].artist;
	child_ctx[20] = list[i].finished;
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[23] = list[i];
	return child_ctx;
}

function get_each_context_2$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[26] = list[i];
	return child_ctx;
}

// (192:2) {:else}
function create_else_block_1$2(ctx) {
	let div;
	let t0;
	let t1;
	let a;
	let t2;

	const block = {
		c: function create() {
			div = element("div");
			t0 = text("No lessons yet");
			t1 = space();
			a = element("a");
			t2 = text("Create a new One");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, "No lessons yet");
			div_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			a = claim_element(nodes, "A", { href: true });
			var a_nodes = children(a);
			t2 = claim_text(a_nodes, "Create a new One");
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$9, 192, 4, 5458);
			attr_dev(a, "href", "#/new-lesson");
			add_location(a, file$9, 193, 4, 5488);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t0);
			insert_hydration_dev(target, t1, anchor);
			insert_hydration_dev(target, a, anchor);
			append_hydration_dev(a, t2);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(a);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$2.name,
		type: "else",
		source: "(192:2) {:else}",
		ctx
	});

	return block;
}

// (135:2) {#if lessons && lessons.length > 0}
function create_if_block_1$3(ctx) {
	let div1;
	let input;
	let t0;
	let div0;
	let span;
	let t1;
	let t2;
	let t3;
	let ul;
	let t4;
	let button;
	let t5;
	let current;
	let mounted;
	let dispose;
	let each_value_1 = /*sortOptions*/ ctx[8];
	validate_each_argument(each_value_1);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	}

	let each_value = /*filteredSongs*/ ctx[6];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			div1 = element("div");
			input = element("input");
			t0 = space();
			div0 = element("div");
			span = element("span");
			t1 = text("Sort By:");
			t2 = space();

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t3 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t4 = space();
			button = element("button");
			t5 = text("Export Data");
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			input = claim_element(div1_nodes, "INPUT", { placeholder: true });
			t0 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			span = claim_element(div0_nodes, "SPAN", {});
			var span_nodes = children(span);
			t1 = claim_text(span_nodes, "Sort By:");
			span_nodes.forEach(detach_dev);
			t2 = claim_space(div0_nodes);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			ul = claim_element(nodes, "UL", {});
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			t4 = claim_space(nodes);
			button = claim_element(nodes, "BUTTON", {});
			var button_nodes = children(button);
			t5 = claim_text(button_nodes, "Export Data");
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "placeholder", "Filter Songs");
			add_location(input, file$9, 136, 6, 3551);
			add_location(span, file$9, 139, 8, 3633);
			attr_dev(div0, "class", "sort svelte-hr8yu7");
			add_location(div0, file$9, 138, 6, 3606);
			attr_dev(div1, "class", "filter-sort svelte-hr8yu7");
			add_location(div1, file$9, 135, 4, 3519);
			add_location(ul, file$9, 156, 4, 4215);
			add_location(button, file$9, 190, 4, 5393);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div1, anchor);
			append_hydration_dev(div1, input);
			set_input_value(input, /*value*/ ctx[1]);
			append_hydration_dev(div1, t0);
			append_hydration_dev(div1, div0);
			append_hydration_dev(div0, span);
			append_hydration_dev(span, t1);
			append_hydration_dev(div0, t2);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div0, null);
			}

			insert_hydration_dev(target, t3, anchor);
			insert_hydration_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			insert_hydration_dev(target, t4, anchor);
			insert_hydration_dev(target, button, anchor);
			append_hydration_dev(button, t5);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_input_handler*/ ctx[13]),
					listen_dev(button, "click", /*exportData*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*value*/ 2 && input.value !== /*value*/ ctx[1]) {
				set_input_value(input, /*value*/ ctx[1]);
			}

			if (dirty & /*sortOptions, sortOption*/ 260) {
				each_value_1 = /*sortOptions*/ ctx[8];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1$1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(div0, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (dirty & /*deleteErrorID, filteredSongs, deleteError, deleteLesson, computePracticeTime*/ 2160) {
				each_value = /*filteredSongs*/ ctx[6];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_each(each_blocks_1, detaching);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(button);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(135:2) {#if lessons && lessons.length > 0}",
		ctx
	});

	return block;
}

// (143:10) {#each ["down", "up"] as direction}
function create_each_block_2$1(ctx) {
	let button;
	let i;
	let t;
	let mounted;
	let dispose;

	function click_handler_1() {
		return /*click_handler_1*/ ctx[14](/*option*/ ctx[23], /*direction*/ ctx[26]);
	}

	const block = {
		c: function create() {
			button = element("button");
			i = element("i");
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {
				"aria-label": true,
				title: true,
				class: true
			});

			var button_nodes = children(button);
			i = claim_element(button_nodes, "I", { class: true });
			children(i).forEach(detach_dev);
			t = claim_space(button_nodes);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(i, "class", "" + (null_to_empty(`fa-solid fa-arrow-${/*direction*/ ctx[26]}-a-z`) + " svelte-hr8yu7"));
			add_location(i, file$9, 149, 14, 4079);
			attr_dev(button, "aria-label", `Sort ${/*option*/ ctx[23]} a-z`);
			attr_dev(button, "title", `Sort ${/*option*/ ctx[23]} a-z`);
			attr_dev(button, "class", "naked-button svelte-hr8yu7");
			toggle_class(button, "button-active", /*sortOption*/ ctx[2] == `${/*option*/ ctx[23]}-${/*direction*/ ctx[26]}`);
			add_location(button, file$9, 143, 12, 3784);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, button, anchor);
			append_hydration_dev(button, i);
			append_hydration_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(button, "click", click_handler_1, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*sortOption, sortOptions*/ 260) {
				toggle_class(button, "button-active", /*sortOption*/ ctx[2] == `${/*option*/ ctx[23]}-${/*direction*/ ctx[26]}`);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2$1.name,
		type: "each",
		source: "(143:10) {#each [\\\"down\\\", \\\"up\\\"] as direction}",
		ctx
	});

	return block;
}

// (141:8) {#each sortOptions as option}
function create_each_block_1$1(ctx) {
	let span;
	let t0_value = /*option*/ ctx[23] + "";
	let t0;
	let t1;
	let each_1_anchor;
	let each_value_2 = ["down", "up"];
	validate_each_argument(each_value_2);
	let each_blocks = [];

	for (let i = 0; i < 2; i += 1) {
		each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
	}

	const block = {
		c: function create() {
			span = element("span");
			t0 = text(t0_value);
			t1 = space();

			for (let i = 0; i < 2; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, t0_value);
			span_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);

			for (let i = 0; i < 2; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(span, file$9, 141, 10, 3704);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t0);
			insert_hydration_dev(target, t1, anchor);

			for (let i = 0; i < 2; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_hydration_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*sortOptions, sortOption*/ 260) {
				each_value_2 = ["down", "up"];
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < 2; i += 1) {
					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < 2; i += 1) {
					each_blocks[i].d(1);
				}
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (detaching) detach_dev(t1);
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$1.name,
		type: "each",
		source: "(141:8) {#each sortOptions as option}",
		ctx
	});

	return block;
}

// (171:12) {:else}
function create_else_block$3(ctx) {
	let i;

	const block = {
		c: function create() {
			i = element("i");
			this.h();
		},
		l: function claim(nodes) {
			i = claim_element(nodes, "I", { title: true, class: true });
			children(i).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(i, "title", "Start practicing");
			attr_dev(i, "class", "fa fa-hourglass-start");
			add_location(i, file$9, 171, 14, 4795);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, i, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(i);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$3.name,
		type: "else",
		source: "(171:12) {:else}",
		ctx
	});

	return block;
}

// (167:31) 
function create_if_block_4$2(ctx) {
	let i;

	const block = {
		c: function create() {
			i = element("i");
			this.h();
		},
		l: function claim(nodes) {
			i = claim_element(nodes, "I", { title: true, class: true });
			children(i).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(i, "title", "Keep goin. The way to mastery is long.");
			attr_dev(i, "class", "fa fa-hourglass-end");
			add_location(i, file$9, 167, 14, 4648);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, i, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(i);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$2.name,
		type: "if",
		source: "(167:31) ",
		ctx
	});

	return block;
}

// (164:12) {#if totalTime}
function create_if_block_3$2(ctx) {
	let i;
	let t0;
	let t1_value = computePracticeTime(/*totalTime*/ ctx[18]) + "";
	let t1;

	const block = {
		c: function create() {
			i = element("i");
			t0 = space();
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			i = claim_element(nodes, "I", { title: true, class: true });
			children(i).forEach(detach_dev);
			t0 = claim_space(nodes);
			t1 = claim_text(nodes, t1_value);
			this.h();
		},
		h: function hydrate() {
			attr_dev(i, "title", "Keep practicing");
			attr_dev(i, "class", "fa fa-hourglass-half");
			add_location(i, file$9, 164, 14, 4496);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, i, anchor);
			insert_hydration_dev(target, t0, anchor);
			insert_hydration_dev(target, t1, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*filteredSongs*/ 64 && t1_value !== (t1_value = computePracticeTime(/*totalTime*/ ctx[18]) + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(i);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$2.name,
		type: "if",
		source: "(164:12) {#if totalTime}",
		ctx
	});

	return block;
}

// (175:10) {#if finished}
function create_if_block_2$2(ctx) {
	let i;

	const block = {
		c: function create() {
			i = element("i");
			this.h();
		},
		l: function claim(nodes) {
			i = claim_element(nodes, "I", { title: true, class: true });
			children(i).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(i, "title", "Congrats, you finished this lesson");
			attr_dev(i, "class", "fa fa-trophy svelte-hr8yu7");
			add_location(i, file$9, 175, 12, 4928);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, i, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(i);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(175:10) {#if finished}",
		ctx
	});

	return block;
}

// (158:6) {#each filteredSongs as { id, title, totalTime, artist, finished }}
function create_each_block$4(ctx) {
	let li;
	let a;
	let t0_value = /*title*/ ctx[17] + "";
	let t0;
	let t1;
	let t2_value = /*artist*/ ctx[19] + "";
	let t2;
	let a_href_value;
	let t3;
	let div;
	let t4;
	let t5;
	let button;
	let i;
	let t6;
	let error_1;
	let t7;
	let current;
	let mounted;
	let dispose;

	function select_block_type_1(ctx, dirty) {
		if (/*totalTime*/ ctx[18]) return create_if_block_3$2;
		if (/*finished*/ ctx[20]) return create_if_block_4$2;
		return create_else_block$3;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*finished*/ ctx[20] && create_if_block_2$2(ctx);

	function click_handler_2() {
		return /*click_handler_2*/ ctx[15](/*id*/ ctx[16]);
	}

	error_1 = new Error$1({
			props: {
				error: /*deleteErrorID*/ ctx[4] == /*id*/ ctx[16]
				? /*deleteError*/ ctx[5]
				: null,
				errorMessage: `Sorry, couldn't delete ${/*title*/ ctx[17]}`
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = text(" - ");
			t2 = text(t2_value);
			t3 = space();
			div = element("div");
			if_block0.c();
			t4 = space();
			if (if_block1) if_block1.c();
			t5 = space();
			button = element("button");
			i = element("i");
			t6 = space();
			create_component(error_1.$$.fragment);
			t7 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { class: true, href: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			t1 = claim_text(a_nodes, " - ");
			t2 = claim_text(a_nodes, t2_value);
			a_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			div = claim_element(li_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if_block0.l(div_nodes);
			div_nodes.forEach(detach_dev);
			t4 = claim_space(li_nodes);
			if (if_block1) if_block1.l(li_nodes);
			t5 = claim_space(li_nodes);
			button = claim_element(li_nodes, "BUTTON", { title: true, class: true });
			var button_nodes = children(button);
			i = claim_element(button_nodes, "I", { class: true });
			children(i).forEach(detach_dev);
			button_nodes.forEach(detach_dev);
			t6 = claim_space(li_nodes);
			claim_component(error_1.$$.fragment, li_nodes);
			t7 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "class", "fancy-link svelte-hr8yu7");
			attr_dev(a, "href", a_href_value = `#/lesson/${/*id*/ ctx[16]}`);
			add_location(a, file$9, 159, 10, 4332);
			attr_dev(div, "class", "time");
			add_location(div, file$9, 162, 10, 4435);
			attr_dev(i, "class", "fa fa-trash-alt");
			add_location(i, file$9, 181, 12, 5158);
			attr_dev(button, "title", "Delete Lesson");
			attr_dev(button, "class", "naked-button svelte-hr8yu7");
			add_location(button, file$9, 177, 10, 5024);
			attr_dev(li, "class", "lesson svelte-hr8yu7");
			add_location(li, file$9, 158, 8, 4302);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, li, anchor);
			append_hydration_dev(li, a);
			append_hydration_dev(a, t0);
			append_hydration_dev(a, t1);
			append_hydration_dev(a, t2);
			append_hydration_dev(li, t3);
			append_hydration_dev(li, div);
			if_block0.m(div, null);
			append_hydration_dev(li, t4);
			if (if_block1) if_block1.m(li, null);
			append_hydration_dev(li, t5);
			append_hydration_dev(li, button);
			append_hydration_dev(button, i);
			append_hydration_dev(li, t6);
			mount_component(error_1, li, null);
			append_hydration_dev(li, t7);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", click_handler_2, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty & /*filteredSongs*/ 64) && t0_value !== (t0_value = /*title*/ ctx[17] + "")) set_data_dev(t0, t0_value);
			if ((!current || dirty & /*filteredSongs*/ 64) && t2_value !== (t2_value = /*artist*/ ctx[19] + "")) set_data_dev(t2, t2_value);

			if (!current || dirty & /*filteredSongs*/ 64 && a_href_value !== (a_href_value = `#/lesson/${/*id*/ ctx[16]}`)) {
				attr_dev(a, "href", a_href_value);
			}

			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div, null);
				}
			}

			if (/*finished*/ ctx[20]) {
				if (if_block1) ; else {
					if_block1 = create_if_block_2$2(ctx);
					if_block1.c();
					if_block1.m(li, t5);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			const error_1_changes = {};

			if (dirty & /*deleteErrorID, filteredSongs, deleteError*/ 112) error_1_changes.error = /*deleteErrorID*/ ctx[4] == /*id*/ ctx[16]
			? /*deleteError*/ ctx[5]
			: null;

			if (dirty & /*filteredSongs*/ 64) error_1_changes.errorMessage = `Sorry, couldn't delete ${/*title*/ ctx[17]}`;
			error_1.$set(error_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if_block0.d();
			if (if_block1) if_block1.d();
			destroy_component(error_1);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$4.name,
		type: "each",
		source: "(158:6) {#each filteredSongs as { id, title, totalTime, artist, finished }}",
		ctx
	});

	return block;
}

// (202:2) {#if error}
function create_if_block$6(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(/*error*/ ctx[3]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, /*error*/ ctx[3]);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "error");
			add_location(div, file$9, 202, 4, 5690);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*error*/ 8) set_data_dev(t, /*error*/ ctx[3]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$6.name,
		type: "if",
		source: "(202:2) {#if error}",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let section;
	let h1;
	let t0;
	let t1;
	let button;
	let t2;
	let t3;
	let current_block_type_index;
	let if_block0;
	let t4;
	let label;
	let t5;
	let input;
	let t6;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_1$3, create_else_block_1$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*lessons*/ ctx[0] && /*lessons*/ ctx[0].length > 0) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*error*/ ctx[3] && create_if_block$6(ctx);

	const block = {
		c: function create() {
			section = element("section");
			h1 = element("h1");
			t0 = text("Click a Lesson to start practicing");
			t1 = space();
			button = element("button");
			t2 = text("UPDATE");
			t3 = space();
			if_block0.c();
			t4 = space();
			label = element("label");
			t5 = text("Import lessons: ");
			input = element("input");
			t6 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", {});
			var section_nodes = children(section);
			h1 = claim_element(section_nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Click a Lesson to start practicing");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(section_nodes);
			button = claim_element(section_nodes, "BUTTON", {});
			var button_nodes = children(button);
			t2 = claim_text(button_nodes, "UPDATE");
			button_nodes.forEach(detach_dev);
			t3 = claim_space(section_nodes);
			if_block0.l(section_nodes);
			t4 = claim_space(section_nodes);
			label = claim_element(section_nodes, "LABEL", {});
			var label_nodes = children(label);
			t5 = claim_text(label_nodes, "Import lessons: ");
			input = claim_element(label_nodes, "INPUT", { accept: true, type: true });
			label_nodes.forEach(detach_dev);
			t6 = claim_space(section_nodes);
			if (if_block1) if_block1.l(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h1, "class", "svelte-hr8yu7");
			add_location(h1, file$9, 125, 2, 3210);
			add_location(button, file$9, 126, 2, 3256);
			attr_dev(input, "accept", ".json");
			attr_dev(input, "type", "file");
			add_location(input, file$9, 196, 21, 5570);
			add_location(label, file$9, 195, 2, 5542);
			add_location(section, file$9, 124, 0, 3198);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, section, anchor);
			append_hydration_dev(section, h1);
			append_hydration_dev(h1, t0);
			append_hydration_dev(section, t1);
			append_hydration_dev(section, button);
			append_hydration_dev(button, t2);
			append_hydration_dev(section, t3);
			if_blocks[current_block_type_index].m(section, null);
			append_hydration_dev(section, t4);
			append_hydration_dev(section, label);
			append_hydration_dev(label, t5);
			append_hydration_dev(label, input);
			append_hydration_dev(section, t6);
			if (if_block1) if_block1.m(section, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button, "click", /*click_handler*/ ctx[12], false, false, false),
					listen_dev(input, "change", prevent_default(/*importData*/ ctx[10]), false, true, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(section, t4);
			}

			if (/*error*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$6(ctx);
					if_block1.c();
					if_block1.m(section, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function computePracticeTime(totalTime) {
	const time = {
		d: Math.floor(totalTime / (60 * 60 * 24)),
		h: Math.floor(totalTime % (60 * 60 * 24) / 3600),
		m: Math.floor(totalTime % 3600 / 60),
		s: Math.floor(totalTime % 60)
	};

	return Object.keys(time).reduce(
		(acc, cV) => {
			return acc.concat(time[cV] ? `${time[cV]}${cV} ` : "");
		},
		""
	);
}

function instance$9($$self, $$props, $$invalidate) {
	let filteredSongs;
	let $db;
	validate_store(db, 'db');
	component_subscribe($$self, db, $$value => $$invalidate(7, $db = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Lessons', slots, []);
	let lessons;
	let error = null;
	let deleteErrorID = null;
	let deleteError = null;
	let value = "";
	let sortOption = "Song-down";
	const sortOptions = ["Song", "Artist"];

	async function exportData() {
		try {
			const stringifiedLessons = JSON.stringify(lessons);
			const blob = new Blob([stringifiedLessons], { type: "text/json" });
			const link = document.createElement("a");
			link.download = "lessons.json";
			link.href = window.URL.createObjectURL(blob);
			link.dataset.downloadurl = `text/json:${link.download}${link.href}`;

			const event = new MouseEvent("click",
			{
					view: window,
					bubbles: true,
					cancelable: true
				});

			link.dispatchEvent(event);
			link.remove();
		} catch(err) {
			$$invalidate(3, error = err.message);
		}
	}

	async function importData(e) {
		try {
			$$invalidate(3, error = null);
			const files = e.target.files;

			if (files.length == 0) {
				return;
			}

			const file = files[0];

			if (file.type != "application/json") {
				throw new Error$1("Only JSON files allowed!");
			}

			let reader = new FileReader();

			reader.onload = e => {
				const stringifiedLessons = e.target.result;
				const importedLessons = JSON.parse(stringifiedLessons);
				const lessonStore = $db.transaction("lessons", "readwrite").objectStore("lessons");
				importedLessons.forEach(lesson => lessonStore.put(lesson));
				$$invalidate(0, lessons = importedLessons);
			};

			reader.onerror = e => {
				throw new Error$1(e.target.error.name);
			};

			reader.readAsText(file);
		} catch(err) {
			$$invalidate(3, error = err.message);
		}
	}

	async function deleteLesson(id) {
		try {
			await transaction("delete", id, "readwrite");
			$$invalidate(0, lessons = lessons.filter(lesson => lesson.id != id));
		} catch(err) {
			$$invalidate(5, deleteError = err);
			$$invalidate(4, deleteErrorID = id);
		}
	}

	onMount(() => {
		(async function setup() {
			$$invalidate(0, lessons = await transaction("getAll") || null);
		})();
	});

	const writable_props = [];

	Object_1$1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Lessons> was created with unknown prop '${key}'`);
	});

	const click_handler = () => {
		const lessonStore = $db.transaction("lessons", "readwrite").objectStore("lessons");

		lessons.forEach(lesson => {
			lessonStore.put(lesson);
		});
	};

	function input_input_handler() {
		value = this.value;
		$$invalidate(1, value);
	}

	const click_handler_1 = (option, direction) => $$invalidate(2, sortOption = `${option}-${direction}`);
	const click_handler_2 = id => deleteLesson(id);

	$$self.$capture_state = () => ({
		db,
		onMount,
		transaction,
		Error: Error$1,
		lessons,
		error,
		deleteErrorID,
		deleteError,
		value,
		sortOption,
		sortOptions,
		computePracticeTime,
		exportData,
		importData,
		deleteLesson,
		filteredSongs,
		$db
	});

	$$self.$inject_state = $$props => {
		if ('lessons' in $$props) $$invalidate(0, lessons = $$props.lessons);
		if ('error' in $$props) $$invalidate(3, error = $$props.error);
		if ('deleteErrorID' in $$props) $$invalidate(4, deleteErrorID = $$props.deleteErrorID);
		if ('deleteError' in $$props) $$invalidate(5, deleteError = $$props.deleteError);
		if ('value' in $$props) $$invalidate(1, value = $$props.value);
		if ('sortOption' in $$props) $$invalidate(2, sortOption = $$props.sortOption);
		if ('filteredSongs' in $$props) $$invalidate(6, filteredSongs = $$props.filteredSongs);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*lessons, sortOption, value*/ 7) {
			$$invalidate(6, filteredSongs = lessons?.sort((a, b) => {
				const [option, direction] = sortOption.split("-");
				const itemA = a[option == "Song" ? "title" : "artist"].toLowerCase();
				const itemB = b[option == "Song" ? "title" : "artist"].toLowerCase();

				if (itemA < itemB) {
					return direction == "up" ? 1 : -1;
				}

				if (itemA > itemB) {
					return direction == "up" ? -1 : 1;
				}

				return 0;
			}).filter(lesson => lesson.title?.toLowerCase().includes(value)) || []);
		}
	};

	return [
		lessons,
		value,
		sortOption,
		error,
		deleteErrorID,
		deleteError,
		filteredSongs,
		$db,
		sortOptions,
		exportData,
		importData,
		deleteLesson,
		click_handler,
		input_input_handler,
		click_handler_1,
		click_handler_2
	];
}

class Lessons extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Lessons",
			options,
			id: create_fragment$9.name
		});
	}
}

var index$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': Lessons
});

/* src/components/VideoSnippet.svelte generated by Svelte v3.47.0 */

const file$8 = "src/components/VideoSnippet.svelte";

// (6:2) {#if snippet}
function create_if_block$5(ctx) {
	let div;
	let img;
	let img_alt_value;
	let img_src_value;
	let img_width_value;
	let img_height_value;
	let t0;
	let h1;
	let t1_value = /*snippet*/ ctx[0].title + "";
	let t1;
	let t2;
	let p;
	let t3_value = /*snippet*/ ctx[0].description + "";
	let t3;

	const block = {
		c: function create() {
			div = element("div");
			img = element("img");
			t0 = space();
			h1 = element("h1");
			t1 = text(t1_value);
			t2 = space();
			p = element("p");
			t3 = text(t3_value);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			img = claim_element(div_nodes, "IMG", {
				alt: true,
				src: true,
				width: true,
				height: true,
				class: true
			});

			div_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			h1 = claim_element(nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t1 = claim_text(h1_nodes, t1_value);
			h1_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			t3 = claim_text(p_nodes, t3_value);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(img, "alt", img_alt_value = /*snippet*/ ctx[0].title);
			if (!src_url_equal(img.src, img_src_value = /*snippet*/ ctx[0].thumbnails.medium.url)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "width", img_width_value = /*snippet*/ ctx[0].thumbnails.medium.width);
			attr_dev(img, "height", img_height_value = /*snippet*/ ctx[0].thumbnails.medium.height);
			attr_dev(img, "class", "svelte-18andtt");
			add_location(img, file$8, 7, 6, 106);
			attr_dev(div, "class", "image-wrapper");
			add_location(div, file$8, 6, 4, 72);
			attr_dev(h1, "class", "svelte-18andtt");
			add_location(h1, file$8, 14, 4, 305);
			attr_dev(p, "class", "svelte-18andtt");
			add_location(p, file$8, 15, 4, 334);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, img);
			insert_hydration_dev(target, t0, anchor);
			insert_hydration_dev(target, h1, anchor);
			append_hydration_dev(h1, t1);
			insert_hydration_dev(target, t2, anchor);
			insert_hydration_dev(target, p, anchor);
			append_hydration_dev(p, t3);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*snippet*/ 1 && img_alt_value !== (img_alt_value = /*snippet*/ ctx[0].title)) {
				attr_dev(img, "alt", img_alt_value);
			}

			if (dirty & /*snippet*/ 1 && !src_url_equal(img.src, img_src_value = /*snippet*/ ctx[0].thumbnails.medium.url)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty & /*snippet*/ 1 && img_width_value !== (img_width_value = /*snippet*/ ctx[0].thumbnails.medium.width)) {
				attr_dev(img, "width", img_width_value);
			}

			if (dirty & /*snippet*/ 1 && img_height_value !== (img_height_value = /*snippet*/ ctx[0].thumbnails.medium.height)) {
				attr_dev(img, "height", img_height_value);
			}

			if (dirty & /*snippet*/ 1 && t1_value !== (t1_value = /*snippet*/ ctx[0].title + "")) set_data_dev(t1, t1_value);
			if (dirty & /*snippet*/ 1 && t3_value !== (t3_value = /*snippet*/ ctx[0].description + "")) set_data_dev(t3, t3_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(6:2) {#if snippet}",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let section;
	let if_block = /*snippet*/ ctx[0] && create_if_block$5(ctx);

	const block = {
		c: function create() {
			section = element("section");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			if (if_block) if_block.l(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "class", "svelte-18andtt");
			add_location(section, file$8, 4, 0, 42);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, section, anchor);
			if (if_block) if_block.m(section, null);
		},
		p: function update(ctx, [dirty]) {
			if (/*snippet*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$5(ctx);
					if_block.c();
					if_block.m(section, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('VideoSnippet', slots, []);
	let { snippet } = $$props;
	const writable_props = ['snippet'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<VideoSnippet> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('snippet' in $$props) $$invalidate(0, snippet = $$props.snippet);
	};

	$$self.$capture_state = () => ({ snippet });

	$$self.$inject_state = $$props => {
		if ('snippet' in $$props) $$invalidate(0, snippet = $$props.snippet);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [snippet];
}

class VideoSnippet extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { snippet: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "VideoSnippet",
			options,
			id: create_fragment$8.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*snippet*/ ctx[0] === undefined && !('snippet' in props)) {
			console.warn("<VideoSnippet> was created without expected prop 'snippet'");
		}
	}

	get snippet() {
		throw new Error("<VideoSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set snippet(value) {
		throw new Error("<VideoSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/pages/Lesson/Stopwatch.svelte generated by Svelte v3.47.0 */

const { document: document_1 } = globals;
const file$7 = "src/pages/Lesson/Stopwatch.svelte";

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i].title;
	child_ctx[18] = list[i].click;
	child_ctx[19] = list[i].icon;
	return child_ctx;
}

// (99:6) {#each buttons as { title, click, icon }}
function create_each_block$3(ctx) {
	let button;
	let i;
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			i = element("i");
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { type: true, title: true, class: true });
			var button_nodes = children(button);
			i = claim_element(button_nodes, "I", { class: true });
			children(i).forEach(detach_dev);
			t = claim_space(button_nodes);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(i, "class", "" + (null_to_empty(`fa fa-${/*icon*/ ctx[19]}-circle`) + " svelte-5940q5"));
			add_location(i, file$7, 100, 10, 2005);
			attr_dev(button, "type", "button");
			attr_dev(button, "title", /*title*/ ctx[3]);
			attr_dev(button, "class", "svelte-5940q5");
			add_location(button, file$7, 99, 8, 1947);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, button, anchor);
			append_hydration_dev(button, i);
			append_hydration_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click*/ ctx[18], false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$3.name,
		type: "each",
		source: "(99:6) {#each buttons as { title, click, icon }}",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let title_value;
	let t0;
	let section;
	let form;
	let div0;
	let t1;
	let div1;
	let t2;
	let t3;
	let span0;
	let t4;
	let t5;
	let div2;
	let t6;
	let t7;
	let span1;
	let t8;
	let t9;
	let div3;
	let t10;
	let mounted;
	let dispose;
	document_1.title = title_value = /*title*/ ctx[3];
	let each_value = /*buttons*/ ctx[5];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			t0 = space();
			section = element("section");
			form = element("form");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			div1 = element("div");
			t2 = text(/*normalizedHours*/ ctx[2]);
			t3 = space();
			span0 = element("span");
			t4 = text(":");
			t5 = space();
			div2 = element("div");
			t6 = text(/*normalizedMinutes*/ ctx[1]);
			t7 = space();
			span1 = element("span");
			t8 = text(":");
			t9 = space();
			div3 = element("div");
			t10 = text(/*normalizedSeconds*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all('[data-svelte=\"svelte-1258swp\"]', document_1.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			section = claim_element(nodes, "SECTION", {});
			var section_nodes = children(section);
			form = claim_element(section_nodes, "FORM", { class: true });
			var form_nodes = children(form);
			div0 = claim_element(form_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach_dev);
			t1 = claim_space(form_nodes);
			div1 = claim_element(form_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			t2 = claim_text(div1_nodes, /*normalizedHours*/ ctx[2]);
			div1_nodes.forEach(detach_dev);
			t3 = claim_space(form_nodes);
			span0 = claim_element(form_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t4 = claim_text(span0_nodes, ":");
			span0_nodes.forEach(detach_dev);
			t5 = claim_space(form_nodes);
			div2 = claim_element(form_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			t6 = claim_text(div2_nodes, /*normalizedMinutes*/ ctx[1]);
			div2_nodes.forEach(detach_dev);
			t7 = claim_space(form_nodes);
			span1 = claim_element(form_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			t8 = claim_text(span1_nodes, ":");
			span1_nodes.forEach(detach_dev);
			t9 = claim_space(form_nodes);
			div3 = claim_element(form_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			t10 = claim_text(div3_nodes, /*normalizedSeconds*/ ctx[0]);
			div3_nodes.forEach(detach_dev);
			form_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "controls svelte-5940q5");
			add_location(div0, file$7, 97, 4, 1868);
			attr_dev(div1, "class", "time svelte-5940q5");
			add_location(div1, file$7, 104, 4, 2089);
			attr_dev(span0, "class", "svelte-5940q5");
			add_location(span0, file$7, 105, 4, 2135);
			attr_dev(div2, "class", "time svelte-5940q5");
			add_location(div2, file$7, 106, 4, 2154);
			attr_dev(span1, "class", "svelte-5940q5");
			add_location(span1, file$7, 107, 4, 2202);
			attr_dev(div3, "class", "time svelte-5940q5");
			add_location(div3, file$7, 108, 4, 2221);
			attr_dev(form, "class", "svelte-5940q5");
			add_location(form, file$7, 96, 2, 1826);
			add_location(section, file$7, 95, 0, 1814);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t0, anchor);
			insert_hydration_dev(target, section, anchor);
			append_hydration_dev(section, form);
			append_hydration_dev(form, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			append_hydration_dev(form, t1);
			append_hydration_dev(form, div1);
			append_hydration_dev(div1, t2);
			append_hydration_dev(form, t3);
			append_hydration_dev(form, span0);
			append_hydration_dev(span0, t4);
			append_hydration_dev(form, t5);
			append_hydration_dev(form, div2);
			append_hydration_dev(div2, t6);
			append_hydration_dev(form, t7);
			append_hydration_dev(form, span1);
			append_hydration_dev(span1, t8);
			append_hydration_dev(form, t9);
			append_hydration_dev(form, div3);
			append_hydration_dev(div3, t10);

			if (!mounted) {
				dispose = listen_dev(form, "submit", prevent_default(/*run*/ ctx[4]), false, true, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*title*/ 8 && title_value !== (title_value = /*title*/ ctx[3])) {
				document_1.title = title_value;
			}

			if (dirty & /*buttons*/ 32) {
				each_value = /*buttons*/ ctx[5];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*normalizedHours*/ 4) set_data_dev(t2, /*normalizedHours*/ ctx[2]);
			if (dirty & /*normalizedMinutes*/ 2) set_data_dev(t6, /*normalizedMinutes*/ ctx[1]);
			if (dirty & /*normalizedSeconds*/ 1) set_data_dev(t10, /*normalizedSeconds*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(section);
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let normalizedHours;
	let normalizedMinutes;
	let normalizedSeconds;
	let title;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Stopwatch', slots, []);
	let { updateTime = null } = $$props;
	let total = 0;
	let minutes = 0;
	let seconds = 0;
	let hours = 0;
	let running = false;
	let time;
	let updated = false;
	const audio = new Audio("Herbert-03.wav");

	function run() {
		if (running) {
			return;
		}

		running = true;
		updated = false;
		timer();
	}

	function timer() {
		time = setInterval(
			() => {
				total++;

				if (seconds == 59) {
					$$invalidate(8, seconds = 0);

					if (minutes == 9) {
						audio.play();
						$$invalidate(7, minutes++, minutes);
					} else if (minutes == 59) {
						$$invalidate(7, minutes = 0);

						if (hours == 23) {
							$$invalidate(9, hours = 0);
						}

						$$invalidate(9, hours++, hours);
					} else {
						$$invalidate(7, minutes++, minutes);
					}
				} else {
					$$invalidate(8, seconds++, seconds);
				}
			},
			1000
		);
	}

	function pause() {
		clearInterval(time);
		time = null;

		if (updateTime && !updated) {
			updateTime(total);
			total = 0;
			updated = true;
		}

		running = false;
	}

	function reset() {
		pause();
		$$invalidate(9, hours = 0);
		$$invalidate(7, minutes = 0);
		$$invalidate(8, seconds = 0);
	}

	onDestroy(() => {
		clearInterval(time);

		if (updateTime && !updated) {
			updateTime(total);
		}

		// Setting the title via the variable does not work
		document.title = "Raguprato";
	});

	const buttons = [
		{ title: "Play", click: run, icon: "play" },
		{
			title: "Pause",
			click: pause,
			icon: "pause"
		},
		{
			title: "Reset",
			click: reset,
			icon: "stop"
		}
	];

	const writable_props = ['updateTime'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Stopwatch> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('updateTime' in $$props) $$invalidate(6, updateTime = $$props.updateTime);
	};

	$$self.$capture_state = () => ({
		onDestroy,
		updateTime,
		total,
		minutes,
		seconds,
		hours,
		running,
		time,
		updated,
		audio,
		run,
		timer,
		pause,
		reset,
		buttons,
		normalizedSeconds,
		normalizedMinutes,
		normalizedHours,
		title
	});

	$$self.$inject_state = $$props => {
		if ('updateTime' in $$props) $$invalidate(6, updateTime = $$props.updateTime);
		if ('total' in $$props) total = $$props.total;
		if ('minutes' in $$props) $$invalidate(7, minutes = $$props.minutes);
		if ('seconds' in $$props) $$invalidate(8, seconds = $$props.seconds);
		if ('hours' in $$props) $$invalidate(9, hours = $$props.hours);
		if ('running' in $$props) running = $$props.running;
		if ('time' in $$props) time = $$props.time;
		if ('updated' in $$props) updated = $$props.updated;
		if ('normalizedSeconds' in $$props) $$invalidate(0, normalizedSeconds = $$props.normalizedSeconds);
		if ('normalizedMinutes' in $$props) $$invalidate(1, normalizedMinutes = $$props.normalizedMinutes);
		if ('normalizedHours' in $$props) $$invalidate(2, normalizedHours = $$props.normalizedHours);
		if ('title' in $$props) $$invalidate(3, title = $$props.title);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*hours*/ 512) {
			$$invalidate(2, normalizedHours = hours > 9 ? hours : `0${hours}`);
		}

		if ($$self.$$.dirty & /*minutes*/ 128) {
			$$invalidate(1, normalizedMinutes = minutes > 9 ? minutes : `0${minutes}`);
		}

		if ($$self.$$.dirty & /*seconds*/ 256) {
			$$invalidate(0, normalizedSeconds = seconds > 9 ? seconds : `0${seconds}`);
		}

		if ($$self.$$.dirty & /*normalizedHours, normalizedMinutes, normalizedSeconds*/ 7) {
			$$invalidate(3, title = `${normalizedHours}:${normalizedMinutes}:${normalizedSeconds}`);
		}
	};

	return [
		normalizedSeconds,
		normalizedMinutes,
		normalizedHours,
		title,
		run,
		buttons,
		updateTime,
		minutes,
		seconds,
		hours
	];
}

class Stopwatch extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { updateTime: 6 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Stopwatch",
			options,
			id: create_fragment$7.name
		});
	}

	get updateTime() {
		throw new Error("<Stopwatch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set updateTime(value) {
		throw new Error("<Stopwatch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/pages/Lesson/LessonHeader.svelte generated by Svelte v3.47.0 */

const { console: console_1$2 } = globals;
const file$6 = "src/pages/Lesson/LessonHeader.svelte";

// (141:4) {:else}
function create_else_block_5(ctx) {
	let button;
	let t_value = /*lesson*/ ctx[0].title + "";
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, t_value);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", "naked-button svelte-1wjd2ri");
			add_location(button, file$6, 141, 6, 3225);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, button, anchor);
			append_hydration_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler*/ ctx[14], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*lesson*/ 1 && t_value !== (t_value = /*lesson*/ ctx[0].title + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_5.name,
		type: "else",
		source: "(141:4) {:else}",
		ctx
	});

	return block;
}

// (137:4) {#if edit == 1}
function create_if_block_5$1(ctx) {
	let form;
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			form = element("form");
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			form = claim_element(nodes, "FORM", { name: true });
			var form_nodes = children(form);
			input = claim_element(form_nodes, "INPUT", {});
			form_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(input, file$6, 138, 8, 3164);
			attr_dev(form, "name", "title");
			add_location(form, file$6, 137, 6, 3102);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, form, anchor);
			append_hydration_dev(form, input);
			set_input_value(input, /*title*/ ctx[3]);

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_input_handler*/ ctx[13]),
					listen_dev(form, "submit", prevent_default(/*update*/ ctx[10]), false, true, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 8 && input.value !== /*title*/ ctx[3]) {
				set_input_value(input, /*title*/ ctx[3]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5$1.name,
		type: "if",
		source: "(137:4) {#if edit == 1}",
		ctx
	});

	return block;
}

// (149:4) {:else}
function create_else_block_4(ctx) {
	let button;
	let t_value = /*lesson*/ ctx[0].artist + "";
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, t_value);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", "naked-button svelte-1wjd2ri");
			add_location(button, file$6, 149, 6, 3486);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, button, anchor);
			append_hydration_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[16], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*lesson*/ 1 && t_value !== (t_value = /*lesson*/ ctx[0].artist + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_4.name,
		type: "else",
		source: "(149:4) {:else}",
		ctx
	});

	return block;
}

// (145:4) {#if edit == 2}
function create_if_block_4$1(ctx) {
	let form;
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			form = element("form");
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			form = claim_element(nodes, "FORM", { name: true });
			var form_nodes = children(form);
			input = claim_element(form_nodes, "INPUT", {});
			form_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(input, file$6, 146, 8, 3424);
			attr_dev(form, "name", "artist");
			add_location(form, file$6, 145, 6, 3361);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, form, anchor);
			append_hydration_dev(form, input);
			set_input_value(input, /*artist*/ ctx[4]);

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_input_handler_1*/ ctx[15]),
					listen_dev(form, "submit", prevent_default(/*update*/ ctx[10]), false, true, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*artist*/ 16 && input.value !== /*artist*/ ctx[4]) {
				set_input_value(input, /*artist*/ ctx[4]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$1.name,
		type: "if",
		source: "(145:4) {#if edit == 2}",
		ctx
	});

	return block;
}

// (160:4) {:else}
function create_else_block_3(ctx) {
	let button;
	let label;
	let t0;
	let t1_value = (/*lesson*/ ctx[0].capo || "No") + "";
	let t1;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			label = element("label");
			t0 = text("Capo:");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			label = claim_element(button_nodes, "LABEL", { for: true, class: true });
			var label_nodes = children(label);
			t0 = claim_text(label_nodes, "Capo:");
			label_nodes.forEach(detach_dev);
			t1 = claim_text(button_nodes, t1_value);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(label, "for", "capo");
			attr_dev(label, "class", "svelte-1wjd2ri");
			add_location(label, file$6, 161, 9, 3925);
			attr_dev(button, "class", "naked-button svelte-1wjd2ri");
			add_location(button, file$6, 160, 6, 3859);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, button, anchor);
			append_hydration_dev(button, label);
			append_hydration_dev(label, t0);
			append_hydration_dev(button, t1);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler_2*/ ctx[18], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*lesson*/ 1 && t1_value !== (t1_value = (/*lesson*/ ctx[0].capo || "No") + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_3.name,
		type: "else",
		source: "(160:4) {:else}",
		ctx
	});

	return block;
}

// (157:4) {#if edit == 3}
function create_if_block_3$1(ctx) {
	let label;
	let t0;
	let t1;
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			label = element("label");
			t0 = text("Capo:");
			t1 = space();
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			label = claim_element(nodes, "LABEL", { for: true, class: true });
			var label_nodes = children(label);
			t0 = claim_text(label_nodes, "Capo:");
			label_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);

			input = claim_element(nodes, "INPUT", {
				id: true,
				type: true,
				placeholder: true,
				min: true,
				max: true,
				class: true
			});

			this.h();
		},
		h: function hydrate() {
			attr_dev(label, "for", "capo");
			attr_dev(label, "class", "svelte-1wjd2ri");
			add_location(label, file$6, 157, 6, 3718);
			attr_dev(input, "id", "capo");
			attr_dev(input, "type", "number");
			attr_dev(input, "placeholder", "X");
			attr_dev(input, "min", "0");
			attr_dev(input, "max", "12");
			attr_dev(input, "class", "svelte-1wjd2ri");
			add_location(input, file$6, 158, 6, 3756);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, label, anchor);
			append_hydration_dev(label, t0);
			insert_hydration_dev(target, t1, anchor);
			insert_hydration_dev(target, input, anchor);
			set_input_value(input, /*capo*/ ctx[1]);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_2*/ ctx[17]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*capo*/ 2 && to_number(input.value) !== /*capo*/ ctx[1]) {
				set_input_value(input, /*capo*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(157:4) {#if edit == 3}",
		ctx
	});

	return block;
}

// (170:4) {:else}
function create_else_block_2(ctx) {
	let button;
	let label;
	let t0;
	let t1_value = (/*lesson*/ ctx[0].tuning || "Standard") + "";
	let t1;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			label = element("label");
			t0 = text("Tuning:");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			label = claim_element(button_nodes, "LABEL", { for: true, class: true });
			var label_nodes = children(label);
			t0 = claim_text(label_nodes, "Tuning:");
			label_nodes.forEach(detach_dev);
			t1 = claim_text(button_nodes, t1_value);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(label, "for", "tuning");
			attr_dev(label, "class", "svelte-1wjd2ri");
			add_location(label, file$6, 171, 8, 4321);
			attr_dev(button, "class", "naked-button svelte-1wjd2ri");
			add_location(button, file$6, 170, 6, 4255);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, button, anchor);
			append_hydration_dev(button, label);
			append_hydration_dev(label, t0);
			append_hydration_dev(button, t1);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler_3*/ ctx[20], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*lesson*/ 1 && t1_value !== (t1_value = (/*lesson*/ ctx[0].tuning || "Standard") + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2.name,
		type: "else",
		source: "(170:4) {:else}",
		ctx
	});

	return block;
}

// (167:4) {#if edit == 4}
function create_if_block_2$1(ctx) {
	let label;
	let t0;
	let t1;
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			label = element("label");
			t0 = text("Tuning:");
			t1 = space();
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			label = claim_element(nodes, "LABEL", { for: true, class: true });
			var label_nodes = children(label);
			t0 = claim_text(label_nodes, "Tuning:");
			label_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			input = claim_element(nodes, "INPUT", { id: true, class: true, placeholder: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(label, "for", "tuning");
			attr_dev(label, "class", "svelte-1wjd2ri");
			add_location(label, file$6, 167, 6, 4111);
			attr_dev(input, "id", "tuning");
			attr_dev(input, "class", "text-input svelte-1wjd2ri");
			attr_dev(input, "placeholder", "Standard");
			add_location(input, file$6, 168, 6, 4153);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, label, anchor);
			append_hydration_dev(label, t0);
			insert_hydration_dev(target, t1, anchor);
			insert_hydration_dev(target, input, anchor);
			set_input_value(input, /*tuning*/ ctx[2]);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_3*/ ctx[19]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*tuning*/ 4 && input.value !== /*tuning*/ ctx[2]) {
				set_input_value(input, /*tuning*/ ctx[2]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(167:4) {#if edit == 4}",
		ctx
	});

	return block;
}

// (180:4) {:else}
function create_else_block_1$1(ctx) {
	let button;
	let label;
	let t0;
	let t1_value = /*translateKey*/ ctx[11](/*lesson*/ ctx[0].audioFeatures?.key) + "";
	let t1;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			label = element("label");
			t0 = text("Key:");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			label = claim_element(button_nodes, "LABEL", { for: true, class: true });
			var label_nodes = children(label);
			t0 = claim_text(label_nodes, "Key:");
			label_nodes.forEach(detach_dev);
			t1 = claim_text(button_nodes, t1_value);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(label, "for", "tuning");
			attr_dev(label, "class", "svelte-1wjd2ri");
			add_location(label, file$6, 181, 8, 4709);
			attr_dev(button, "class", "naked-button svelte-1wjd2ri");
			add_location(button, file$6, 180, 6, 4643);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, button, anchor);
			append_hydration_dev(button, label);
			append_hydration_dev(label, t0);
			append_hydration_dev(button, t1);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler_4*/ ctx[22], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*lesson*/ 1 && t1_value !== (t1_value = /*translateKey*/ ctx[11](/*lesson*/ ctx[0].audioFeatures?.key) + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$1.name,
		type: "else",
		source: "(180:4) {:else}",
		ctx
	});

	return block;
}

// (177:4) {#if edit == 5}
function create_if_block_1$2(ctx) {
	let label;
	let t0;
	let t1;
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			label = element("label");
			t0 = text("Key:");
			t1 = space();
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			label = claim_element(nodes, "LABEL", { for: true, class: true });
			var label_nodes = children(label);
			t0 = claim_text(label_nodes, "Key:");
			label_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			input = claim_element(nodes, "INPUT", { id: true, class: true, placeholder: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(label, "for", "key");
			attr_dev(label, "class", "svelte-1wjd2ri");
			add_location(label, file$6, 177, 6, 4516);
			attr_dev(input, "id", "key");
			attr_dev(input, "class", "text-input svelte-1wjd2ri");
			attr_dev(input, "placeholder", "Key");
			add_location(input, file$6, 178, 6, 4552);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, label, anchor);
			append_hydration_dev(label, t0);
			insert_hydration_dev(target, t1, anchor);
			insert_hydration_dev(target, input, anchor);
			set_input_value(input, /*key*/ ctx[5]);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_4*/ ctx[21]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*key*/ 32 && input.value !== /*key*/ ctx[5]) {
				set_input_value(input, /*key*/ ctx[5]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(177:4) {#if edit == 5}",
		ctx
	});

	return block;
}

// (195:4) {:else}
function create_else_block$2(ctx) {
	let button;
	let label;
	let t0;
	let t1_value = (/*lesson*/ ctx[0].audioFeatures?.tempo?.toFixed(0) || "Not set") + "";
	let t1;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			label = element("label");
			t0 = text("Bpm:");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			label = claim_element(button_nodes, "LABEL", { for: true, class: true });
			var label_nodes = children(label);
			t0 = claim_text(label_nodes, "Bpm:");
			label_nodes.forEach(detach_dev);
			t1 = claim_text(button_nodes, t1_value);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(label, "for", "tuning");
			attr_dev(label, "class", "svelte-1wjd2ri");
			add_location(label, file$6, 196, 8, 5168);
			attr_dev(button, "class", "naked-button svelte-1wjd2ri");
			add_location(button, file$6, 195, 6, 5102);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, button, anchor);
			append_hydration_dev(button, label);
			append_hydration_dev(label, t0);
			append_hydration_dev(button, t1);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler_5*/ ctx[24], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*lesson*/ 1 && t1_value !== (t1_value = (/*lesson*/ ctx[0].audioFeatures?.tempo?.toFixed(0) || "Not set") + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(195:4) {:else}",
		ctx
	});

	return block;
}

// (187:4) {#if edit == 6}
function create_if_block$4(ctx) {
	let label;
	let t0;
	let t1;
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			label = element("label");
			t0 = text("Bpm:");
			t1 = space();
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			label = claim_element(nodes, "LABEL", { for: true, class: true });
			var label_nodes = children(label);
			t0 = claim_text(label_nodes, "Bpm:");
			label_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);

			input = claim_element(nodes, "INPUT", {
				id: true,
				type: true,
				class: true,
				placeholder: true
			});

			this.h();
		},
		h: function hydrate() {
			attr_dev(label, "for", "bpm");
			attr_dev(label, "class", "svelte-1wjd2ri");
			add_location(label, file$6, 187, 6, 4913);
			attr_dev(input, "id", "bpm");
			attr_dev(input, "type", "number");
			attr_dev(input, "class", "text-input svelte-1wjd2ri");
			attr_dev(input, "placeholder", "Enter tempo");
			add_location(input, file$6, 188, 6, 4949);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, label, anchor);
			append_hydration_dev(label, t0);
			insert_hydration_dev(target, t1, anchor);
			insert_hydration_dev(target, input, anchor);
			set_input_value(input, /*bpm*/ ctx[6]);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_5*/ ctx[23]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*bpm*/ 64 && to_number(input.value) !== /*bpm*/ ctx[6]) {
				set_input_value(input, /*bpm*/ ctx[6]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(187:4) {#if edit == 6}",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let header;
	let h1;
	let t0;
	let span;
	let t1;
	let t2;
	let t3;
	let stopwatch;
	let t4;
	let form0;
	let t5;
	let form1;
	let t6;
	let form2;
	let t7;
	let form3;
	let t8;
	let button;
	let i;
	let current;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*edit*/ ctx[7] == 1) return create_if_block_5$1;
		return create_else_block_5;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);

	function select_block_type_1(ctx, dirty) {
		if (/*edit*/ ctx[7] == 2) return create_if_block_4$1;
		return create_else_block_4;
	}

	let current_block_type_1 = select_block_type_1(ctx);
	let if_block1 = current_block_type_1(ctx);

	stopwatch = new Stopwatch({
			props: { updateTime: /*updateTime*/ ctx[9] },
			$$inline: true
		});

	function select_block_type_2(ctx, dirty) {
		if (/*edit*/ ctx[7] == 3) return create_if_block_3$1;
		return create_else_block_3;
	}

	let current_block_type_2 = select_block_type_2(ctx);
	let if_block2 = current_block_type_2(ctx);

	function select_block_type_3(ctx, dirty) {
		if (/*edit*/ ctx[7] == 4) return create_if_block_2$1;
		return create_else_block_2;
	}

	let current_block_type_3 = select_block_type_3(ctx);
	let if_block3 = current_block_type_3(ctx);

	function select_block_type_4(ctx, dirty) {
		if (/*edit*/ ctx[7] == 5) return create_if_block_1$2;
		return create_else_block_1$1;
	}

	let current_block_type_4 = select_block_type_4(ctx);
	let if_block4 = current_block_type_4(ctx);

	function select_block_type_5(ctx, dirty) {
		if (/*edit*/ ctx[7] == 6) return create_if_block$4;
		return create_else_block$2;
	}

	let current_block_type_5 = select_block_type_5(ctx);
	let if_block5 = current_block_type_5(ctx);

	const block = {
		c: function create() {
			header = element("header");
			h1 = element("h1");
			if_block0.c();
			t0 = space();
			span = element("span");
			t1 = text("-");
			t2 = space();
			if_block1.c();
			t3 = space();
			create_component(stopwatch.$$.fragment);
			t4 = space();
			form0 = element("form");
			if_block2.c();
			t5 = space();
			form1 = element("form");
			if_block3.c();
			t6 = space();
			form2 = element("form");
			if_block4.c();
			t7 = space();
			form3 = element("form");
			if_block5.c();
			t8 = space();
			button = element("button");
			i = element("i");
			this.h();
		},
		l: function claim(nodes) {
			header = claim_element(nodes, "HEADER", { class: true });
			var header_nodes = children(header);
			h1 = claim_element(header_nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			if_block0.l(h1_nodes);
			t0 = claim_space(h1_nodes);
			span = claim_element(h1_nodes, "SPAN", {});
			var span_nodes = children(span);
			t1 = claim_text(span_nodes, "-");
			span_nodes.forEach(detach_dev);
			t2 = claim_space(h1_nodes);
			if_block1.l(h1_nodes);
			h1_nodes.forEach(detach_dev);
			t3 = claim_space(header_nodes);
			claim_component(stopwatch.$$.fragment, header_nodes);
			t4 = claim_space(header_nodes);
			form0 = claim_element(header_nodes, "FORM", { name: true, class: true });
			var form0_nodes = children(form0);
			if_block2.l(form0_nodes);
			form0_nodes.forEach(detach_dev);
			t5 = claim_space(header_nodes);
			form1 = claim_element(header_nodes, "FORM", { name: true, class: true });
			var form1_nodes = children(form1);
			if_block3.l(form1_nodes);
			form1_nodes.forEach(detach_dev);
			t6 = claim_space(header_nodes);
			form2 = claim_element(header_nodes, "FORM", { name: true, class: true });
			var form2_nodes = children(form2);
			if_block4.l(form2_nodes);
			form2_nodes.forEach(detach_dev);
			t7 = claim_space(header_nodes);
			form3 = claim_element(header_nodes, "FORM", { name: true, class: true });
			var form3_nodes = children(form3);
			if_block5.l(form3_nodes);
			form3_nodes.forEach(detach_dev);
			t8 = claim_space(header_nodes);
			button = claim_element(header_nodes, "BUTTON", { class: true, title: true });
			var button_nodes = children(button);
			i = claim_element(button_nodes, "I", { class: true });
			children(i).forEach(detach_dev);
			button_nodes.forEach(detach_dev);
			header_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(span, file$6, 143, 4, 3320);
			attr_dev(h1, "class", "svelte-1wjd2ri");
			add_location(h1, file$6, 135, 2, 3071);
			attr_dev(form0, "name", "capo");
			attr_dev(form0, "class", "header-form svelte-1wjd2ri");
			add_location(form0, file$6, 155, 2, 3619);
			attr_dev(form1, "name", "tuning");
			attr_dev(form1, "class", "header-form svelte-1wjd2ri");
			add_location(form1, file$6, 165, 2, 4010);
			attr_dev(form2, "name", "key");
			attr_dev(form2, "class", "header-form svelte-1wjd2ri");
			add_location(form2, file$6, 175, 2, 4418);
			attr_dev(form3, "name", "bpm");
			attr_dev(form3, "class", "header-form svelte-1wjd2ri");
			add_location(form3, file$6, 185, 2, 4815);
			attr_dev(i, "class", "fab fa-spotify");
			add_location(i, file$6, 202, 4, 5386);
			attr_dev(button, "class", "sync-button svelte-1wjd2ri");
			attr_dev(button, "title", "Sync Spotify");
			button.disabled = /*loading*/ ctx[8];
			add_location(button, file$6, 201, 2, 5297);
			attr_dev(header, "class", "svelte-1wjd2ri");
			add_location(header, file$6, 134, 0, 3060);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, header, anchor);
			append_hydration_dev(header, h1);
			if_block0.m(h1, null);
			append_hydration_dev(h1, t0);
			append_hydration_dev(h1, span);
			append_hydration_dev(span, t1);
			append_hydration_dev(h1, t2);
			if_block1.m(h1, null);
			append_hydration_dev(header, t3);
			mount_component(stopwatch, header, null);
			append_hydration_dev(header, t4);
			append_hydration_dev(header, form0);
			if_block2.m(form0, null);
			append_hydration_dev(header, t5);
			append_hydration_dev(header, form1);
			if_block3.m(form1, null);
			append_hydration_dev(header, t6);
			append_hydration_dev(header, form2);
			if_block4.m(form2, null);
			append_hydration_dev(header, t7);
			append_hydration_dev(header, form3);
			if_block5.m(form3, null);
			append_hydration_dev(header, t8);
			append_hydration_dev(header, button);
			append_hydration_dev(button, i);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(form0, "submit", prevent_default(/*update*/ ctx[10]), false, true, false),
					listen_dev(form1, "submit", prevent_default(/*update*/ ctx[10]), false, true, false),
					listen_dev(form2, "submit", prevent_default(/*update*/ ctx[10]), false, true, false),
					listen_dev(form3, "submit", prevent_default(/*update*/ ctx[10]), false, true, false),
					listen_dev(button, "click", /*sync*/ ctx[12], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(h1, t0);
				}
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(h1, null);
				}
			}

			if (current_block_type_2 === (current_block_type_2 = select_block_type_2(ctx)) && if_block2) {
				if_block2.p(ctx, dirty);
			} else {
				if_block2.d(1);
				if_block2 = current_block_type_2(ctx);

				if (if_block2) {
					if_block2.c();
					if_block2.m(form0, null);
				}
			}

			if (current_block_type_3 === (current_block_type_3 = select_block_type_3(ctx)) && if_block3) {
				if_block3.p(ctx, dirty);
			} else {
				if_block3.d(1);
				if_block3 = current_block_type_3(ctx);

				if (if_block3) {
					if_block3.c();
					if_block3.m(form1, null);
				}
			}

			if (current_block_type_4 === (current_block_type_4 = select_block_type_4(ctx)) && if_block4) {
				if_block4.p(ctx, dirty);
			} else {
				if_block4.d(1);
				if_block4 = current_block_type_4(ctx);

				if (if_block4) {
					if_block4.c();
					if_block4.m(form2, null);
				}
			}

			if (current_block_type_5 === (current_block_type_5 = select_block_type_5(ctx)) && if_block5) {
				if_block5.p(ctx, dirty);
			} else {
				if_block5.d(1);
				if_block5 = current_block_type_5(ctx);

				if (if_block5) {
					if_block5.c();
					if_block5.m(form3, null);
				}
			}

			if (!current || dirty & /*loading*/ 256) {
				prop_dev(button, "disabled", /*loading*/ ctx[8]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(stopwatch.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(stopwatch.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(header);
			if_block0.d();
			if_block1.d();
			destroy_component(stopwatch);
			if_block2.d();
			if_block3.d();
			if_block4.d();
			if_block5.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let $spotifyToken;
	validate_store(spotifyToken, 'spotifyToken');
	component_subscribe($$self, spotifyToken, $$value => $$invalidate(25, $spotifyToken = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('LessonHeader', slots, []);
	let { lesson } = $$props;
	let capo;
	let tuning;
	let title;
	let artist;
	let key;
	let bpm;
	let edit;
	let loading;

	const keys = [
		"C",
		"C#/Db",
		"D",
		"D#/Eb",
		"E",
		"F",
		"F#/Gb",
		"G",
		"G#/Ab",
		"A",
		"A#/Bb",
		"B",
		"C"
	];

	async function updateTime(seconds) {
		if (!lesson.totalTime) {
			$$invalidate(0, lesson.totalTime = 0, lesson);
		}

		$$invalidate(0, lesson.totalTime += seconds, lesson);
		await transaction("put", lesson, "readwrite");
	}

	async function update({ target: { name } }) {
		if (name == "key") {
			if (!lesson.audioFeatures) {
				$$invalidate(0, lesson.audioFeatures = {}, lesson);
			}

			const validKey = keys.findIndex(keyValue => keyValue == key.toUpperCase());
			$$invalidate(0, lesson.audioFeatures.key = validKey !== -1 ? validKey : null, lesson);
		} else if (name == "bpm") {
			if (!lesson.audioFeatures) {
				$$invalidate(0, lesson.audioFeatures = {}, lesson);
			}

			$$invalidate(0, lesson.audioFeatures.tempo = bpm, lesson);
		} else {
			$$invalidate(
				0,
				lesson[name] = name == "title"
				? title
				: name == "artist"
					? artist
					: name == "capo" ? capo : tuning,
				lesson
			);
		}

		await transaction("put", lesson, "readwrite");
		$$invalidate(7, edit = null);
	}

	function translateKey(key) {
		if (key === undefined || key === null) {
			return "Not set";
		}

		return keys[key];
	}

	async function sync() {
		try {
			$$invalidate(8, loading = true);

			if (!$spotifyToken) {
				const credentials = await authenticateSpotify();
				await spotifyToken.set(credentials?.data?.access_token);
			}

			const res = await axios("https://api.spotify.com/v1/search", {
				headers: {
					Authorization: `Authorization: Bearer ${$spotifyToken}`
				},
				params: {
					q: encodeURI(title),
					type: "track",
					limit: 1
				}
			});

			const [spotifyResponse] = res?.data?.tracks?.items;

			const { data } = await axios("https://api.spotify.com/v1/audio-features", {
				headers: {
					"Content-Type": "application/json",
					Authorization: `Authorization: Bearer ${$spotifyToken}`
				},
				params: { ids: spotifyResponse.id }
			});

			if (data?.audio_features[0]) {
				$$invalidate(5, key = data?.audio_features[0]?.key);
				$$invalidate(6, bpm = data?.audio_features[0]?.tempo);

				if (!lesson.audioFeatures) {
					$$invalidate(0, lesson.audioFeatures = {}, lesson);
				}

				$$invalidate(0, lesson.audioFeatures.key = key, lesson);
				$$invalidate(0, lesson.audioFeatures.tempo = bpm, lesson);
				await transaction("put", lesson, "readwrite");
			}
		} catch(error) {
			console.error(error);
		} finally {
			$$invalidate(8, loading = false);
		}
	}

	onMount(() => {
		$$invalidate(1, capo = lesson.capo);
		$$invalidate(2, tuning = lesson.tuning);
		$$invalidate(3, title = lesson.title);
		$$invalidate(4, artist = lesson.artist);
		$$invalidate(5, key = lesson.audioFeatures?.key);
		$$invalidate(6, bpm = lesson.audioFeatures?.tempo);
	});

	const writable_props = ['lesson'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<LessonHeader> was created with unknown prop '${key}'`);
	});

	function input_input_handler() {
		title = this.value;
		$$invalidate(3, title);
	}

	const click_handler = () => $$invalidate(7, edit = 1);

	function input_input_handler_1() {
		artist = this.value;
		$$invalidate(4, artist);
	}

	const click_handler_1 = () => $$invalidate(7, edit = 2);

	function input_input_handler_2() {
		capo = to_number(this.value);
		$$invalidate(1, capo);
	}

	const click_handler_2 = () => $$invalidate(7, edit = 3);

	function input_input_handler_3() {
		tuning = this.value;
		$$invalidate(2, tuning);
	}

	const click_handler_3 = () => $$invalidate(7, edit = 4);

	function input_input_handler_4() {
		key = this.value;
		$$invalidate(5, key);
	}

	const click_handler_4 = () => $$invalidate(7, edit = 5);

	function input_input_handler_5() {
		bpm = to_number(this.value);
		$$invalidate(6, bpm);
	}

	const click_handler_5 = () => $$invalidate(7, edit = 6);

	$$self.$$set = $$props => {
		if ('lesson' in $$props) $$invalidate(0, lesson = $$props.lesson);
	};

	$$self.$capture_state = () => ({
		onMount,
		Stopwatch,
		authenticateSpotify,
		transaction,
		spotifyToken,
		axios,
		lesson,
		capo,
		tuning,
		title,
		artist,
		key,
		bpm,
		edit,
		loading,
		keys,
		updateTime,
		update,
		translateKey,
		sync,
		$spotifyToken
	});

	$$self.$inject_state = $$props => {
		if ('lesson' in $$props) $$invalidate(0, lesson = $$props.lesson);
		if ('capo' in $$props) $$invalidate(1, capo = $$props.capo);
		if ('tuning' in $$props) $$invalidate(2, tuning = $$props.tuning);
		if ('title' in $$props) $$invalidate(3, title = $$props.title);
		if ('artist' in $$props) $$invalidate(4, artist = $$props.artist);
		if ('key' in $$props) $$invalidate(5, key = $$props.key);
		if ('bpm' in $$props) $$invalidate(6, bpm = $$props.bpm);
		if ('edit' in $$props) $$invalidate(7, edit = $$props.edit);
		if ('loading' in $$props) $$invalidate(8, loading = $$props.loading);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		lesson,
		capo,
		tuning,
		title,
		artist,
		key,
		bpm,
		edit,
		loading,
		updateTime,
		update,
		translateKey,
		sync,
		input_input_handler,
		click_handler,
		input_input_handler_1,
		click_handler_1,
		input_input_handler_2,
		click_handler_2,
		input_input_handler_3,
		click_handler_3,
		input_input_handler_4,
		click_handler_4,
		input_input_handler_5,
		click_handler_5
	];
}

class LessonHeader extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { lesson: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LessonHeader",
			options,
			id: create_fragment$6.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*lesson*/ ctx[0] === undefined && !('lesson' in props)) {
			console_1$2.warn("<LessonHeader> was created without expected prop 'lesson'");
		}
	}

	get lesson() {
		throw new Error("<LessonHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set lesson(value) {
		throw new Error("<LessonHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/pages/Lesson/index.svelte generated by Svelte v3.47.0 */

const { Object: Object_1, console: console_1$1 } = globals;
const file$5 = "src/pages/Lesson/index.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[35] = list[i];
	child_ctx[37] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[37] = list[i];
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[40] = list[i];
	child_ctx[37] = i;
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[42] = list[i];
	return child_ctx;
}

function get_each_context_4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[45] = list[i];
	return child_ctx;
}

// (346:2) {:else}
function create_else_block_1(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text("Sorry, could not load lesson");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			t = claim_text(div_nodes, "Sorry, could not load lesson");
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$5, 346, 4, 9072);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(346:2) {:else}",
		ctx
	});

	return block;
}

// (213:2) {#if lesson}
function create_if_block$3(ctx) {
	let lessonheader;
	let t0;
	let t1;
	let div0;
	let form0;
	let input0;
	let t2;
	let form1;
	let input1;
	let t3;
	let t4;
	let t5;
	let h20;
	let t6;
	let t7;
	let select;
	let option;
	let t8;
	let t9;
	let t10;
	let h21;
	let t11;
	let t12;
	let div1;
	let t13;
	let t14;
	let div2;
	let t15;
	let t16;
	let div3;
	let img0;
	let img0_src_value;
	let t17;
	let img1;
	let img1_src_value;
	let t18;
	let label;
	let t19;
	let t20;
	let textarea;
	let t21;
	let button;
	let button_class_value;
	let current;
	let mounted;
	let dispose;

	lessonheader = new LessonHeader({
			props: { lesson: /*lesson*/ ctx[2] },
			$$inline: true
		});

	let if_block0 = /*addVideos*/ ctx[1] && create_if_block_6(ctx);
	let if_block1 = /*lesson*/ ctx[2].videos?.length && create_if_block_5(ctx);
	let if_block2 = /*lesson*/ ctx[2].tab && create_if_block_4(ctx);
	let each_value_3 = /*chordNames*/ ctx[7];
	validate_each_argument(each_value_3);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks_1[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	let if_block3 = /*lesson*/ ctx[2].chords?.length && create_if_block_3(ctx);
	let each_value_1 = [...Array(6)];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	let if_block4 = /*lesson*/ ctx[2]?.strumming && create_if_block_2(ctx);

	function select_block_type_1(ctx, dirty) {
		if (/*lesson*/ ctx[2].finished) return create_if_block_1$1;
		return create_else_block$1;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block5 = current_block_type(ctx);

	const block = {
		c: function create() {
			create_component(lessonheader.$$.fragment);
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			div0 = element("div");
			form0 = element("form");
			input0 = element("input");
			t2 = space();
			form1 = element("form");
			input1 = element("input");
			t3 = space();
			if (if_block1) if_block1.c();
			t4 = space();
			if (if_block2) if_block2.c();
			t5 = space();
			h20 = element("h2");
			t6 = text("Chords");
			t7 = space();
			select = element("select");
			option = element("option");
			t8 = text("Add Chords");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t9 = space();
			if (if_block3) if_block3.c();
			t10 = space();
			h21 = element("h2");
			t11 = text("Strumming Pattern");
			t12 = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t13 = space();
			if (if_block4) if_block4.c();
			t14 = space();
			div2 = element("div");
			t15 = text("Drag and Drop the Arrows to create a Strumming Pattern");
			t16 = space();
			div3 = element("div");
			img0 = element("img");
			t17 = space();
			img1 = element("img");
			t18 = space();
			label = element("label");
			t19 = text("Notes about the Song");
			t20 = space();
			textarea = element("textarea");
			t21 = space();
			button = element("button");
			if_block5.c();
			this.h();
		},
		l: function claim(nodes) {
			claim_component(lessonheader.$$.fragment, nodes);
			t0 = claim_space(nodes);
			if (if_block0) if_block0.l(nodes);
			t1 = claim_space(nodes);
			div0 = claim_element(nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			form0 = claim_element(div0_nodes, "FORM", { class: true });
			var form0_nodes = children(form0);
			input0 = claim_element(form0_nodes, "INPUT", { placeholder: true });
			form0_nodes.forEach(detach_dev);
			t2 = claim_space(div0_nodes);
			form1 = claim_element(div0_nodes, "FORM", { class: true });
			var form1_nodes = children(form1);
			input1 = claim_element(form1_nodes, "INPUT", { placeholder: true });
			form1_nodes.forEach(detach_dev);
			t3 = claim_space(div0_nodes);
			if (if_block1) if_block1.l(div0_nodes);
			t4 = claim_space(div0_nodes);
			if (if_block2) if_block2.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t5 = claim_space(nodes);
			h20 = claim_element(nodes, "H2", { class: true });
			var h20_nodes = children(h20);
			t6 = claim_text(h20_nodes, "Chords");
			h20_nodes.forEach(detach_dev);
			t7 = claim_space(nodes);
			select = claim_element(nodes, "SELECT", { class: true });
			var select_nodes = children(select);
			option = claim_element(select_nodes, "OPTION", {});
			var option_nodes = children(option);
			t8 = claim_text(option_nodes, "Add Chords");
			option_nodes.forEach(detach_dev);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].l(select_nodes);
			}

			select_nodes.forEach(detach_dev);
			t9 = claim_space(nodes);
			if (if_block3) if_block3.l(nodes);
			t10 = claim_space(nodes);
			h21 = claim_element(nodes, "H2", { class: true });
			var h21_nodes = children(h21);
			t11 = claim_text(h21_nodes, "Strumming Pattern");
			h21_nodes.forEach(detach_dev);
			t12 = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div1_nodes);
			}

			t13 = claim_space(div1_nodes);
			if (if_block4) if_block4.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			t14 = claim_space(nodes);
			div2 = claim_element(nodes, "DIV", {});
			var div2_nodes = children(div2);
			t15 = claim_text(div2_nodes, "Drag and Drop the Arrows to create a Strumming Pattern");
			div2_nodes.forEach(detach_dev);
			t16 = claim_space(nodes);
			div3 = claim_element(nodes, "DIV", {});
			var div3_nodes = children(div3);
			img0 = claim_element(div3_nodes, "IMG", { alt: true, class: true, src: true });
			t17 = claim_space(div3_nodes);
			img1 = claim_element(div3_nodes, "IMG", { class: true, alt: true, src: true });
			div3_nodes.forEach(detach_dev);
			t18 = claim_space(nodes);
			label = claim_element(nodes, "LABEL", { for: true });
			var label_nodes = children(label);
			t19 = claim_text(label_nodes, "Notes about the Song");
			label_nodes.forEach(detach_dev);
			t20 = claim_space(nodes);
			textarea = claim_element(nodes, "TEXTAREA", { id: true, rows: true, placeholder: true });
			children(textarea).forEach(detach_dev);
			t21 = claim_space(nodes);
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			if_block5.l(button_nodes);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input0, "placeholder", "Search for another Video");
			add_location(input0, file$5, 227, 8, 5572);
			attr_dev(form0, "class", "svelte-42339x");
			add_location(form0, file$5, 226, 6, 5514);
			attr_dev(input1, "placeholder", "Update Guitar Tab");
			add_location(input1, file$5, 234, 8, 5776);
			attr_dev(form1, "class", "svelte-42339x");
			add_location(form1, file$5, 233, 6, 5724);
			attr_dev(div0, "class", "media-wrapper svelte-42339x");
			add_location(div0, file$5, 225, 4, 5480);
			attr_dev(h20, "class", "svelte-42339x");
			add_location(h20, file$5, 267, 4, 6739);
			option.__value = "";
			option.value = option.__value;
			add_location(option, file$5, 270, 6, 6823);
			attr_dev(select, "class", "svelte-42339x");
			if (/*selectedChord*/ ctx[4] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[25].call(select));
			add_location(select, file$5, 269, 4, 6760);
			attr_dev(h21, "class", "svelte-42339x");
			add_location(h21, file$5, 298, 4, 7664);
			attr_dev(div1, "class", "strumming svelte-42339x");
			add_location(div1, file$5, 299, 4, 7695);
			add_location(div2, file$5, 320, 4, 8281);
			attr_dev(img0, "alt", "Arrow down");
			attr_dev(img0, "class", "arrow-down");
			if (!src_url_equal(img0.src, img0_src_value = ARROW_SRC)) attr_dev(img0, "src", img0_src_value);
			add_location(img0, file$5, 322, 6, 8363);
			attr_dev(img1, "class", "arrow-up svelte-42339x");
			attr_dev(img1, "alt", "Arrow down");
			if (!src_url_equal(img1.src, img1_src_value = ARROW_SRC)) attr_dev(img1, "src", img1_src_value);
			add_location(img1, file$5, 327, 6, 8525);
			add_location(div3, file$5, 321, 4, 8351);
			attr_dev(label, "for", "notes");
			add_location(label, file$5, 334, 4, 8693);
			attr_dev(textarea, "id", "notes");
			attr_dev(textarea, "rows", 5);
			attr_dev(textarea, "placeholder", "Your notes for the song");
			add_location(textarea, file$5, 335, 4, 8745);
			attr_dev(button, "class", button_class_value = "" + (null_to_empty(/*lesson*/ ctx[2].finished ? "re-open" : "") + " svelte-42339x"));
			add_location(button, file$5, 342, 4, 8912);
		},
		m: function mount(target, anchor) {
			mount_component(lessonheader, target, anchor);
			insert_hydration_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration_dev(target, t1, anchor);
			insert_hydration_dev(target, div0, anchor);
			append_hydration_dev(div0, form0);
			append_hydration_dev(form0, input0);
			set_input_value(input0, /*videoSearch*/ ctx[0]);
			append_hydration_dev(div0, t2);
			append_hydration_dev(div0, form1);
			append_hydration_dev(form1, input1);
			set_input_value(input1, /*tab*/ ctx[6]);
			append_hydration_dev(div0, t3);
			if (if_block1) if_block1.m(div0, null);
			append_hydration_dev(div0, t4);
			if (if_block2) if_block2.m(div0, null);
			insert_hydration_dev(target, t5, anchor);
			insert_hydration_dev(target, h20, anchor);
			append_hydration_dev(h20, t6);
			insert_hydration_dev(target, t7, anchor);
			insert_hydration_dev(target, select, anchor);
			append_hydration_dev(select, option);
			append_hydration_dev(option, t8);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(select, null);
			}

			select_option(select, /*selectedChord*/ ctx[4]);
			insert_hydration_dev(target, t9, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_hydration_dev(target, t10, anchor);
			insert_hydration_dev(target, h21, anchor);
			append_hydration_dev(h21, t11);
			insert_hydration_dev(target, t12, anchor);
			insert_hydration_dev(target, div1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			append_hydration_dev(div1, t13);
			if (if_block4) if_block4.m(div1, null);
			insert_hydration_dev(target, t14, anchor);
			insert_hydration_dev(target, div2, anchor);
			append_hydration_dev(div2, t15);
			insert_hydration_dev(target, t16, anchor);
			insert_hydration_dev(target, div3, anchor);
			append_hydration_dev(div3, img0);
			append_hydration_dev(div3, t17);
			append_hydration_dev(div3, img1);
			insert_hydration_dev(target, t18, anchor);
			insert_hydration_dev(target, label, anchor);
			append_hydration_dev(label, t19);
			insert_hydration_dev(target, t20, anchor);
			insert_hydration_dev(target, textarea, anchor);
			set_input_value(textarea, /*notes*/ ctx[5]);
			insert_hydration_dev(target, t21, anchor);
			insert_hydration_dev(target, button, anchor);
			if_block5.m(button, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input0, "input", /*debouncedSearch*/ ctx[17], false, false, false),
					listen_dev(input0, "input", /*input0_input_handler*/ ctx[21]),
					listen_dev(form0, "submit", prevent_default(/*debouncedSearch*/ ctx[17]), false, true, false),
					listen_dev(input1, "input", /*input1_input_handler*/ ctx[22]),
					listen_dev(form1, "submit", prevent_default(/*updateTab*/ ctx[14]), false, true, false),
					listen_dev(select, "change", /*select_change_handler*/ ctx[25]),
					listen_dev(select, "change", /*addChord*/ ctx[8], false, false, false),
					listen_dev(div1, "dragover", prevent_default(/*dragover_handler_1*/ ctx[19]), false, true, false),
					listen_dev(div1, "drop", prevent_default(/*handleDrop*/ ctx[11]), false, true, false),
					listen_dev(img0, "dragstart", dragstart_handler_1, false, false, false),
					listen_dev(img1, "dragstart", dragstart_handler_2, false, false, false),
					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[28]),
					listen_dev(textarea, "change", /*change_handler*/ ctx[29], false, false, false),
					listen_dev(button, "click", /*finish*/ ctx[13], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const lessonheader_changes = {};
			if (dirty[0] & /*lesson*/ 4) lessonheader_changes.lesson = /*lesson*/ ctx[2];
			lessonheader.$set(lessonheader_changes);

			if (/*addVideos*/ ctx[1]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*addVideos*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_6(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (dirty[0] & /*videoSearch*/ 1 && input0.value !== /*videoSearch*/ ctx[0]) {
				set_input_value(input0, /*videoSearch*/ ctx[0]);
			}

			if (dirty[0] & /*tab*/ 64 && input1.value !== /*tab*/ ctx[6]) {
				set_input_value(input1, /*tab*/ ctx[6]);
			}

			if (/*lesson*/ ctx[2].videos?.length) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_5(ctx);
					if_block1.c();
					if_block1.m(div0, t4);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*lesson*/ ctx[2].tab) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_4(ctx);
					if_block2.c();
					if_block2.m(div0, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty[0] & /*chordNames*/ 128) {
				each_value_3 = /*chordNames*/ ctx[7];
				validate_each_argument(each_value_3);
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_3(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(select, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_3.length;
			}

			if (dirty[0] & /*selectedChord, chordNames*/ 144) {
				select_option(select, /*selectedChord*/ ctx[4]);
			}

			if (/*lesson*/ ctx[2].chords?.length) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_3(ctx);
					if_block3.c();
					if_block3.m(t10.parentNode, t10);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (/*lesson*/ ctx[2]?.strumming) {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block_2(ctx);
					if_block4.c();
					if_block4.m(div1, null);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (dirty[0] & /*notes*/ 32) {
				set_input_value(textarea, /*notes*/ ctx[5]);
			}

			if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
				if_block5.d(1);
				if_block5 = current_block_type(ctx);

				if (if_block5) {
					if_block5.c();
					if_block5.m(button, null);
				}
			}

			if (!current || dirty[0] & /*lesson*/ 4 && button_class_value !== (button_class_value = "" + (null_to_empty(/*lesson*/ ctx[2].finished ? "re-open" : "") + " svelte-42339x"))) {
				attr_dev(button, "class", button_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(lessonheader.$$.fragment, local);
			transition_in(if_block0);
			current = true;
		},
		o: function outro(local) {
			transition_out(lessonheader.$$.fragment, local);
			transition_out(if_block0);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(lessonheader, detaching);
			if (detaching) detach_dev(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div0);
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (detaching) detach_dev(t5);
			if (detaching) detach_dev(h20);
			if (detaching) detach_dev(t7);
			if (detaching) detach_dev(select);
			destroy_each(each_blocks_1, detaching);
			if (detaching) detach_dev(t9);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach_dev(t10);
			if (detaching) detach_dev(h21);
			if (detaching) detach_dev(t12);
			if (detaching) detach_dev(div1);
			destroy_each(each_blocks, detaching);
			if (if_block4) if_block4.d();
			if (detaching) detach_dev(t14);
			if (detaching) detach_dev(div2);
			if (detaching) detach_dev(t16);
			if (detaching) detach_dev(div3);
			if (detaching) detach_dev(t18);
			if (detaching) detach_dev(label);
			if (detaching) detach_dev(t20);
			if (detaching) detach_dev(textarea);
			if (detaching) detach_dev(t21);
			if (detaching) detach_dev(button);
			if_block5.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(213:2) {#if lesson}",
		ctx
	});

	return block;
}

// (216:4) {#if addVideos}
function create_if_block_6(ctx) {
	let ul;
	let current;
	let each_value_4 = /*addVideos*/ ctx[1];
	validate_each_argument(each_value_4);
	let each_blocks = [];

	for (let i = 0; i < each_value_4.length; i += 1) {
		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "video-container svelte-42339x");
			add_location(ul, file$5, 216, 6, 5231);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*addVideo, addVideos*/ 32770) {
				each_value_4 = /*addVideos*/ ctx[1];
				validate_each_argument(each_value_4);
				let i;

				for (i = 0; i < each_value_4.length; i += 1) {
					const child_ctx = get_each_context_4(ctx, each_value_4, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_4(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value_4.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_4.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(216:4) {#if addVideos}",
		ctx
	});

	return block;
}

// (218:8) {#each addVideos as video}
function create_each_block_4(ctx) {
	let li;
	let videosnippet;
	let t;
	let current;
	let mounted;
	let dispose;

	videosnippet = new VideoSnippet({
			props: { snippet: /*video*/ ctx[45].snippet },
			$$inline: true
		});

	function click_handler() {
		return /*click_handler*/ ctx[20](/*video*/ ctx[45]);
	}

	const block = {
		c: function create() {
			li = element("li");
			create_component(videosnippet.$$.fragment);
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { role: true, class: true });
			var li_nodes = children(li);
			claim_component(videosnippet.$$.fragment, li_nodes);
			t = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(li, "role", "button");
			attr_dev(li, "class", "svelte-42339x");
			add_location(li, file$5, 218, 10, 5305);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, li, anchor);
			mount_component(videosnippet, li, null);
			append_hydration_dev(li, t);
			current = true;

			if (!mounted) {
				dispose = listen_dev(li, "click", click_handler, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const videosnippet_changes = {};
			if (dirty[0] & /*addVideos*/ 2) videosnippet_changes.snippet = /*video*/ ctx[45].snippet;
			videosnippet.$set(videosnippet_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(videosnippet.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(videosnippet.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			destroy_component(videosnippet);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_4.name,
		type: "each",
		source: "(218:8) {#each addVideos as video}",
		ctx
	});

	return block;
}

// (238:6) {#if lesson.videos?.length}
function create_if_block_5(ctx) {
	let div;
	let button0;
	let i0;
	let t0;
	let iframe;
	let iframe_title_value;
	let iframe_src_value;
	let t1;
	let button1;
	let i1;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			button0 = element("button");
			i0 = element("i");
			t0 = space();
			iframe = element("iframe");
			t1 = space();
			button1 = element("button");
			i1 = element("i");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			button0 = claim_element(div_nodes, "BUTTON", { class: true });
			var button0_nodes = children(button0);
			i0 = claim_element(button0_nodes, "I", { class: true });
			children(i0).forEach(detach_dev);
			button0_nodes.forEach(detach_dev);
			t0 = claim_space(div_nodes);
			iframe = claim_element(div_nodes, "IFRAME", { title: true, class: true, src: true });
			children(iframe).forEach(detach_dev);
			t1 = claim_space(div_nodes);
			button1 = claim_element(div_nodes, "BUTTON", { class: true });
			var button1_nodes = children(button1);
			i1 = claim_element(button1_nodes, "I", { class: true });
			children(i1).forEach(detach_dev);
			button1_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(i0, "class", "fa fa-caret-left");
			add_location(i0, file$5, 240, 12, 6006);
			attr_dev(button0, "class", "naked-button svelte-42339x");
			add_location(button0, file$5, 239, 10, 5931);
			attr_dev(iframe, "title", iframe_title_value = `Lesson video of ${/*lesson*/ ctx[2].title}`);
			iframe.allowFullscreen = true;
			attr_dev(iframe, "class", "video svelte-42339x");
			if (!src_url_equal(iframe.src, iframe_src_value = `https://www.youtube.com/embed/${/*lesson*/ ctx[2].videos[/*showVideo*/ ctx[3]]}`)) attr_dev(iframe, "src", iframe_src_value);
			add_location(iframe, file$5, 243, 10, 6068);
			attr_dev(i1, "class", "fa fa-caret-right");
			add_location(i1, file$5, 250, 12, 6350);
			attr_dev(button1, "class", "naked-button svelte-42339x");
			add_location(button1, file$5, 249, 10, 6276);
			attr_dev(div, "class", "iframe-wrapper svelte-42339x");
			add_location(div, file$5, 238, 8, 5892);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, button0);
			append_hydration_dev(button0, i0);
			append_hydration_dev(div, t0);
			append_hydration_dev(div, iframe);
			append_hydration_dev(div, t1);
			append_hydration_dev(div, button1);
			append_hydration_dev(button1, i1);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*click_handler_1*/ ctx[23], false, false, false),
					listen_dev(button1, "click", /*click_handler_2*/ ctx[24], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*lesson*/ 4 && iframe_title_value !== (iframe_title_value = `Lesson video of ${/*lesson*/ ctx[2].title}`)) {
				attr_dev(iframe, "title", iframe_title_value);
			}

			if (dirty[0] & /*lesson, showVideo*/ 12 && !src_url_equal(iframe.src, iframe_src_value = `https://www.youtube.com/embed/${/*lesson*/ ctx[2].videos[/*showVideo*/ ctx[3]]}`)) {
				attr_dev(iframe, "src", iframe_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(238:6) {#if lesson.videos?.length}",
		ctx
	});

	return block;
}

// (256:6) {#if lesson.tab}
function create_if_block_4(ctx) {
	let iframe;
	let iframe_src_value;

	const block = {
		c: function create() {
			iframe = element("iframe");
			this.h();
		},
		l: function claim(nodes) {
			iframe = claim_element(nodes, "IFRAME", {
				allow: true,
				referrerpolicy: true,
				loading: true,
				height: true,
				width: true,
				title: true,
				src: true
			});

			children(iframe).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(iframe, "allow", "fullscreen");
			attr_dev(iframe, "referrerpolicy", "no-referrer");
			attr_dev(iframe, "loading", "lazy");
			attr_dev(iframe, "height", "100%");
			attr_dev(iframe, "width", "100%");
			attr_dev(iframe, "title", "Hopefully some lyrics");
			if (!src_url_equal(iframe.src, iframe_src_value = /*lesson*/ ctx[2].tab || "https://www.guitaretab.com")) attr_dev(iframe, "src", iframe_src_value);
			add_location(iframe, file$5, 256, 8, 6461);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, iframe, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*lesson*/ 4 && !src_url_equal(iframe.src, iframe_src_value = /*lesson*/ ctx[2].tab || "https://www.guitaretab.com")) {
				attr_dev(iframe, "src", iframe_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(iframe);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(256:6) {#if lesson.tab}",
		ctx
	});

	return block;
}

// (272:6) {#each chordNames as chordName}
function create_each_block_3(ctx) {
	let option;
	let t_value = /*chordName*/ ctx[42] + "";
	let t;

	const block = {
		c: function create() {
			option = element("option");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			option = claim_element(nodes, "OPTION", {});
			var option_nodes = children(option);
			t = claim_text(option_nodes, t_value);
			option_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			option.__value = /*chordName*/ ctx[42];
			option.value = option.__value;
			add_location(option, file$5, 272, 8, 6906);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, option, anchor);
			append_hydration_dev(option, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(option);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3.name,
		type: "each",
		source: "(272:6) {#each chordNames as chordName}",
		ctx
	});

	return block;
}

// (277:4) {#if lesson.chords?.length}
function create_if_block_3(ctx) {
	let div;
	let each_value_2 = /*lesson*/ ctx[2].chords;
	validate_each_argument(each_value_2);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "chord-wrapper svelte-42339x");
			add_location(div, file$5, 277, 6, 7020);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*deleteChord, lesson*/ 516) {
				each_value_2 = /*lesson*/ ctx[2].chords;
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(277:4) {#if lesson.chords?.length}",
		ctx
	});

	return block;
}

// (279:8) {#each lesson.chords as _c, i}
function create_each_block_2(ctx) {
	let div1;
	let button;
	let i_1;
	let t0;
	let div0;
	let t1;
	let mounted;
	let dispose;

	function click_handler_3() {
		return /*click_handler_3*/ ctx[26](/*i*/ ctx[37]);
	}

	const block = {
		c: function create() {
			div1 = element("div");
			button = element("button");
			i_1 = element("i");
			t0 = space();
			div0 = element("div");
			t1 = space();
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			button = claim_element(div1_nodes, "BUTTON", { "aria-label": true, class: true });
			var button_nodes = children(button);
			i_1 = claim_element(button_nodes, "I", { class: true });
			children(i_1).forEach(detach_dev);
			button_nodes.forEach(detach_dev);
			t0 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { id: true });
			children(div0).forEach(detach_dev);
			t1 = claim_space(div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(i_1, "class", "fa fa-times");
			add_location(i_1, file$5, 284, 14, 7280);
			attr_dev(button, "aria-label", "Delete Chord");
			attr_dev(button, "class", "naked-button svelte-42339x");
			add_location(button, file$5, 280, 12, 7136);
			attr_dev(div0, "id", `chord-${/*i*/ ctx[37]}`);
			add_location(div0, file$5, 286, 12, 7340);
			attr_dev(div1, "class", "chord-holder svelte-42339x");
			add_location(div1, file$5, 279, 10, 7097);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div1, anchor);
			append_hydration_dev(div1, button);
			append_hydration_dev(button, i_1);
			append_hydration_dev(div1, t0);
			append_hydration_dev(div1, div0);
			append_hydration_dev(div1, t1);

			if (!mounted) {
				dispose = listen_dev(button, "click", click_handler_3, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(279:8) {#each lesson.chords as _c, i}",
		ctx
	});

	return block;
}

// (301:6) {#each [...Array(6)] as i}
function create_each_block_1(ctx) {
	let hr;

	const block = {
		c: function create() {
			hr = element("hr");
			this.h();
		},
		l: function claim(nodes) {
			hr = claim_element(nodes, "HR", {});
			this.h();
		},
		h: function hydrate() {
			add_location(hr, file$5, 301, 8, 7823);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, hr, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(hr);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(301:6) {#each [...Array(6)] as i}",
		ctx
	});

	return block;
}

// (305:6) {#if lesson?.strumming}
function create_if_block_2(ctx) {
	let ul;
	let each_value = /*lesson*/ ctx[2].strumming;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "svelte-42339x");
			add_location(ul, file$5, 305, 8, 7883);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*lesson*/ 4) {
				each_value = /*lesson*/ ctx[2].strumming;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(305:6) {#if lesson?.strumming}",
		ctx
	});

	return block;
}

// (307:10) {#each lesson.strumming as strum, i}
function create_each_block$2(ctx) {
	let li;
	let img;
	let img_class_value;
	let img_src_value;
	let t;
	let mounted;
	let dispose;

	function dragstart_handler(...args) {
		return /*dragstart_handler*/ ctx[27](/*i*/ ctx[37], ...args);
	}

	const block = {
		c: function create() {
			li = element("li");
			img = element("img");
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", {});
			var li_nodes = children(li);

			img = claim_element(li_nodes, "IMG", {
				alt: true,
				width: true,
				height: true,
				class: true,
				src: true
			});

			t = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(img, "alt", "Arrow");
			attr_dev(img, "width", 60);
			attr_dev(img, "height", 80);
			attr_dev(img, "class", img_class_value = "" + (null_to_empty(`arrow-${/*strum*/ ctx[35]}`) + " svelte-42339x"));
			if (!src_url_equal(img.src, img_src_value = ARROW_SRC)) attr_dev(img, "src", img_src_value);
			add_location(img, file$5, 308, 14, 7966);
			add_location(li, file$5, 307, 12, 7947);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, li, anchor);
			append_hydration_dev(li, img);
			append_hydration_dev(li, t);

			if (!mounted) {
				dispose = listen_dev(img, "dragstart", dragstart_handler, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*lesson*/ 4 && img_class_value !== (img_class_value = "" + (null_to_empty(`arrow-${/*strum*/ ctx[35]}`) + " svelte-42339x"))) {
				attr_dev(img, "class", img_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(307:10) {#each lesson.strumming as strum, i}",
		ctx
	});

	return block;
}

// (344:38) {:else}
function create_else_block$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Finish Lesson");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Finish Lesson");
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(344:38) {:else}",
		ctx
	});

	return block;
}

// (344:6) {#if lesson.finished}
function create_if_block_1$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Open Lesson");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Open Lesson");
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(344:6) {#if lesson.finished}",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let section;
	let current_block_type_index;
	let if_block;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block$3, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*lesson*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			section = element("section");
			if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			if_block.l(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "class", "svelte-42339x");
			add_location(section, file$5, 211, 0, 5085);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, section, anchor);
			if_blocks[current_block_type_index].m(section, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(section, "dragover", prevent_default(/*dragover_handler*/ ctx[18]), false, true, false),
					listen_dev(section, "drop", prevent_default(/*removeStrum*/ ctx[12]), false, true, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(section, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			if_blocks[current_block_type_index].d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const dragstart_handler_1 = e => e.dataTransfer.setData("direction", "down");
const dragstart_handler_2 = e => e.dataTransfer.setData("direction", "up");

function instance$5($$self, $$props, $$invalidate) {
	let $location;
	validate_store(location, 'location');
	component_subscribe($$self, location, $$value => $$invalidate(30, $location = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Lesson', slots, []);
	const urlParts = $location.split("/");
	const id = decodeURIComponent(urlParts[urlParts.length - 1]);
	let videoSearch;
	let addVideos;
	let lesson;
	let showVideo = 0;
	let selectedChord = "";
	let notes = "";
	let tab = "";
	const chordNames = Object.keys(chords);

	async function addChord() {
		if (!selectedChord) {
			return;
		}

		try {
			if (lesson.chords) {
				$$invalidate(2, lesson.chords = [...lesson.chords, selectedChord], lesson);
			} else {
				$$invalidate(2, lesson.chords = [selectedChord], lesson);
			}

			$$invalidate(4, selectedChord = "");
			await transaction("put", lesson, "readwrite");
			renderChords();
		} catch(error) {
			console.error(error);
		}
	}

	async function deleteChord(chordPosition) {
		try {
			const newChords = [
				...lesson.chords.slice(0, chordPosition),
				...lesson.chords.slice(chordPosition + 1)
			];

			$$invalidate(2, lesson.chords = [...newChords], lesson);
			await transaction("put", lesson, "readwrite");
		} catch(error) {
			console.error(error);
		}
	}

	async function addNotes(notes) {
		try {
			$$invalidate(2, lesson.notes = notes, lesson);
			await transaction("put", lesson, "readwrite");
		} catch(error) {
			console.error(error);
		}
	}

	async function handleDrop(e) {
		e.preventDefault();
		const direction = e.dataTransfer.getData("direction");

		if (lesson.strumming) {
			$$invalidate(2, lesson.strumming = [...lesson.strumming, direction], lesson);
		} else {
			$$invalidate(2, lesson.strumming = [direction], lesson);
		}

		await transaction("put", lesson, "readwrite");
		e.stopPropagation();
	}

	async function removeStrum(e) {
		const position = e.dataTransfer.getData("position");

		if (position && lesson.strumming) {
			$$invalidate(
				2,
				lesson.strumming = [
					...lesson.strumming.slice(0, position),
					...lesson.strumming.slice(parseInt(position) + 1)
				],
				lesson
			);
		}

		await transaction("put", lesson, "readwrite");
	}

	async function finish() {
		if ("finished" in lesson) {
			$$invalidate(2, lesson.finished = !lesson.finished, lesson);
		} else {
			$$invalidate(2, lesson.finished = true, lesson);
		}

		await transaction("put", lesson, "readwrite");
		push("/");
	}

	async function searchYoutube() {
		if (videoSearch && videoSearch.length > 3) {
			try {
				const res = await apiCall("https://www.googleapis.com/youtube/v3/search", {
					q: videoSearch,
					type: "video",
					key: "AIzaSyAViHdvitELO2-jct4oVozhk8Wq3hCkjRk",
					part: "snippet",
					maxResults: 7,
					topicId: "/m/04rlf"
				});

				$$invalidate(1, addVideos = res.items);
			} catch(error) {
				console.log(error.message);
			}
		}
	}

	async function updateTab() {
		$$invalidate(2, lesson.tab = tab, lesson);
		await transaction("put", lesson, "readwrite");
	}

	async function addVideo(videoID) {
		$$invalidate(2, lesson.videos = [...lesson.videos, videoID], lesson);
		$$invalidate(1, addVideos = null);
		await transaction("put", lesson, "readwrite");
	}

	function changeVideo(count) {
		if (lesson.videos.length > 1) {
			if (showVideo + count < 0) {
				$$invalidate(3, showVideo = lesson.videos.length - 1);
			} else if (showVideo + count > lesson.videos.length - 1) {
				$$invalidate(3, showVideo = 0);
			} else {
				$$invalidate(3, showVideo += count);
			}
		}
	}

	// async function addTab() {
	//   lesson.coordinates = [
	//     ...lesson.coordinates,
	//     [...new Array(6).keys()].reduce((acc, cV) => {
	//       acc[cV] = {};
	//       return acc;
	//     }, {}),
	//   ];
	//         await transaction("put", lesson, "readwrite");
	// }
	// async function deleteTab(position) {
	//   lesson.coordinates = [
	//     ...lesson.coordinates.slice(0, position),
	//     ...lesson.coordinates.slice(position + 1),
	//   ];
	//         await transaction("put", lesson, "readwrite");
	// }
	function renderChords() {
		if (lesson.chords?.length) {
			lesson.chords.forEach((chordName, i) => {
				const chart = new SVGuitarChord(`#chord-${i}`);
				const { fingers, barre, position } = chords[chordName];

				chart.configure({
					tuning: ["E", "A", "D", "G", "B", "E"],
					frets: 4,
					position: position || 1
				}).chord({
					fingers,
					barres: barre ? [barre] : [],
					title: chordName
				}).draw();
			});
		}
	}

	onMount(() => {
		try {
			(async function init() {
				$$invalidate(2, lesson = await transaction("get", id));
				$$invalidate(5, notes = lesson.notes);
				setTimeout(renderChords, 500);
			})();
		} catch(error) {
			console.error(error);
		}
	});

	const debouncedSearch = debounce(searchYoutube);
	const writable_props = [];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<Lesson> was created with unknown prop '${key}'`);
	});

	function dragover_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dragover_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	const click_handler = video => addVideo(video.id.videoId);

	function input0_input_handler() {
		videoSearch = this.value;
		$$invalidate(0, videoSearch);
	}

	function input1_input_handler() {
		tab = this.value;
		$$invalidate(6, tab);
	}

	const click_handler_1 = () => changeVideo(-1);
	const click_handler_2 = () => changeVideo(1);

	function select_change_handler() {
		selectedChord = select_value(this);
		$$invalidate(4, selectedChord);
		$$invalidate(7, chordNames);
	}

	const click_handler_3 = i => deleteChord(i);
	const dragstart_handler = (i, e) => e.dataTransfer.setData("position", i);

	function textarea_input_handler() {
		notes = this.value;
		$$invalidate(5, notes);
	}

	const change_handler = e => addNotes(e.target.value);

	$$self.$capture_state = () => ({
		onMount,
		location,
		push,
		svguitar,
		apiCall,
		ARROW_SRC,
		debounce,
		transaction,
		chords,
		VideoSnippet,
		LessonHeader,
		urlParts,
		id,
		videoSearch,
		addVideos,
		lesson,
		showVideo,
		selectedChord,
		notes,
		tab,
		chordNames,
		addChord,
		deleteChord,
		addNotes,
		handleDrop,
		removeStrum,
		finish,
		searchYoutube,
		updateTab,
		addVideo,
		changeVideo,
		renderChords,
		debouncedSearch,
		$location
	});

	$$self.$inject_state = $$props => {
		if ('videoSearch' in $$props) $$invalidate(0, videoSearch = $$props.videoSearch);
		if ('addVideos' in $$props) $$invalidate(1, addVideos = $$props.addVideos);
		if ('lesson' in $$props) $$invalidate(2, lesson = $$props.lesson);
		if ('showVideo' in $$props) $$invalidate(3, showVideo = $$props.showVideo);
		if ('selectedChord' in $$props) $$invalidate(4, selectedChord = $$props.selectedChord);
		if ('notes' in $$props) $$invalidate(5, notes = $$props.notes);
		if ('tab' in $$props) $$invalidate(6, tab = $$props.tab);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		videoSearch,
		addVideos,
		lesson,
		showVideo,
		selectedChord,
		notes,
		tab,
		chordNames,
		addChord,
		deleteChord,
		addNotes,
		handleDrop,
		removeStrum,
		finish,
		updateTab,
		addVideo,
		changeVideo,
		debouncedSearch,
		dragover_handler,
		dragover_handler_1,
		click_handler,
		input0_input_handler,
		input1_input_handler,
		click_handler_1,
		click_handler_2,
		select_change_handler,
		click_handler_3,
		dragstart_handler,
		textarea_input_handler,
		change_handler
	];
}

class Lesson extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {}, null, [-1, -1]);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Lesson",
			options,
			id: create_fragment$5.name
		});
	}
}

var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': Lesson
});

/* src/pages/NewLesson/SpotifyResponse.svelte generated by Svelte v3.47.0 */
const file$4 = "src/pages/NewLesson/SpotifyResponse.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (21:0) {#each data as song}
function create_each_block$1(ctx) {
	let section;
	let h3;
	let span0;
	let t0_value = /*song*/ ctx[6]?.name + "";
	let t0;
	let t1;
	let span1;
	let t2_value = getArtists(/*song*/ ctx[6].artists) + "";
	let t2;
	let t3;
	let div1;
	let div0;
	let t4_value = transformSongLength(/*song*/ ctx[6]?.duration_ms) + "";
	let t4;
	let t5;
	let a;
	let i;
	let a_href_value;
	let t6;
	let img;
	let img_src_value;
	let img_height_value;
	let img_width_value;
	let img_alt_value;
	let t7;
	let audio;
	let source;
	let source_src_value;
	let t8;
	let mounted;
	let dispose;

	function keydown_handler() {
		return /*keydown_handler*/ ctx[3](/*song*/ ctx[6]);
	}

	function click_handler_1() {
		return /*click_handler_1*/ ctx[4](/*song*/ ctx[6]);
	}

	const block = {
		c: function create() {
			section = element("section");
			h3 = element("h3");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = text(" by\n      ");
			span1 = element("span");
			t2 = text(t2_value);
			t3 = space();
			div1 = element("div");
			div0 = element("div");
			t4 = text(t4_value);
			t5 = space();
			a = element("a");
			i = element("i");
			t6 = space();
			img = element("img");
			t7 = space();
			audio = element("audio");
			source = element("source");
			t8 = space();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { role: true, tabindex: true, class: true });
			var section_nodes = children(section);
			h3 = claim_element(section_nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			span0 = claim_element(h3_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, t0_value);
			span0_nodes.forEach(detach_dev);
			t1 = claim_text(h3_nodes, " by\n      ");
			span1 = claim_element(h3_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			t2 = claim_text(span1_nodes, t2_value);
			span1_nodes.forEach(detach_dev);
			h3_nodes.forEach(detach_dev);
			t3 = claim_space(section_nodes);
			div1 = claim_element(section_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t4 = claim_text(div0_nodes, t4_value);
			div0_nodes.forEach(detach_dev);
			t5 = claim_space(div1_nodes);
			a = claim_element(div1_nodes, "A", { target: true, href: true, class: true });
			var a_nodes = children(a);
			i = claim_element(a_nodes, "I", { class: true });
			children(i).forEach(detach_dev);
			a_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t6 = claim_space(section_nodes);

			img = claim_element(section_nodes, "IMG", {
				src: true,
				height: true,
				width: true,
				alt: true
			});

			t7 = claim_space(section_nodes);
			audio = claim_element(section_nodes, "AUDIO", {});
			var audio_nodes = children(audio);
			source = claim_element(audio_nodes, "SOURCE", { src: true, type: true });
			audio_nodes.forEach(detach_dev);
			t8 = claim_space(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span0, "class", "svelte-1kyf0m7");
			add_location(span0, file$4, 28, 6, 700);
			attr_dev(span1, "class", "svelte-1kyf0m7");
			add_location(span1, file$4, 29, 6, 735);
			attr_dev(h3, "class", "svelte-1kyf0m7");
			add_location(h3, file$4, 27, 4, 689);
			attr_dev(div0, "class", "length");
			add_location(div0, file$4, 33, 6, 815);
			attr_dev(i, "class", "fab fa-spotify");
			add_location(i, file$4, 37, 8, 993);
			attr_dev(a, "target", "_blank");
			attr_dev(a, "href", a_href_value = /*song*/ ctx[6]?.external_urls?.spotify);
			attr_dev(a, "class", "svelte-1kyf0m7");
			add_location(a, file$4, 36, 6, 904);
			attr_dev(div1, "class", "info svelte-1kyf0m7");
			add_location(div1, file$4, 32, 4, 790);
			if (!src_url_equal(img.src, img_src_value = /*song*/ ctx[6].album?.images[1]?.url)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "height", img_height_value = /*song*/ ctx[6].album?.images[1]?.height);
			attr_dev(img, "width", img_width_value = /*song*/ ctx[6].album?.images[1]?.height);
			attr_dev(img, "alt", img_alt_value = `Album cover of ${/*song*/ ctx[6].name}`);
			add_location(img, file$4, 41, 4, 1049);
			if (!src_url_equal(source.src, source_src_value = /*song*/ ctx[6].preview_url)) attr_dev(source, "src", source_src_value);
			attr_dev(source, "type", "audio/mpeg");
			add_location(source, file$4, 48, 6, 1266);
			audio.controls = "controls";
			add_location(audio, file$4, 47, 4, 1232);
			attr_dev(section, "role", "button");
			attr_dev(section, "tabindex", "0");
			attr_dev(section, "class", "svelte-1kyf0m7");
			toggle_class(section, "show", /*song*/ ctx[6]);
			add_location(section, file$4, 21, 2, 540);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, section, anchor);
			append_hydration_dev(section, h3);
			append_hydration_dev(h3, span0);
			append_hydration_dev(span0, t0);
			append_hydration_dev(h3, t1);
			append_hydration_dev(h3, span1);
			append_hydration_dev(span1, t2);
			append_hydration_dev(section, t3);
			append_hydration_dev(section, div1);
			append_hydration_dev(div1, div0);
			append_hydration_dev(div0, t4);
			append_hydration_dev(div1, t5);
			append_hydration_dev(div1, a);
			append_hydration_dev(a, i);
			append_hydration_dev(section, t6);
			append_hydration_dev(section, img);
			append_hydration_dev(section, t7);
			append_hydration_dev(section, audio);
			append_hydration_dev(audio, source);
			append_hydration_dev(section, t8);

			if (!mounted) {
				dispose = [
					listen_dev(a, "click", stop_propagation(/*click_handler*/ ctx[2]), false, false, true),
					listen_dev(section, "keydown", keydown_handler, false, false, false),
					listen_dev(section, "click", click_handler_1, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*data*/ 1 && t0_value !== (t0_value = /*song*/ ctx[6]?.name + "")) set_data_dev(t0, t0_value);
			if (dirty & /*data*/ 1 && t2_value !== (t2_value = getArtists(/*song*/ ctx[6].artists) + "")) set_data_dev(t2, t2_value);
			if (dirty & /*data*/ 1 && t4_value !== (t4_value = transformSongLength(/*song*/ ctx[6]?.duration_ms) + "")) set_data_dev(t4, t4_value);

			if (dirty & /*data*/ 1 && a_href_value !== (a_href_value = /*song*/ ctx[6]?.external_urls?.spotify)) {
				attr_dev(a, "href", a_href_value);
			}

			if (dirty & /*data*/ 1 && !src_url_equal(img.src, img_src_value = /*song*/ ctx[6].album?.images[1]?.url)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty & /*data*/ 1 && img_height_value !== (img_height_value = /*song*/ ctx[6].album?.images[1]?.height)) {
				attr_dev(img, "height", img_height_value);
			}

			if (dirty & /*data*/ 1 && img_width_value !== (img_width_value = /*song*/ ctx[6].album?.images[1]?.height)) {
				attr_dev(img, "width", img_width_value);
			}

			if (dirty & /*data*/ 1 && img_alt_value !== (img_alt_value = `Album cover of ${/*song*/ ctx[6].name}`)) {
				attr_dev(img, "alt", img_alt_value);
			}

			if (dirty & /*data*/ 1 && !src_url_equal(source.src, source_src_value = /*song*/ ctx[6].preview_url)) {
				attr_dev(source, "src", source_src_value);
			}

			if (dirty & /*data*/ 1) {
				toggle_class(section, "show", /*song*/ ctx[6]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(21:0) {#each data as song}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let each_1_anchor;
	let each_value = /*data*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_hydration_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*data, returnData, transformSongLength, getArtists*/ 3) {
				each_value = /*data*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function transformSongLength(ms) {
	const seconds = ms / 1000;
	const minutes = seconds / 60;
	const remainingSeconds = seconds % 60;
	return `${minutes.toFixed(0)}:${remainingSeconds.toFixed(0) < 10 ? "0" : ""}${remainingSeconds.toFixed(0)}`;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('SpotifyResponse', slots, []);
	let { data } = $$props;
	const dispatch = createEventDispatcher();
	const returnData = song => dispatch("song", song);
	const writable_props = ['data'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SpotifyResponse> was created with unknown prop '${key}'`);
	});

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	const keydown_handler = song => returnData(song);
	const click_handler_1 = song => returnData(song);

	$$self.$$set = $$props => {
		if ('data' in $$props) $$invalidate(0, data = $$props.data);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		getArtists,
		data,
		transformSongLength,
		dispatch,
		returnData
	});

	$$self.$inject_state = $$props => {
		if ('data' in $$props) $$invalidate(0, data = $$props.data);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [data, returnData, click_handler, keydown_handler, click_handler_1];
}

class SpotifyResponse extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { data: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SpotifyResponse",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*data*/ ctx[0] === undefined && !('data' in props)) {
			console.warn("<SpotifyResponse> was created without expected prop 'data'");
		}
	}

	get data() {
		throw new Error("<SpotifyResponse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<SpotifyResponse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Input.svelte generated by Svelte v3.47.0 */
const file$3 = "src/components/Input.svelte";

// (16:2) {#if error}
function create_if_block$2(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(/*error*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, /*error*/ ctx[2]);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "error svelte-1nsq3fe");
			add_location(div, file$3, 16, 4, 378);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*error*/ 4) set_data_dev(t, /*error*/ ctx[2]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(16:2) {#if error}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let div;
	let input;
	let t0;
	let label_1;
	let t1;
	let t2;
	let mounted;
	let dispose;
	let if_block = /*error*/ ctx[2] && create_if_block$2(ctx);

	const block = {
		c: function create() {
			div = element("div");
			input = element("input");
			t0 = space();
			label_1 = element("label");
			t1 = text(/*label*/ ctx[1]);
			t2 = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			input = claim_element(div_nodes, "INPUT", { id: true, class: true });
			t0 = claim_space(div_nodes);
			label_1 = claim_element(div_nodes, "LABEL", { for: true, class: true });
			var label_1_nodes = children(label_1);
			t1 = claim_text(label_1_nodes, /*label*/ ctx[1]);
			label_1_nodes.forEach(detach_dev);
			t2 = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "id", /*inputID*/ ctx[4]);
			attr_dev(input, "class", "svelte-1nsq3fe");
			add_location(input, file$3, 12, 2, 240);
			attr_dev(label_1, "for", /*inputID*/ ctx[4]);
			attr_dev(label_1, "class", "svelte-1nsq3fe");
			toggle_class(label_1, "flying-label", /*value*/ ctx[0]);
			add_location(label_1, file$3, 13, 2, 295);
			attr_dev(div, "class", "input-container svelte-1nsq3fe");
			add_location(div, file$3, 11, 0, 208);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, input);
			set_input_value(input, /*value*/ ctx[0]);
			append_hydration_dev(div, t0);
			append_hydration_dev(div, label_1);
			append_hydration_dev(label_1, t1);
			append_hydration_dev(div, t2);
			if (if_block) if_block.m(div, null);

			if (!mounted) {
				dispose = [
					listen_dev(
						input,
						"input",
						function () {
							if (is_function(/*onInput*/ ctx[3])) /*onInput*/ ctx[3].apply(this, arguments);
						},
						false,
						false,
						false
					),
					listen_dev(input, "input", /*input_input_handler*/ ctx[5])
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty & /*label*/ 2) set_data_dev(t1, /*label*/ ctx[1]);

			if (dirty & /*value*/ 1) {
				toggle_class(label_1, "flying-label", /*value*/ ctx[0]);
			}

			if (/*error*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Input', slots, []);
	let { value } = $$props;
	let { label } = $$props;
	let { error = null } = $$props;
	let { onInput = null } = $$props;
	let inputID = `${label}-${createID()}`;
	const writable_props = ['value', 'label', 'error', 'onInput'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Input> was created with unknown prop '${key}'`);
	});

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('label' in $$props) $$invalidate(1, label = $$props.label);
		if ('error' in $$props) $$invalidate(2, error = $$props.error);
		if ('onInput' in $$props) $$invalidate(3, onInput = $$props.onInput);
	};

	$$self.$capture_state = () => ({
		createID,
		value,
		label,
		error,
		onInput,
		inputID
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('label' in $$props) $$invalidate(1, label = $$props.label);
		if ('error' in $$props) $$invalidate(2, error = $$props.error);
		if ('onInput' in $$props) $$invalidate(3, onInput = $$props.onInput);
		if ('inputID' in $$props) $$invalidate(4, inputID = $$props.inputID);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [value, label, error, onInput, inputID, input_input_handler];
}

class Input extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { value: 0, label: 1, error: 2, onInput: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Input",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*value*/ ctx[0] === undefined && !('value' in props)) {
			console.warn("<Input> was created without expected prop 'value'");
		}

		if (/*label*/ ctx[1] === undefined && !('label' in props)) {
			console.warn("<Input> was created without expected prop 'label'");
		}
	}

	get value() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get error() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set error(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onInput() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onInput(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/pages/NewLesson/SpotifySearch.svelte generated by Svelte v3.47.0 */

const { Error: Error_1$1 } = globals;
const file$2 = "src/pages/NewLesson/SpotifySearch.svelte";

// (51:2) {#if loading}
function create_if_block_1(ctx) {
	let loading_1;
	let current;

	loading_1 = new Loading({
			props: { text: "Searching Spotify..." },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(loading_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(loading_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(loading_1, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(loading_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loading_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(loading_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(51:2) {#if loading}",
		ctx
	});

	return block;
}

// (57:2) {#if spotifyResponse}
function create_if_block$1(ctx) {
	let div;
	let spotifyresponse;
	let current;

	spotifyresponse = new SpotifyResponse({
			props: { data: /*spotifyResponse*/ ctx[3] },
			$$inline: true
		});

	spotifyresponse.$on("song", /*song_handler*/ ctx[6]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(spotifyresponse.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(spotifyresponse.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "search-results svelte-1pkvtmg");
			add_location(div, file$2, 57, 4, 1499);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			mount_component(spotifyresponse, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const spotifyresponse_changes = {};
			if (dirty & /*spotifyResponse*/ 8) spotifyresponse_changes.data = /*spotifyResponse*/ ctx[3];
			spotifyresponse.$set(spotifyresponse_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(spotifyresponse.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(spotifyresponse.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(spotifyresponse);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(57:2) {#if spotifyResponse}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let input;
	let updating_value;
	let t0;
	let div;
	let t1;
	let error_1;
	let t2;
	let current;

	function input_value_binding(value) {
		/*input_value_binding*/ ctx[5](value);
	}

	let input_props = {
		label: "Song",
		onInput: debounce(/*searchSpotify*/ ctx[4])
	};

	if (/*songName*/ ctx[0] !== void 0) {
		input_props.value = /*songName*/ ctx[0];
	}

	input = new Input({ props: input_props, $$inline: true });
	binding_callbacks.push(() => bind(input, 'value', input_value_binding));
	let if_block0 = /*loading*/ ctx[1] && create_if_block_1(ctx);

	error_1 = new Error$1({
			props: { error: /*error*/ ctx[2] },
			$$inline: true
		});

	let if_block1 = /*spotifyResponse*/ ctx[3] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			create_component(input.$$.fragment);
			t0 = space();
			div = element("div");
			if (if_block0) if_block0.c();
			t1 = space();
			create_component(error_1.$$.fragment);
			t2 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			claim_component(input.$$.fragment, nodes);
			t0 = claim_space(nodes);
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t1 = claim_space(div_nodes);
			claim_component(error_1.$$.fragment, div_nodes);
			t2 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$2, 49, 0, 1375);
		},
		m: function mount(target, anchor) {
			mount_component(input, target, anchor);
			insert_hydration_dev(target, t0, anchor);
			insert_hydration_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_hydration_dev(div, t1);
			mount_component(error_1, div, null);
			append_hydration_dev(div, t2);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const input_changes = {};

			if (!updating_value && dirty & /*songName*/ 1) {
				updating_value = true;
				input_changes.value = /*songName*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);

			if (/*loading*/ ctx[1]) {
				if (if_block0) {
					if (dirty & /*loading*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			const error_1_changes = {};
			if (dirty & /*error*/ 4) error_1_changes.error = /*error*/ ctx[2];
			error_1.$set(error_1_changes);

			if (/*spotifyResponse*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*spotifyResponse*/ 8) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(if_block0);
			transition_in(error_1.$$.fragment, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(input.$$.fragment, local);
			transition_out(if_block0);
			transition_out(error_1.$$.fragment, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(input, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			destroy_component(error_1);
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let $spotifyToken;
	validate_store(spotifyToken, 'spotifyToken');
	component_subscribe($$self, spotifyToken, $$value => $$invalidate(7, $spotifyToken = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('SpotifySearch', slots, []);
	let { songName = "" } = $$props;
	let loading = false;
	let error = null;
	let spotifyResponse = null;

	async function searchSpotify() {
		if ($spotifyToken && songName.length > 1) {
			$$invalidate(2, error = null);
			$$invalidate(1, loading = true);

			try {
				const { data } = await axios("https://api.spotify.com/v1/search", {
					headers: {
						Authorization: `Authorization: Bearer ${$spotifyToken}`
					},
					params: { q: songName, type: "track", limit: 5 }
				});

				$$invalidate(3, spotifyResponse = data?.tracks?.items);
			} catch(err) {
				$$invalidate(2, error = err);
			} finally {
				$$invalidate(1, loading = false);
			}
		}
	}

	onMount(() => {
		(async function init() {
			if (!$spotifyToken) {
				const credentials = await authenticateSpotify();
				spotifyToken.set(credentials?.data?.access_token);
			}
		})();
	});

	const writable_props = ['songName'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SpotifySearch> was created with unknown prop '${key}'`);
	});

	function input_value_binding(value) {
		songName = value;
		$$invalidate(0, songName);
	}

	function song_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('songName' in $$props) $$invalidate(0, songName = $$props.songName);
	};

	$$self.$capture_state = () => ({
		onMount,
		axios,
		SpotifyResponse,
		Input,
		Loading,
		Error: Error$1,
		spotifyToken,
		authenticateSpotify,
		debounce,
		songName,
		loading,
		error,
		spotifyResponse,
		searchSpotify,
		$spotifyToken
	});

	$$self.$inject_state = $$props => {
		if ('songName' in $$props) $$invalidate(0, songName = $$props.songName);
		if ('loading' in $$props) $$invalidate(1, loading = $$props.loading);
		if ('error' in $$props) $$invalidate(2, error = $$props.error);
		if ('spotifyResponse' in $$props) $$invalidate(3, spotifyResponse = $$props.spotifyResponse);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		songName,
		loading,
		error,
		spotifyResponse,
		searchSpotify,
		input_value_binding,
		song_handler
	];
}

class SpotifySearch extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { songName: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SpotifySearch",
			options,
			id: create_fragment$2.name
		});
	}

	get songName() {
		throw new Error_1$1("<SpotifySearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set songName(value) {
		throw new Error_1$1("<SpotifySearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/pages/NewLesson/YoutubeSearch.svelte generated by Svelte v3.47.0 */

const { Error: Error_1 } = globals;
const file$1 = "src/pages/NewLesson/YoutubeSearch.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (58:2) {#each searchResult as video}
function create_each_block(ctx) {
	let li;
	let videosnippet;
	let t;
	let li_title_value;
	let current;
	let mounted;
	let dispose;

	videosnippet = new VideoSnippet({
			props: { snippet: /*video*/ ctx[11].snippet },
			$$inline: true
		});

	function click_handler() {
		return /*click_handler*/ ctx[9](/*video*/ ctx[11]);
	}

	const block = {
		c: function create() {
			li = element("li");
			create_component(videosnippet.$$.fragment);
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { title: true, class: true, role: true });
			var li_nodes = children(li);
			claim_component(videosnippet.$$.fragment, li_nodes);
			t = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(li, "title", li_title_value = `Click to ${/*findID*/ ctx[3](/*video*/ ctx[11].id.videoId)
			? "un"
			: ""}select`);

			attr_dev(li, "class", "empty-button svelte-krholc");
			attr_dev(li, "role", "button");
			toggle_class(li, "selected", /*findID*/ ctx[3](/*video*/ ctx[11].id.videoId));
			add_location(li, file$1, 58, 4, 1591);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, li, anchor);
			mount_component(videosnippet, li, null);
			append_hydration_dev(li, t);
			current = true;

			if (!mounted) {
				dispose = listen_dev(li, "click", click_handler, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const videosnippet_changes = {};
			if (dirty & /*searchResult*/ 2) videosnippet_changes.snippet = /*video*/ ctx[11].snippet;
			videosnippet.$set(videosnippet_changes);

			if (!current || dirty & /*findID, searchResult*/ 10 && li_title_value !== (li_title_value = `Click to ${/*findID*/ ctx[3](/*video*/ ctx[11].id.videoId)
			? "un"
			: ""}select`)) {
				attr_dev(li, "title", li_title_value);
			}

			if (dirty & /*findID, searchResult*/ 10) {
				toggle_class(li, "selected", /*findID*/ ctx[3](/*video*/ ctx[11].id.videoId));
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(videosnippet.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(videosnippet.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			destroy_component(videosnippet);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(58:2) {#each searchResult as video}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let input;
	let updating_value;
	let t0;
	let error;
	let t1;
	let ul;
	let current;

	function input_value_binding(value) {
		/*input_value_binding*/ ctx[8](value);
	}

	let input_props = {
		label: "Search Youtube",
		onInput: /*debouncedSearch*/ ctx[5]
	};

	if (/*videoSearch*/ ctx[0] !== void 0) {
		input_props.value = /*videoSearch*/ ctx[0];
	}

	input = new Input({ props: input_props, $$inline: true });
	binding_callbacks.push(() => bind(input, 'value', input_value_binding));

	error = new Error$1({
			props: { error: /*videoError*/ ctx[2] },
			$$inline: true
		});

	let each_value = /*searchResult*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			create_component(input.$$.fragment);
			t0 = space();
			create_component(error.$$.fragment);
			t1 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			claim_component(input.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(error.$$.fragment, nodes);
			t1 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "search-result svelte-krholc");
			toggle_class(ul, "show", /*searchResult*/ ctx[1]);
			add_location(ul, file$1, 56, 0, 1502);
		},
		m: function mount(target, anchor) {
			mount_component(input, target, anchor);
			insert_hydration_dev(target, t0, anchor);
			mount_component(error, target, anchor);
			insert_hydration_dev(target, t1, anchor);
			insert_hydration_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			const input_changes = {};

			if (!updating_value && dirty & /*videoSearch*/ 1) {
				updating_value = true;
				input_changes.value = /*videoSearch*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
			const error_changes = {};
			if (dirty & /*videoError*/ 4) error_changes.error = /*videoError*/ ctx[2];
			error.$set(error_changes);

			if (dirty & /*findID, searchResult, handleClick*/ 26) {
				each_value = /*searchResult*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (dirty & /*searchResult*/ 2) {
				toggle_class(ul, "show", /*searchResult*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(error.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(input.$$.fragment, local);
			transition_out(error.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(input, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(error, detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let findID;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('YoutubeSearch', slots, []);
	let { videos } = $$props;
	let { videoSearch } = $$props;
	let { startSearch = false } = $$props;
	let searchResult = [];
	let videoError;

	async function searchYoutube() {
		if (videoSearch?.length > 2) {
			try {
				const res = await apiCall("https://www.googleapis.com/youtube/v3/search", {
					q: videoSearch,
					type: "video",
					key: "AIzaSyAViHdvitELO2-jct4oVozhk8Wq3hCkjRk",
					part: "snippet",
					maxResults: 7,
					topicId: "/m/04rlf"
				});

				$$invalidate(1, searchResult = res.items);
				$$invalidate(2, videoError = null);
				$$invalidate(7, startSearch = false);
			} catch(error) {
				$$invalidate(2, videoError = error);
			}
		}
	}

	function handleClick(video) {
		if (videos.length > 0) {
			const alreadyIn = findID(video.id.videoId);

			if (alreadyIn) {
				$$invalidate(6, videos = videos.filter(vid => vid != alreadyIn));
			} else {
				$$invalidate(6, videos = [...videos, video.id.videoId]);
			}
		} else {
			$$invalidate(6, videos = [video.id.videoId]);
		}
	}

	const debouncedSearch = debounce(searchYoutube);
	const writable_props = ['videos', 'videoSearch', 'startSearch'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<YoutubeSearch> was created with unknown prop '${key}'`);
	});

	function input_value_binding(value) {
		videoSearch = value;
		$$invalidate(0, videoSearch);
	}

	const click_handler = video => handleClick(video);

	$$self.$$set = $$props => {
		if ('videos' in $$props) $$invalidate(6, videos = $$props.videos);
		if ('videoSearch' in $$props) $$invalidate(0, videoSearch = $$props.videoSearch);
		if ('startSearch' in $$props) $$invalidate(7, startSearch = $$props.startSearch);
	};

	$$self.$capture_state = () => ({
		VideoSnippet,
		Input,
		Error: Error$1,
		debounce,
		apiCall,
		videos,
		videoSearch,
		startSearch,
		searchResult,
		videoError,
		searchYoutube,
		handleClick,
		debouncedSearch,
		findID
	});

	$$self.$inject_state = $$props => {
		if ('videos' in $$props) $$invalidate(6, videos = $$props.videos);
		if ('videoSearch' in $$props) $$invalidate(0, videoSearch = $$props.videoSearch);
		if ('startSearch' in $$props) $$invalidate(7, startSearch = $$props.startSearch);
		if ('searchResult' in $$props) $$invalidate(1, searchResult = $$props.searchResult);
		if ('videoError' in $$props) $$invalidate(2, videoError = $$props.videoError);
		if ('findID' in $$props) $$invalidate(3, findID = $$props.findID);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*videos*/ 64) {
			$$invalidate(3, findID = id => videos?.find(videoID => id == videoID));
		}

		if ($$self.$$.dirty & /*startSearch*/ 128) {
			startSearch ? searchYoutube() : null;
		}
	};

	return [
		videoSearch,
		searchResult,
		videoError,
		findID,
		handleClick,
		debouncedSearch,
		videos,
		startSearch,
		input_value_binding,
		click_handler
	];
}

class YoutubeSearch extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			videos: 6,
			videoSearch: 0,
			startSearch: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "YoutubeSearch",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*videos*/ ctx[6] === undefined && !('videos' in props)) {
			console.warn("<YoutubeSearch> was created without expected prop 'videos'");
		}

		if (/*videoSearch*/ ctx[0] === undefined && !('videoSearch' in props)) {
			console.warn("<YoutubeSearch> was created without expected prop 'videoSearch'");
		}
	}

	get videos() {
		throw new Error_1("<YoutubeSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set videos(value) {
		throw new Error_1("<YoutubeSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get videoSearch() {
		throw new Error_1("<YoutubeSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set videoSearch(value) {
		throw new Error_1("<YoutubeSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get startSearch() {
		throw new Error_1("<YoutubeSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set startSearch(value) {
		throw new Error_1("<YoutubeSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/pages/NewLesson/index.svelte generated by Svelte v3.47.0 */

const { console: console_1 } = globals;
const file = "src/pages/NewLesson/index.svelte";

// (137:6) {:else}
function create_else_block(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("Save Lesson");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, "Save Lesson");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(span, file, 137, 8, 3815);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(137:6) {:else}",
		ctx
	});

	return block;
}

// (135:6) {#if loading}
function create_if_block(ctx) {
	let loading_1;
	let current;
	loading_1 = new Loading({ props: { text: "" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(loading_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(loading_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(loading_1, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(loading_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loading_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(loading_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(135:6) {#if loading}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let section;
	let h1;
	let t0;
	let t1;
	let form;
	let spotifysearch;
	let updating_songName;
	let t2;
	let input0;
	let updating_value;
	let t3;
	let youtubesearch;
	let updating_videoSearch;
	let updating_startSearch;
	let updating_videos;
	let t4;
	let input1;
	let updating_value_1;
	let t5;
	let button;
	let current_block_type_index;
	let if_block;
	let button_disabled_value;
	let current;
	let mounted;
	let dispose;

	function spotifysearch_songName_binding(value) {
		/*spotifysearch_songName_binding*/ ctx[6](value);
	}

	let spotifysearch_props = {};

	if (/*songData*/ ctx[3].title !== void 0) {
		spotifysearch_props.songName = /*songData*/ ctx[3].title;
	}

	spotifysearch = new SpotifySearch({
			props: spotifysearch_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(spotifysearch, 'songName', spotifysearch_songName_binding));
	spotifysearch.$on("song", /*song_handler*/ ctx[7]);

	function input0_value_binding(value) {
		/*input0_value_binding*/ ctx[8](value);
	}

	let input0_props = { label: "Artist" };

	if (/*songData*/ ctx[3].artist !== void 0) {
		input0_props.value = /*songData*/ ctx[3].artist;
	}

	input0 = new Input({ props: input0_props, $$inline: true });
	binding_callbacks.push(() => bind(input0, 'value', input0_value_binding));

	function youtubesearch_videoSearch_binding(value) {
		/*youtubesearch_videoSearch_binding*/ ctx[9](value);
	}

	function youtubesearch_startSearch_binding(value) {
		/*youtubesearch_startSearch_binding*/ ctx[10](value);
	}

	function youtubesearch_videos_binding(value) {
		/*youtubesearch_videos_binding*/ ctx[11](value);
	}

	let youtubesearch_props = {};

	if (/*videoSearch*/ ctx[0] !== void 0) {
		youtubesearch_props.videoSearch = /*videoSearch*/ ctx[0];
	}

	if (/*startSearch*/ ctx[1] !== void 0) {
		youtubesearch_props.startSearch = /*startSearch*/ ctx[1];
	}

	if (/*songData*/ ctx[3].videos !== void 0) {
		youtubesearch_props.videos = /*songData*/ ctx[3].videos;
	}

	youtubesearch = new YoutubeSearch({
			props: youtubesearch_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(youtubesearch, 'videoSearch', youtubesearch_videoSearch_binding));
	binding_callbacks.push(() => bind(youtubesearch, 'startSearch', youtubesearch_startSearch_binding));
	binding_callbacks.push(() => bind(youtubesearch, 'videos', youtubesearch_videos_binding));

	function input1_value_binding(value) {
		/*input1_value_binding*/ ctx[12](value);
	}

	let input1_props = {
		label: "Enter Url of chord site like https://azchords.com/"
	};

	if (/*songData*/ ctx[3].tab !== void 0) {
		input1_props.value = /*songData*/ ctx[3].tab;
	}

	input1 = new Input({ props: input1_props, $$inline: true });
	binding_callbacks.push(() => bind(input1, 'value', input1_value_binding));
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*loading*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			section = element("section");
			h1 = element("h1");
			t0 = text("Create a new Lesson");
			t1 = space();
			form = element("form");
			create_component(spotifysearch.$$.fragment);
			t2 = space();
			create_component(input0.$$.fragment);
			t3 = space();
			create_component(youtubesearch.$$.fragment);
			t4 = space();
			create_component(input1.$$.fragment);
			t5 = space();
			button = element("button");
			if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { id: true, class: true });
			var section_nodes = children(section);
			h1 = claim_element(section_nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Create a new Lesson");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(section_nodes);
			form = claim_element(section_nodes, "FORM", { class: true });
			var form_nodes = children(form);
			claim_component(spotifysearch.$$.fragment, form_nodes);
			t2 = claim_space(form_nodes);
			claim_component(input0.$$.fragment, form_nodes);
			t3 = claim_space(form_nodes);
			claim_component(youtubesearch.$$.fragment, form_nodes);
			t4 = claim_space(form_nodes);
			claim_component(input1.$$.fragment, form_nodes);
			t5 = claim_space(form_nodes);
			button = claim_element(form_nodes, "BUTTON", { type: true });
			var button_nodes = children(button);
			if_block.l(button_nodes);
			button_nodes.forEach(detach_dev);
			form_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file, 96, 2, 2501);
			button.disabled = button_disabled_value = !/*songData*/ ctx[3].title || /*loading*/ ctx[2];
			attr_dev(button, "type", "submit");
			add_location(button, file, 133, 4, 3684);
			attr_dev(form, "class", "svelte-lqnpzt");
			add_location(form, file, 98, 2, 2533);
			attr_dev(section, "id", "container");
			attr_dev(section, "class", "svelte-lqnpzt");
			add_location(section, file, 95, 0, 2474);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, section, anchor);
			append_hydration_dev(section, h1);
			append_hydration_dev(h1, t0);
			append_hydration_dev(section, t1);
			append_hydration_dev(section, form);
			mount_component(spotifysearch, form, null);
			append_hydration_dev(form, t2);
			mount_component(input0, form, null);
			append_hydration_dev(form, t3);
			mount_component(youtubesearch, form, null);
			append_hydration_dev(form, t4);
			mount_component(input1, form, null);
			append_hydration_dev(form, t5);
			append_hydration_dev(form, button);
			if_blocks[current_block_type_index].m(button, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(form, "submit", prevent_default(/*handleSubmit*/ ctx[4]), false, true, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const spotifysearch_changes = {};

			if (!updating_songName && dirty & /*songData*/ 8) {
				updating_songName = true;
				spotifysearch_changes.songName = /*songData*/ ctx[3].title;
				add_flush_callback(() => updating_songName = false);
			}

			spotifysearch.$set(spotifysearch_changes);
			const input0_changes = {};

			if (!updating_value && dirty & /*songData*/ 8) {
				updating_value = true;
				input0_changes.value = /*songData*/ ctx[3].artist;
				add_flush_callback(() => updating_value = false);
			}

			input0.$set(input0_changes);
			const youtubesearch_changes = {};

			if (!updating_videoSearch && dirty & /*videoSearch*/ 1) {
				updating_videoSearch = true;
				youtubesearch_changes.videoSearch = /*videoSearch*/ ctx[0];
				add_flush_callback(() => updating_videoSearch = false);
			}

			if (!updating_startSearch && dirty & /*startSearch*/ 2) {
				updating_startSearch = true;
				youtubesearch_changes.startSearch = /*startSearch*/ ctx[1];
				add_flush_callback(() => updating_startSearch = false);
			}

			if (!updating_videos && dirty & /*songData*/ 8) {
				updating_videos = true;
				youtubesearch_changes.videos = /*songData*/ ctx[3].videos;
				add_flush_callback(() => updating_videos = false);
			}

			youtubesearch.$set(youtubesearch_changes);
			const input1_changes = {};

			if (!updating_value_1 && dirty & /*songData*/ 8) {
				updating_value_1 = true;
				input1_changes.value = /*songData*/ ctx[3].tab;
				add_flush_callback(() => updating_value_1 = false);
			}

			input1.$set(input1_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index !== previous_block_index) {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(button, null);
			}

			if (!current || dirty & /*songData, loading*/ 12 && button_disabled_value !== (button_disabled_value = !/*songData*/ ctx[3].title || /*loading*/ ctx[2])) {
				prop_dev(button, "disabled", button_disabled_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(spotifysearch.$$.fragment, local);
			transition_in(input0.$$.fragment, local);
			transition_in(youtubesearch.$$.fragment, local);
			transition_in(input1.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(spotifysearch.$$.fragment, local);
			transition_out(input0.$$.fragment, local);
			transition_out(youtubesearch.$$.fragment, local);
			transition_out(input1.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(spotifysearch);
			destroy_component(input0);
			destroy_component(youtubesearch);
			destroy_component(input1);
			if_blocks[current_block_type_index].d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $spotifyToken;
	validate_store(spotifyToken, 'spotifyToken');
	component_subscribe($$self, spotifyToken, $$value => $$invalidate(13, $spotifyToken = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('NewLesson', slots, []);
	let videoSearch;
	let startSearch = false;
	let loading = false;

	let songData = {
		title: null,
		artist: null,
		videos: [],
		tab: null,
		coordinates: [{ 0: {}, 1: {}, 2: {}, 3: {}, 4: {}, 5: {} }]
	};

	// let tabSearch;
	// let tabs;
	// let tabError;
	// async function searchSongsterr() {
	//   if (tabSearch && tabSearch.length > 3) {
	//     songData.tab = null;
	//     videos = null;
	//     try {
	//       const res = await apiCall("http://www.songsterr.com/a/ra/songs.json", {
	//         pattern: tabSearch,
	//       });
	//       console.log("FIRE: searchSongsterr -> res", res);
	//       tabs = res > 7 ? res.slice(0, 7) : res;
	//       tabError = null;
	//     } catch (error) {
	//       tabError = "Oops, couldn't get data from songsterr. Sorry :-(";
	//     }
	//   }
	// }
	const handleSubmit = async () => {
		if ($spotifyToken) {
			try {
				$$invalidate(2, loading = true);

				const { data } = await axios("https://api.spotify.com/v1/audio-features", {
					headers: {
						"Content-Type": "application/json",
						Authorization: `Authorization: Bearer ${$spotifyToken}`
					},
					params: { ids: songData.spotifyID }
				});

				if (data?.audio_features[0]) {
					$$invalidate(3, songData = {
						...songData,
						audioFeatures: data?.audio_features[0]
					});
				}
			} catch(err) {
				console.error(err);
			} finally {
				$$invalidate(2, loading = false);
			}
		}

		try {
			$$invalidate(3, songData.id = `${songData.title}-${createID()}`, songData);
			await transaction("put", songData, "readwrite");
			push(`#/lesson/${encodeURIComponent(songData.id)}`);
		} catch(err) {
			console.error(err);
		}
	};

	function handleSpotifySearchClick(data) {
		$$invalidate(3, songData = {
			...songData,
			...data,
			title: data.name,
			spotifyID: data.id
		});

		$$invalidate(3, songData.artist = getArtists(data.artists), songData);
		$$invalidate(0, videoSearch = `${songData.name} guitar tutorial`);
		$$invalidate(1, startSearch = true);
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<NewLesson> was created with unknown prop '${key}'`);
	});

	function spotifysearch_songName_binding(value) {
		if ($$self.$$.not_equal(songData.title, value)) {
			songData.title = value;
			$$invalidate(3, songData);
		}
	}

	const song_handler = e => handleSpotifySearchClick(e.detail);

	function input0_value_binding(value) {
		if ($$self.$$.not_equal(songData.artist, value)) {
			songData.artist = value;
			$$invalidate(3, songData);
		}
	}

	function youtubesearch_videoSearch_binding(value) {
		videoSearch = value;
		$$invalidate(0, videoSearch);
	}

	function youtubesearch_startSearch_binding(value) {
		startSearch = value;
		$$invalidate(1, startSearch);
	}

	function youtubesearch_videos_binding(value) {
		if ($$self.$$.not_equal(songData.videos, value)) {
			songData.videos = value;
			$$invalidate(3, songData);
		}
	}

	function input1_value_binding(value) {
		if ($$self.$$.not_equal(songData.tab, value)) {
			songData.tab = value;
			$$invalidate(3, songData);
		}
	}

	$$self.$capture_state = () => ({
		axios,
		push,
		spotifyToken,
		SpotifySearch,
		YoutubeSearch,
		Input,
		Loading,
		getArtists,
		createID,
		transaction,
		videoSearch,
		startSearch,
		loading,
		songData,
		handleSubmit,
		handleSpotifySearchClick,
		$spotifyToken
	});

	$$self.$inject_state = $$props => {
		if ('videoSearch' in $$props) $$invalidate(0, videoSearch = $$props.videoSearch);
		if ('startSearch' in $$props) $$invalidate(1, startSearch = $$props.startSearch);
		if ('loading' in $$props) $$invalidate(2, loading = $$props.loading);
		if ('songData' in $$props) $$invalidate(3, songData = $$props.songData);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		videoSearch,
		startSearch,
		loading,
		songData,
		handleSubmit,
		handleSpotifySearchClick,
		spotifysearch_songName_binding,
		song_handler,
		input0_value_binding,
		youtubesearch_videoSearch_binding,
		youtubesearch_startSearch_binding,
		youtubesearch_videos_binding,
		input1_value_binding
	];
}

class NewLesson extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "NewLesson",
			options,
			id: create_fragment.name
		});
	}
}

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': NewLesson
});

export { app as default };
//# sourceMappingURL=main.js.map
