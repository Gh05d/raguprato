
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, A as validate_each_argument, v as validate_slots, Y as createEventDispatcher, e as element, t as text, a as space, c as claim_element, b as children, f as claim_text, g as detach_dev, h as claim_space, k as attr_dev, j as add_location, U as src_url_equal, F as toggle_class, l as insert_hydration_dev, m as append_hydration_dev, x as listen_dev, Z as stop_propagation, w as set_data_dev, z as run_all, B as empty, n as noop, C as destroy_each, X as bubble, D as set_input_value, _ as is_function, u as globals, $ as binding_callbacks, a0 as bind, o as validate_store, I as spotifyToken, p as component_subscribe, q as onMount, J as create_component, K as claim_component, L as mount_component, N as transition_in, O as transition_out, P as destroy_component, a1 as add_flush_callback, V as group_outros, W as check_outros, T as push, y as prevent_default, M as prop_dev } from './main-7ace8c10.js';
import { g as getArtists, e as createID, d as debounce, a as authenticateSpotify, b as axios, c as apiCall, L as LESSONS } from './helpers-1ffa8285.js';
import { V as VideoSnippet } from './VideoSnippet-6195bdb6.js';

/* src/pages/NewLesson/SpotifyResponse.svelte generated by Svelte v3.47.0 */
const file$6 = "src/pages/NewLesson/SpotifyResponse.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (21:0) {#each data as song}
function create_each_block$1(ctx) {
	let section;
	let h3;
	let span0;
	let t0_value = /*song*/ ctx[6]?.name + "";
	let t0;
	let t1;
	let span1;
	let t2_value = getArtists(/*song*/ ctx[6].artists) + "";
	let t2;
	let t3;
	let div1;
	let div0;
	let t4_value = transformSongLength(/*song*/ ctx[6]?.duration_ms) + "";
	let t4;
	let t5;
	let a;
	let i;
	let a_href_value;
	let t6;
	let img;
	let img_src_value;
	let img_height_value;
	let img_width_value;
	let img_alt_value;
	let t7;
	let audio;
	let source;
	let source_src_value;
	let t8;
	let mounted;
	let dispose;

	function keydown_handler() {
		return /*keydown_handler*/ ctx[3](/*song*/ ctx[6]);
	}

	function click_handler_1() {
		return /*click_handler_1*/ ctx[4](/*song*/ ctx[6]);
	}

	const block = {
		c: function create() {
			section = element("section");
			h3 = element("h3");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = text(" by\n      ");
			span1 = element("span");
			t2 = text(t2_value);
			t3 = space();
			div1 = element("div");
			div0 = element("div");
			t4 = text(t4_value);
			t5 = space();
			a = element("a");
			i = element("i");
			t6 = space();
			img = element("img");
			t7 = space();
			audio = element("audio");
			source = element("source");
			t8 = space();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { role: true, tabindex: true, class: true });
			var section_nodes = children(section);
			h3 = claim_element(section_nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			span0 = claim_element(h3_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, t0_value);
			span0_nodes.forEach(detach_dev);
			t1 = claim_text(h3_nodes, " by\n      ");
			span1 = claim_element(h3_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			t2 = claim_text(span1_nodes, t2_value);
			span1_nodes.forEach(detach_dev);
			h3_nodes.forEach(detach_dev);
			t3 = claim_space(section_nodes);
			div1 = claim_element(section_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t4 = claim_text(div0_nodes, t4_value);
			div0_nodes.forEach(detach_dev);
			t5 = claim_space(div1_nodes);
			a = claim_element(div1_nodes, "A", { target: true, href: true, class: true });
			var a_nodes = children(a);
			i = claim_element(a_nodes, "I", { class: true });
			children(i).forEach(detach_dev);
			a_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t6 = claim_space(section_nodes);

			img = claim_element(section_nodes, "IMG", {
				src: true,
				height: true,
				width: true,
				alt: true
			});

			t7 = claim_space(section_nodes);
			audio = claim_element(section_nodes, "AUDIO", {});
			var audio_nodes = children(audio);
			source = claim_element(audio_nodes, "SOURCE", { src: true, type: true });
			audio_nodes.forEach(detach_dev);
			t8 = claim_space(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span0, "class", "svelte-1kyf0m7");
			add_location(span0, file$6, 28, 6, 700);
			attr_dev(span1, "class", "svelte-1kyf0m7");
			add_location(span1, file$6, 29, 6, 735);
			attr_dev(h3, "class", "svelte-1kyf0m7");
			add_location(h3, file$6, 27, 4, 689);
			attr_dev(div0, "class", "length");
			add_location(div0, file$6, 33, 6, 815);
			attr_dev(i, "class", "fab fa-spotify");
			add_location(i, file$6, 37, 8, 993);
			attr_dev(a, "target", "_blank");
			attr_dev(a, "href", a_href_value = /*song*/ ctx[6]?.external_urls?.spotify);
			attr_dev(a, "class", "svelte-1kyf0m7");
			add_location(a, file$6, 36, 6, 904);
			attr_dev(div1, "class", "info svelte-1kyf0m7");
			add_location(div1, file$6, 32, 4, 790);
			if (!src_url_equal(img.src, img_src_value = /*song*/ ctx[6].album?.images[1]?.url)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "height", img_height_value = /*song*/ ctx[6].album?.images[1]?.height);
			attr_dev(img, "width", img_width_value = /*song*/ ctx[6].album?.images[1]?.height);
			attr_dev(img, "alt", img_alt_value = `Album cover of ${/*song*/ ctx[6].name}`);
			add_location(img, file$6, 41, 4, 1049);
			if (!src_url_equal(source.src, source_src_value = /*song*/ ctx[6].preview_url)) attr_dev(source, "src", source_src_value);
			attr_dev(source, "type", "audio/mpeg");
			add_location(source, file$6, 48, 6, 1266);
			audio.controls = "controls";
			add_location(audio, file$6, 47, 4, 1232);
			attr_dev(section, "role", "button");
			attr_dev(section, "tabindex", "0");
			attr_dev(section, "class", "svelte-1kyf0m7");
			toggle_class(section, "show", /*song*/ ctx[6]);
			add_location(section, file$6, 21, 2, 540);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, section, anchor);
			append_hydration_dev(section, h3);
			append_hydration_dev(h3, span0);
			append_hydration_dev(span0, t0);
			append_hydration_dev(h3, t1);
			append_hydration_dev(h3, span1);
			append_hydration_dev(span1, t2);
			append_hydration_dev(section, t3);
			append_hydration_dev(section, div1);
			append_hydration_dev(div1, div0);
			append_hydration_dev(div0, t4);
			append_hydration_dev(div1, t5);
			append_hydration_dev(div1, a);
			append_hydration_dev(a, i);
			append_hydration_dev(section, t6);
			append_hydration_dev(section, img);
			append_hydration_dev(section, t7);
			append_hydration_dev(section, audio);
			append_hydration_dev(audio, source);
			append_hydration_dev(section, t8);

			if (!mounted) {
				dispose = [
					listen_dev(a, "click", stop_propagation(/*click_handler*/ ctx[2]), false, false, true),
					listen_dev(section, "keydown", keydown_handler, false, false, false),
					listen_dev(section, "click", click_handler_1, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*data*/ 1 && t0_value !== (t0_value = /*song*/ ctx[6]?.name + "")) set_data_dev(t0, t0_value);
			if (dirty & /*data*/ 1 && t2_value !== (t2_value = getArtists(/*song*/ ctx[6].artists) + "")) set_data_dev(t2, t2_value);
			if (dirty & /*data*/ 1 && t4_value !== (t4_value = transformSongLength(/*song*/ ctx[6]?.duration_ms) + "")) set_data_dev(t4, t4_value);

			if (dirty & /*data*/ 1 && a_href_value !== (a_href_value = /*song*/ ctx[6]?.external_urls?.spotify)) {
				attr_dev(a, "href", a_href_value);
			}

			if (dirty & /*data*/ 1 && !src_url_equal(img.src, img_src_value = /*song*/ ctx[6].album?.images[1]?.url)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty & /*data*/ 1 && img_height_value !== (img_height_value = /*song*/ ctx[6].album?.images[1]?.height)) {
				attr_dev(img, "height", img_height_value);
			}

			if (dirty & /*data*/ 1 && img_width_value !== (img_width_value = /*song*/ ctx[6].album?.images[1]?.height)) {
				attr_dev(img, "width", img_width_value);
			}

			if (dirty & /*data*/ 1 && img_alt_value !== (img_alt_value = `Album cover of ${/*song*/ ctx[6].name}`)) {
				attr_dev(img, "alt", img_alt_value);
			}

			if (dirty & /*data*/ 1 && !src_url_equal(source.src, source_src_value = /*song*/ ctx[6].preview_url)) {
				attr_dev(source, "src", source_src_value);
			}

			if (dirty & /*data*/ 1) {
				toggle_class(section, "show", /*song*/ ctx[6]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(21:0) {#each data as song}",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let each_1_anchor;
	let each_value = /*data*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_hydration_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*data, returnData, transformSongLength, getArtists*/ 3) {
				each_value = /*data*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function transformSongLength(ms) {
	const seconds = ms / 1000;
	const minutes = seconds / 60;
	const remainingSeconds = seconds % 60;
	return `${minutes.toFixed(0)}:${remainingSeconds.toFixed(0) < 10 ? "0" : ""}${remainingSeconds.toFixed(0)}`;
}

function instance$6($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('SpotifyResponse', slots, []);
	let { data } = $$props;
	const dispatch = createEventDispatcher();
	const returnData = song => dispatch("song", song);
	const writable_props = ['data'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SpotifyResponse> was created with unknown prop '${key}'`);
	});

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	const keydown_handler = song => returnData(song);
	const click_handler_1 = song => returnData(song);

	$$self.$$set = $$props => {
		if ('data' in $$props) $$invalidate(0, data = $$props.data);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		getArtists,
		data,
		transformSongLength,
		dispatch,
		returnData
	});

	$$self.$inject_state = $$props => {
		if ('data' in $$props) $$invalidate(0, data = $$props.data);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [data, returnData, click_handler, keydown_handler, click_handler_1];
}

class SpotifyResponse extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { data: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SpotifyResponse",
			options,
			id: create_fragment$6.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*data*/ ctx[0] === undefined && !('data' in props)) {
			console.warn("<SpotifyResponse> was created without expected prop 'data'");
		}
	}

	get data() {
		throw new Error("<SpotifyResponse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<SpotifyResponse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Input.svelte generated by Svelte v3.47.0 */
const file$5 = "src/components/Input.svelte";

// (16:2) {#if error}
function create_if_block$2(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(/*error*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, /*error*/ ctx[2]);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "error svelte-1nsq3fe");
			add_location(div, file$5, 16, 4, 378);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*error*/ 4) set_data_dev(t, /*error*/ ctx[2]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(16:2) {#if error}",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let div;
	let input;
	let t0;
	let label_1;
	let t1;
	let t2;
	let mounted;
	let dispose;
	let if_block = /*error*/ ctx[2] && create_if_block$2(ctx);

	const block = {
		c: function create() {
			div = element("div");
			input = element("input");
			t0 = space();
			label_1 = element("label");
			t1 = text(/*label*/ ctx[1]);
			t2 = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			input = claim_element(div_nodes, "INPUT", { id: true, class: true });
			t0 = claim_space(div_nodes);
			label_1 = claim_element(div_nodes, "LABEL", { for: true, class: true });
			var label_1_nodes = children(label_1);
			t1 = claim_text(label_1_nodes, /*label*/ ctx[1]);
			label_1_nodes.forEach(detach_dev);
			t2 = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "id", /*inputID*/ ctx[4]);
			attr_dev(input, "class", "svelte-1nsq3fe");
			add_location(input, file$5, 12, 2, 240);
			attr_dev(label_1, "for", /*inputID*/ ctx[4]);
			attr_dev(label_1, "class", "svelte-1nsq3fe");
			toggle_class(label_1, "flying-label", /*value*/ ctx[0]);
			add_location(label_1, file$5, 13, 2, 295);
			attr_dev(div, "class", "input-container svelte-1nsq3fe");
			add_location(div, file$5, 11, 0, 208);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, input);
			set_input_value(input, /*value*/ ctx[0]);
			append_hydration_dev(div, t0);
			append_hydration_dev(div, label_1);
			append_hydration_dev(label_1, t1);
			append_hydration_dev(div, t2);
			if (if_block) if_block.m(div, null);

			if (!mounted) {
				dispose = [
					listen_dev(
						input,
						"input",
						function () {
							if (is_function(/*onInput*/ ctx[3])) /*onInput*/ ctx[3].apply(this, arguments);
						},
						false,
						false,
						false
					),
					listen_dev(input, "input", /*input_input_handler*/ ctx[5])
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty & /*label*/ 2) set_data_dev(t1, /*label*/ ctx[1]);

			if (dirty & /*value*/ 1) {
				toggle_class(label_1, "flying-label", /*value*/ ctx[0]);
			}

			if (/*error*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Input', slots, []);
	let { value } = $$props;
	let { label } = $$props;
	let { error = null } = $$props;
	let { onInput = null } = $$props;
	let inputID = `${label}-${createID()}`;
	const writable_props = ['value', 'label', 'error', 'onInput'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Input> was created with unknown prop '${key}'`);
	});

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('label' in $$props) $$invalidate(1, label = $$props.label);
		if ('error' in $$props) $$invalidate(2, error = $$props.error);
		if ('onInput' in $$props) $$invalidate(3, onInput = $$props.onInput);
	};

	$$self.$capture_state = () => ({
		createID,
		value,
		label,
		error,
		onInput,
		inputID
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('label' in $$props) $$invalidate(1, label = $$props.label);
		if ('error' in $$props) $$invalidate(2, error = $$props.error);
		if ('onInput' in $$props) $$invalidate(3, onInput = $$props.onInput);
		if ('inputID' in $$props) $$invalidate(4, inputID = $$props.inputID);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [value, label, error, onInput, inputID, input_input_handler];
}

class Input extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { value: 0, label: 1, error: 2, onInput: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Input",
			options,
			id: create_fragment$5.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*value*/ ctx[0] === undefined && !('value' in props)) {
			console.warn("<Input> was created without expected prop 'value'");
		}

		if (/*label*/ ctx[1] === undefined && !('label' in props)) {
			console.warn("<Input> was created without expected prop 'label'");
		}
	}

	get value() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get error() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set error(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onInput() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onInput(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Loading.svelte generated by Svelte v3.47.0 */

const file$4 = "src/components/Loading.svelte";

function create_fragment$4(ctx) {
	let div;
	let span;
	let t0;
	let t1;
	let i;

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			t0 = text(/*text*/ ctx[0]);
			t1 = space();
			i = element("i");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			span = claim_element(div_nodes, "SPAN", {});
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, /*text*/ ctx[0]);
			span_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			i = claim_element(div_nodes, "I", { class: true });
			children(i).forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(span, file$4, 5, 2, 78);
			attr_dev(i, "class", "fa fa-spinner fa-spin");
			add_location(i, file$4, 5, 22, 98);
			attr_dev(div, "class", "loading svelte-fp2n7");
			add_location(div, file$4, 4, 0, 54);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, span);
			append_hydration_dev(span, t0);
			append_hydration_dev(div, t1);
			append_hydration_dev(div, i);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*text*/ 1) set_data_dev(t0, /*text*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Loading', slots, []);
	let { text = "Loading..." } = $$props;
	const writable_props = ['text'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Loading> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('text' in $$props) $$invalidate(0, text = $$props.text);
	};

	$$self.$capture_state = () => ({ text });

	$$self.$inject_state = $$props => {
		if ('text' in $$props) $$invalidate(0, text = $$props.text);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [text];
}

class Loading extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { text: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Loading",
			options,
			id: create_fragment$4.name
		});
	}

	get text() {
		throw new Error("<Loading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<Loading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Error.svelte generated by Svelte v3.47.0 */

const { Error: Error_1$2, console: console_1$1 } = globals;
const file$3 = "src/components/Error.svelte";

function create_fragment$3(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(/*errorMessage*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, /*errorMessage*/ ctx[0]);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svelte-3sgp1q");
			toggle_class(div, "show", /*error*/ ctx[1]);
			add_location(div, file$3, 7, 0, 152);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*errorMessage*/ 1) set_data_dev(t, /*errorMessage*/ ctx[0]);

			if (dirty & /*error*/ 2) {
				toggle_class(div, "show", /*error*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Error', slots, []);
	let { errorMessage = "Sorry, something went wrong 😔" } = $$props;
	let { error = null } = $$props;
	const writable_props = ['errorMessage', 'error'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<Error> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('errorMessage' in $$props) $$invalidate(0, errorMessage = $$props.errorMessage);
		if ('error' in $$props) $$invalidate(1, error = $$props.error);
	};

	$$self.$capture_state = () => ({ errorMessage, error });

	$$self.$inject_state = $$props => {
		if ('errorMessage' in $$props) $$invalidate(0, errorMessage = $$props.errorMessage);
		if ('error' in $$props) $$invalidate(1, error = $$props.error);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*error*/ 2) {
			error ? console.error(error) : null;
		}
	};

	return [errorMessage, error];
}

class Error$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { errorMessage: 0, error: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Error",
			options,
			id: create_fragment$3.name
		});
	}

	get errorMessage() {
		throw new Error_1$2("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errorMessage(value) {
		throw new Error_1$2("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get error() {
		throw new Error_1$2("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set error(value) {
		throw new Error_1$2("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/pages/NewLesson/SpotifySearch.svelte generated by Svelte v3.47.0 */

const { Error: Error_1$1 } = globals;
const file$2 = "src/pages/NewLesson/SpotifySearch.svelte";

// (51:2) {#if loading}
function create_if_block_1(ctx) {
	let loading_1;
	let current;

	loading_1 = new Loading({
			props: { text: "Searching Spotify..." },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(loading_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(loading_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(loading_1, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(loading_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loading_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(loading_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(51:2) {#if loading}",
		ctx
	});

	return block;
}

// (57:2) {#if spotifyResponse}
function create_if_block$1(ctx) {
	let div;
	let spotifyresponse;
	let current;

	spotifyresponse = new SpotifyResponse({
			props: { data: /*spotifyResponse*/ ctx[3] },
			$$inline: true
		});

	spotifyresponse.$on("song", /*song_handler*/ ctx[6]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(spotifyresponse.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(spotifyresponse.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "search-results svelte-1pkvtmg");
			add_location(div, file$2, 57, 4, 1499);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			mount_component(spotifyresponse, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const spotifyresponse_changes = {};
			if (dirty & /*spotifyResponse*/ 8) spotifyresponse_changes.data = /*spotifyResponse*/ ctx[3];
			spotifyresponse.$set(spotifyresponse_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(spotifyresponse.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(spotifyresponse.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(spotifyresponse);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(57:2) {#if spotifyResponse}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let input;
	let updating_value;
	let t0;
	let div;
	let t1;
	let error_1;
	let t2;
	let current;

	function input_value_binding(value) {
		/*input_value_binding*/ ctx[5](value);
	}

	let input_props = {
		label: "Song",
		onInput: debounce(/*searchSpotify*/ ctx[4])
	};

	if (/*songName*/ ctx[0] !== void 0) {
		input_props.value = /*songName*/ ctx[0];
	}

	input = new Input({ props: input_props, $$inline: true });
	binding_callbacks.push(() => bind(input, 'value', input_value_binding));
	let if_block0 = /*loading*/ ctx[1] && create_if_block_1(ctx);

	error_1 = new Error$1({
			props: { error: /*error*/ ctx[2] },
			$$inline: true
		});

	let if_block1 = /*spotifyResponse*/ ctx[3] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			create_component(input.$$.fragment);
			t0 = space();
			div = element("div");
			if (if_block0) if_block0.c();
			t1 = space();
			create_component(error_1.$$.fragment);
			t2 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			claim_component(input.$$.fragment, nodes);
			t0 = claim_space(nodes);
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t1 = claim_space(div_nodes);
			claim_component(error_1.$$.fragment, div_nodes);
			t2 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$2, 49, 0, 1375);
		},
		m: function mount(target, anchor) {
			mount_component(input, target, anchor);
			insert_hydration_dev(target, t0, anchor);
			insert_hydration_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_hydration_dev(div, t1);
			mount_component(error_1, div, null);
			append_hydration_dev(div, t2);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const input_changes = {};

			if (!updating_value && dirty & /*songName*/ 1) {
				updating_value = true;
				input_changes.value = /*songName*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);

			if (/*loading*/ ctx[1]) {
				if (if_block0) {
					if (dirty & /*loading*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			const error_1_changes = {};
			if (dirty & /*error*/ 4) error_1_changes.error = /*error*/ ctx[2];
			error_1.$set(error_1_changes);

			if (/*spotifyResponse*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*spotifyResponse*/ 8) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(if_block0);
			transition_in(error_1.$$.fragment, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(input.$$.fragment, local);
			transition_out(if_block0);
			transition_out(error_1.$$.fragment, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(input, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			destroy_component(error_1);
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let $spotifyToken;
	validate_store(spotifyToken, 'spotifyToken');
	component_subscribe($$self, spotifyToken, $$value => $$invalidate(7, $spotifyToken = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('SpotifySearch', slots, []);
	let { songName = "" } = $$props;
	let loading = false;
	let error = null;
	let spotifyResponse = null;

	async function searchSpotify() {
		if ($spotifyToken && songName.length > 1) {
			$$invalidate(2, error = null);
			$$invalidate(1, loading = true);

			try {
				const { data } = await axios("https://api.spotify.com/v1/search", {
					headers: {
						Authorization: `Authorization: Bearer ${$spotifyToken}`
					},
					params: { q: songName, type: "track", limit: 5 }
				});

				$$invalidate(3, spotifyResponse = data?.tracks?.items);
			} catch(err) {
				$$invalidate(2, error = err);
			} finally {
				$$invalidate(1, loading = false);
			}
		}
	}

	onMount(() => {
		(async function init() {
			if (!$spotifyToken) {
				const credentials = await authenticateSpotify();
				spotifyToken.set(credentials?.data?.access_token);
			}
		})();
	});

	const writable_props = ['songName'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SpotifySearch> was created with unknown prop '${key}'`);
	});

	function input_value_binding(value) {
		songName = value;
		$$invalidate(0, songName);
	}

	function song_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('songName' in $$props) $$invalidate(0, songName = $$props.songName);
	};

	$$self.$capture_state = () => ({
		onMount,
		axios,
		SpotifyResponse,
		Input,
		Loading,
		Error: Error$1,
		spotifyToken,
		authenticateSpotify,
		debounce,
		songName,
		loading,
		error,
		spotifyResponse,
		searchSpotify,
		$spotifyToken
	});

	$$self.$inject_state = $$props => {
		if ('songName' in $$props) $$invalidate(0, songName = $$props.songName);
		if ('loading' in $$props) $$invalidate(1, loading = $$props.loading);
		if ('error' in $$props) $$invalidate(2, error = $$props.error);
		if ('spotifyResponse' in $$props) $$invalidate(3, spotifyResponse = $$props.spotifyResponse);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		songName,
		loading,
		error,
		spotifyResponse,
		searchSpotify,
		input_value_binding,
		song_handler
	];
}

class SpotifySearch extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { songName: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SpotifySearch",
			options,
			id: create_fragment$2.name
		});
	}

	get songName() {
		throw new Error_1$1("<SpotifySearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set songName(value) {
		throw new Error_1$1("<SpotifySearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/pages/NewLesson/YoutubeSearch.svelte generated by Svelte v3.47.0 */

const { Error: Error_1 } = globals;
const file$1 = "src/pages/NewLesson/YoutubeSearch.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (58:2) {#each searchResult as video}
function create_each_block(ctx) {
	let li;
	let videosnippet;
	let t;
	let li_title_value;
	let current;
	let mounted;
	let dispose;

	videosnippet = new VideoSnippet({
			props: { snippet: /*video*/ ctx[11].snippet },
			$$inline: true
		});

	function click_handler() {
		return /*click_handler*/ ctx[9](/*video*/ ctx[11]);
	}

	const block = {
		c: function create() {
			li = element("li");
			create_component(videosnippet.$$.fragment);
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { title: true, class: true, role: true });
			var li_nodes = children(li);
			claim_component(videosnippet.$$.fragment, li_nodes);
			t = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(li, "title", li_title_value = `Click to ${/*findID*/ ctx[3](/*video*/ ctx[11].id.videoId)
			? "un"
			: ""}select`);

			attr_dev(li, "class", "empty-button svelte-krholc");
			attr_dev(li, "role", "button");
			toggle_class(li, "selected", /*findID*/ ctx[3](/*video*/ ctx[11].id.videoId));
			add_location(li, file$1, 58, 4, 1591);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, li, anchor);
			mount_component(videosnippet, li, null);
			append_hydration_dev(li, t);
			current = true;

			if (!mounted) {
				dispose = listen_dev(li, "click", click_handler, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const videosnippet_changes = {};
			if (dirty & /*searchResult*/ 2) videosnippet_changes.snippet = /*video*/ ctx[11].snippet;
			videosnippet.$set(videosnippet_changes);

			if (!current || dirty & /*findID, searchResult*/ 10 && li_title_value !== (li_title_value = `Click to ${/*findID*/ ctx[3](/*video*/ ctx[11].id.videoId)
			? "un"
			: ""}select`)) {
				attr_dev(li, "title", li_title_value);
			}

			if (dirty & /*findID, searchResult*/ 10) {
				toggle_class(li, "selected", /*findID*/ ctx[3](/*video*/ ctx[11].id.videoId));
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(videosnippet.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(videosnippet.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			destroy_component(videosnippet);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(58:2) {#each searchResult as video}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let input;
	let updating_value;
	let t0;
	let error;
	let t1;
	let ul;
	let current;

	function input_value_binding(value) {
		/*input_value_binding*/ ctx[8](value);
	}

	let input_props = {
		label: "Search Youtube",
		onInput: /*debouncedSearch*/ ctx[5]
	};

	if (/*videoSearch*/ ctx[0] !== void 0) {
		input_props.value = /*videoSearch*/ ctx[0];
	}

	input = new Input({ props: input_props, $$inline: true });
	binding_callbacks.push(() => bind(input, 'value', input_value_binding));

	error = new Error$1({
			props: { error: /*videoError*/ ctx[2] },
			$$inline: true
		});

	let each_value = /*searchResult*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			create_component(input.$$.fragment);
			t0 = space();
			create_component(error.$$.fragment);
			t1 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			claim_component(input.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(error.$$.fragment, nodes);
			t1 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "search-result svelte-krholc");
			toggle_class(ul, "show", /*searchResult*/ ctx[1]);
			add_location(ul, file$1, 56, 0, 1502);
		},
		m: function mount(target, anchor) {
			mount_component(input, target, anchor);
			insert_hydration_dev(target, t0, anchor);
			mount_component(error, target, anchor);
			insert_hydration_dev(target, t1, anchor);
			insert_hydration_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			const input_changes = {};

			if (!updating_value && dirty & /*videoSearch*/ 1) {
				updating_value = true;
				input_changes.value = /*videoSearch*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
			const error_changes = {};
			if (dirty & /*videoError*/ 4) error_changes.error = /*videoError*/ ctx[2];
			error.$set(error_changes);

			if (dirty & /*findID, searchResult, handleClick*/ 26) {
				each_value = /*searchResult*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (dirty & /*searchResult*/ 2) {
				toggle_class(ul, "show", /*searchResult*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(error.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(input.$$.fragment, local);
			transition_out(error.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(input, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(error, detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let findID;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('YoutubeSearch', slots, []);
	let { videos } = $$props;
	let { videoSearch } = $$props;
	let { startSearch = false } = $$props;
	let searchResult = [];
	let videoError;

	async function searchYoutube() {
		if (videoSearch?.length > 2) {
			try {
				const res = await apiCall("https://www.googleapis.com/youtube/v3/search", {
					q: videoSearch,
					type: "video",
					key: "AIzaSyAViHdvitELO2-jct4oVozhk8Wq3hCkjRk",
					part: "snippet",
					maxResults: 7,
					topicId: "/m/04rlf"
				});

				$$invalidate(1, searchResult = res.items);
				$$invalidate(2, videoError = null);
				$$invalidate(7, startSearch = false);
			} catch(error) {
				$$invalidate(2, videoError = error);
			}
		}
	}

	function handleClick(video) {
		if (videos.length > 0) {
			const alreadyIn = findID(video.id.videoId);

			if (alreadyIn) {
				$$invalidate(6, videos = videos.filter(vid => vid != alreadyIn));
			} else {
				$$invalidate(6, videos = [...videos, video.id.videoId]);
			}
		} else {
			$$invalidate(6, videos = [video.id.videoId]);
		}
	}

	const debouncedSearch = debounce(searchYoutube);
	const writable_props = ['videos', 'videoSearch', 'startSearch'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<YoutubeSearch> was created with unknown prop '${key}'`);
	});

	function input_value_binding(value) {
		videoSearch = value;
		$$invalidate(0, videoSearch);
	}

	const click_handler = video => handleClick(video);

	$$self.$$set = $$props => {
		if ('videos' in $$props) $$invalidate(6, videos = $$props.videos);
		if ('videoSearch' in $$props) $$invalidate(0, videoSearch = $$props.videoSearch);
		if ('startSearch' in $$props) $$invalidate(7, startSearch = $$props.startSearch);
	};

	$$self.$capture_state = () => ({
		VideoSnippet,
		Input,
		Error: Error$1,
		debounce,
		apiCall,
		videos,
		videoSearch,
		startSearch,
		searchResult,
		videoError,
		searchYoutube,
		handleClick,
		debouncedSearch,
		findID
	});

	$$self.$inject_state = $$props => {
		if ('videos' in $$props) $$invalidate(6, videos = $$props.videos);
		if ('videoSearch' in $$props) $$invalidate(0, videoSearch = $$props.videoSearch);
		if ('startSearch' in $$props) $$invalidate(7, startSearch = $$props.startSearch);
		if ('searchResult' in $$props) $$invalidate(1, searchResult = $$props.searchResult);
		if ('videoError' in $$props) $$invalidate(2, videoError = $$props.videoError);
		if ('findID' in $$props) $$invalidate(3, findID = $$props.findID);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*videos*/ 64) {
			$$invalidate(3, findID = id => videos?.find(videoID => id == videoID));
		}

		if ($$self.$$.dirty & /*startSearch*/ 128) {
			startSearch ? searchYoutube() : null;
		}
	};

	return [
		videoSearch,
		searchResult,
		videoError,
		findID,
		handleClick,
		debouncedSearch,
		videos,
		startSearch,
		input_value_binding,
		click_handler
	];
}

class YoutubeSearch extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			videos: 6,
			videoSearch: 0,
			startSearch: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "YoutubeSearch",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*videos*/ ctx[6] === undefined && !('videos' in props)) {
			console.warn("<YoutubeSearch> was created without expected prop 'videos'");
		}

		if (/*videoSearch*/ ctx[0] === undefined && !('videoSearch' in props)) {
			console.warn("<YoutubeSearch> was created without expected prop 'videoSearch'");
		}
	}

	get videos() {
		throw new Error_1("<YoutubeSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set videos(value) {
		throw new Error_1("<YoutubeSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get videoSearch() {
		throw new Error_1("<YoutubeSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set videoSearch(value) {
		throw new Error_1("<YoutubeSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get startSearch() {
		throw new Error_1("<YoutubeSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set startSearch(value) {
		throw new Error_1("<YoutubeSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/pages/NewLesson/index.svelte generated by Svelte v3.47.0 */

const { console: console_1 } = globals;
const file = "src/pages/NewLesson/index.svelte";

// (147:6) {:else}
function create_else_block(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("Save Lesson");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, "Save Lesson");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(span, file, 147, 8, 4082);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(147:6) {:else}",
		ctx
	});

	return block;
}

// (145:6) {#if loading}
function create_if_block(ctx) {
	let loading_1;
	let current;
	loading_1 = new Loading({ props: { text: "" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(loading_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(loading_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(loading_1, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(loading_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loading_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(loading_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(145:6) {#if loading}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let section;
	let h1;
	let t0;
	let t1;
	let form;
	let spotifysearch;
	let updating_songName;
	let t2;
	let input0;
	let updating_value;
	let t3;
	let youtubesearch;
	let updating_videoSearch;
	let updating_startSearch;
	let updating_videos;
	let t4;
	let input1;
	let updating_value_1;
	let t5;
	let button;
	let current_block_type_index;
	let if_block;
	let button_disabled_value;
	let current;
	let mounted;
	let dispose;

	function spotifysearch_songName_binding(value) {
		/*spotifysearch_songName_binding*/ ctx[6](value);
	}

	let spotifysearch_props = {};

	if (/*songData*/ ctx[3].title !== void 0) {
		spotifysearch_props.songName = /*songData*/ ctx[3].title;
	}

	spotifysearch = new SpotifySearch({
			props: spotifysearch_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(spotifysearch, 'songName', spotifysearch_songName_binding));
	spotifysearch.$on("song", /*song_handler*/ ctx[7]);

	function input0_value_binding(value) {
		/*input0_value_binding*/ ctx[8](value);
	}

	let input0_props = { label: "Artist" };

	if (/*songData*/ ctx[3].artist !== void 0) {
		input0_props.value = /*songData*/ ctx[3].artist;
	}

	input0 = new Input({ props: input0_props, $$inline: true });
	binding_callbacks.push(() => bind(input0, 'value', input0_value_binding));

	function youtubesearch_videoSearch_binding(value) {
		/*youtubesearch_videoSearch_binding*/ ctx[9](value);
	}

	function youtubesearch_startSearch_binding(value) {
		/*youtubesearch_startSearch_binding*/ ctx[10](value);
	}

	function youtubesearch_videos_binding(value) {
		/*youtubesearch_videos_binding*/ ctx[11](value);
	}

	let youtubesearch_props = {};

	if (/*videoSearch*/ ctx[0] !== void 0) {
		youtubesearch_props.videoSearch = /*videoSearch*/ ctx[0];
	}

	if (/*startSearch*/ ctx[1] !== void 0) {
		youtubesearch_props.startSearch = /*startSearch*/ ctx[1];
	}

	if (/*songData*/ ctx[3].videos !== void 0) {
		youtubesearch_props.videos = /*songData*/ ctx[3].videos;
	}

	youtubesearch = new YoutubeSearch({
			props: youtubesearch_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(youtubesearch, 'videoSearch', youtubesearch_videoSearch_binding));
	binding_callbacks.push(() => bind(youtubesearch, 'startSearch', youtubesearch_startSearch_binding));
	binding_callbacks.push(() => bind(youtubesearch, 'videos', youtubesearch_videos_binding));

	function input1_value_binding(value) {
		/*input1_value_binding*/ ctx[12](value);
	}

	let input1_props = {
		label: "Enter Url of chord site like https://azchords.com/"
	};

	if (/*songData*/ ctx[3].tab !== void 0) {
		input1_props.value = /*songData*/ ctx[3].tab;
	}

	input1 = new Input({ props: input1_props, $$inline: true });
	binding_callbacks.push(() => bind(input1, 'value', input1_value_binding));
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*loading*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			section = element("section");
			h1 = element("h1");
			t0 = text("Create a new Lesson");
			t1 = space();
			form = element("form");
			create_component(spotifysearch.$$.fragment);
			t2 = space();
			create_component(input0.$$.fragment);
			t3 = space();
			create_component(youtubesearch.$$.fragment);
			t4 = space();
			create_component(input1.$$.fragment);
			t5 = space();
			button = element("button");
			if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { id: true, class: true });
			var section_nodes = children(section);
			h1 = claim_element(section_nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Create a new Lesson");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(section_nodes);
			form = claim_element(section_nodes, "FORM", { class: true });
			var form_nodes = children(form);
			claim_component(spotifysearch.$$.fragment, form_nodes);
			t2 = claim_space(form_nodes);
			claim_component(input0.$$.fragment, form_nodes);
			t3 = claim_space(form_nodes);
			claim_component(youtubesearch.$$.fragment, form_nodes);
			t4 = claim_space(form_nodes);
			claim_component(input1.$$.fragment, form_nodes);
			t5 = claim_space(form_nodes);
			button = claim_element(form_nodes, "BUTTON", { type: true });
			var button_nodes = children(button);
			if_block.l(button_nodes);
			button_nodes.forEach(detach_dev);
			form_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file, 106, 2, 2768);
			button.disabled = button_disabled_value = !/*songData*/ ctx[3].title || /*loading*/ ctx[2];
			attr_dev(button, "type", "submit");
			add_location(button, file, 143, 4, 3951);
			attr_dev(form, "class", "svelte-lqnpzt");
			add_location(form, file, 108, 2, 2800);
			attr_dev(section, "id", "container");
			attr_dev(section, "class", "svelte-lqnpzt");
			add_location(section, file, 105, 0, 2741);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, section, anchor);
			append_hydration_dev(section, h1);
			append_hydration_dev(h1, t0);
			append_hydration_dev(section, t1);
			append_hydration_dev(section, form);
			mount_component(spotifysearch, form, null);
			append_hydration_dev(form, t2);
			mount_component(input0, form, null);
			append_hydration_dev(form, t3);
			mount_component(youtubesearch, form, null);
			append_hydration_dev(form, t4);
			mount_component(input1, form, null);
			append_hydration_dev(form, t5);
			append_hydration_dev(form, button);
			if_blocks[current_block_type_index].m(button, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(form, "submit", prevent_default(/*handleSubmit*/ ctx[4]), false, true, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const spotifysearch_changes = {};

			if (!updating_songName && dirty & /*songData*/ 8) {
				updating_songName = true;
				spotifysearch_changes.songName = /*songData*/ ctx[3].title;
				add_flush_callback(() => updating_songName = false);
			}

			spotifysearch.$set(spotifysearch_changes);
			const input0_changes = {};

			if (!updating_value && dirty & /*songData*/ 8) {
				updating_value = true;
				input0_changes.value = /*songData*/ ctx[3].artist;
				add_flush_callback(() => updating_value = false);
			}

			input0.$set(input0_changes);
			const youtubesearch_changes = {};

			if (!updating_videoSearch && dirty & /*videoSearch*/ 1) {
				updating_videoSearch = true;
				youtubesearch_changes.videoSearch = /*videoSearch*/ ctx[0];
				add_flush_callback(() => updating_videoSearch = false);
			}

			if (!updating_startSearch && dirty & /*startSearch*/ 2) {
				updating_startSearch = true;
				youtubesearch_changes.startSearch = /*startSearch*/ ctx[1];
				add_flush_callback(() => updating_startSearch = false);
			}

			if (!updating_videos && dirty & /*songData*/ 8) {
				updating_videos = true;
				youtubesearch_changes.videos = /*songData*/ ctx[3].videos;
				add_flush_callback(() => updating_videos = false);
			}

			youtubesearch.$set(youtubesearch_changes);
			const input1_changes = {};

			if (!updating_value_1 && dirty & /*songData*/ 8) {
				updating_value_1 = true;
				input1_changes.value = /*songData*/ ctx[3].tab;
				add_flush_callback(() => updating_value_1 = false);
			}

			input1.$set(input1_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index !== previous_block_index) {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(button, null);
			}

			if (!current || dirty & /*songData, loading*/ 12 && button_disabled_value !== (button_disabled_value = !/*songData*/ ctx[3].title || /*loading*/ ctx[2])) {
				prop_dev(button, "disabled", button_disabled_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(spotifysearch.$$.fragment, local);
			transition_in(input0.$$.fragment, local);
			transition_in(youtubesearch.$$.fragment, local);
			transition_in(input1.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(spotifysearch.$$.fragment, local);
			transition_out(input0.$$.fragment, local);
			transition_out(youtubesearch.$$.fragment, local);
			transition_out(input1.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(spotifysearch);
			destroy_component(input0);
			destroy_component(youtubesearch);
			destroy_component(input1);
			if_blocks[current_block_type_index].d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $spotifyToken;
	validate_store(spotifyToken, 'spotifyToken');
	component_subscribe($$self, spotifyToken, $$value => $$invalidate(13, $spotifyToken = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('NewLesson', slots, []);
	let videoSearch;
	let startSearch = false;
	let loading = false;

	let songData = {
		title: null,
		artist: null,
		videos: [],
		tab: null,
		coordinates: [{ 0: {}, 1: {}, 2: {}, 3: {}, 4: {}, 5: {} }]
	};

	// let tabSearch;
	// let tabs;
	// let tabError;
	// async function searchSongsterr() {
	//   if (tabSearch && tabSearch.length > 3) {
	//     songData.tab = null;
	//     videos = null;
	//     try {
	//       const res = await apiCall("http://www.songsterr.com/a/ra/songs.json", {
	//         pattern: tabSearch,
	//       });
	//       console.log("FIRE: searchSongsterr -> res", res);
	//       tabs = res > 7 ? res.slice(0, 7) : res;
	//       tabError = null;
	//     } catch (error) {
	//       tabError = "Oops, couldn't get data from songsterr. Sorry :-(";
	//     }
	//   }
	// }
	const handleSubmit = async () => {
		if ($spotifyToken) {
			try {
				$$invalidate(2, loading = true);

				const { data } = await axios("https://api.spotify.com/v1/audio-features", {
					headers: {
						"Content-Type": "application/json",
						Authorization: `Authorization: Bearer ${$spotifyToken}`
					},
					params: { ids: songData.spotifyID }
				});

				if (data?.audio_features[0]) {
					$$invalidate(3, songData = {
						...songData,
						audioFeatures: data?.audio_features[0]
					});
				}
			} catch(err) {
				console.error(err);
			} finally {
				$$invalidate(2, loading = false);
			}
		}

		try {
			$$invalidate(3, songData.id = `${songData.title}-${createID()}`, songData);
			let lessons;
			const stringifiedLessons = await localStorage.getItem(LESSONS);

			if (stringifiedLessons) {
				lessons = JSON.parse(stringifiedLessons);
				lessons.push(songData);
			} else {
				lessons = [songData];
			}

			await localStorage.setItem(LESSONS, JSON.stringify(lessons));
			push(`#/lesson/${encodeURIComponent(songData.id)}`);
		} catch(err) {
			console.error(err);
		}
	};

	function handleSpotifySearchClick(data) {
		$$invalidate(3, songData = {
			...songData,
			...data,
			title: data.name,
			spotifyID: data.id
		});

		$$invalidate(3, songData.artist = getArtists(data.artists), songData);
		$$invalidate(0, videoSearch = `${songData.name} guitar tutorial`);
		$$invalidate(1, startSearch = true);
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<NewLesson> was created with unknown prop '${key}'`);
	});

	function spotifysearch_songName_binding(value) {
		if ($$self.$$.not_equal(songData.title, value)) {
			songData.title = value;
			$$invalidate(3, songData);
		}
	}

	const song_handler = e => handleSpotifySearchClick(e.detail);

	function input0_value_binding(value) {
		if ($$self.$$.not_equal(songData.artist, value)) {
			songData.artist = value;
			$$invalidate(3, songData);
		}
	}

	function youtubesearch_videoSearch_binding(value) {
		videoSearch = value;
		$$invalidate(0, videoSearch);
	}

	function youtubesearch_startSearch_binding(value) {
		startSearch = value;
		$$invalidate(1, startSearch);
	}

	function youtubesearch_videos_binding(value) {
		if ($$self.$$.not_equal(songData.videos, value)) {
			songData.videos = value;
			$$invalidate(3, songData);
		}
	}

	function input1_value_binding(value) {
		if ($$self.$$.not_equal(songData.tab, value)) {
			songData.tab = value;
			$$invalidate(3, songData);
		}
	}

	$$self.$capture_state = () => ({
		axios,
		push,
		spotifyToken,
		SpotifySearch,
		YoutubeSearch,
		Input,
		Loading,
		getArtists,
		createID,
		LESSONS,
		videoSearch,
		startSearch,
		loading,
		songData,
		handleSubmit,
		handleSpotifySearchClick,
		$spotifyToken
	});

	$$self.$inject_state = $$props => {
		if ('videoSearch' in $$props) $$invalidate(0, videoSearch = $$props.videoSearch);
		if ('startSearch' in $$props) $$invalidate(1, startSearch = $$props.startSearch);
		if ('loading' in $$props) $$invalidate(2, loading = $$props.loading);
		if ('songData' in $$props) $$invalidate(3, songData = $$props.songData);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		videoSearch,
		startSearch,
		loading,
		songData,
		handleSubmit,
		handleSpotifySearchClick,
		spotifysearch_songName_binding,
		song_handler,
		input0_value_binding,
		youtubesearch_videoSearch_binding,
		youtubesearch_startSearch_binding,
		youtubesearch_videos_binding,
		input1_value_binding
	];
}

class NewLesson extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "NewLesson",
			options,
			id: create_fragment.name
		});
	}
}

export { NewLesson as default };
//# sourceMappingURL=index-164c9d99.js.map
