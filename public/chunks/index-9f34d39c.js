
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
define(['exports', './main-c143da1f', './helpers-8cc365c8', './VideoSnippet-7bdb97da'], (function (exports, main, helpers, VideoSnippet) { 'use strict';

  /* src/pages/NewLesson/SpotifyResponse.svelte generated by Svelte v3.47.0 */
  const file$6 = "src/pages/NewLesson/SpotifyResponse.svelte";

  function get_each_context$1(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[6] = list[i];
  	return child_ctx;
  }

  // (21:0) {#each data as song}
  function create_each_block$1(ctx) {
  	let section;
  	let h3;
  	let span0;
  	let t0_value = /*song*/ ctx[6]?.name + "";
  	let t0;
  	let t1;
  	let span1;
  	let t2_value = helpers.getArtists(/*song*/ ctx[6].artists) + "";
  	let t2;
  	let t3;
  	let div1;
  	let div0;
  	let t4_value = transformSongLength(/*song*/ ctx[6]?.duration_ms) + "";
  	let t4;
  	let t5;
  	let a;
  	let i;
  	let a_href_value;
  	let t6;
  	let img;
  	let img_src_value;
  	let img_height_value;
  	let img_width_value;
  	let img_alt_value;
  	let t7;
  	let audio;
  	let source;
  	let source_src_value;
  	let t8;
  	let mounted;
  	let dispose;

  	function keydown_handler() {
  		return /*keydown_handler*/ ctx[3](/*song*/ ctx[6]);
  	}

  	function click_handler_1() {
  		return /*click_handler_1*/ ctx[4](/*song*/ ctx[6]);
  	}

  	const block = {
  		c: function create() {
  			section = main.element("section");
  			h3 = main.element("h3");
  			span0 = main.element("span");
  			t0 = main.text(t0_value);
  			t1 = main.text(" by\n      ");
  			span1 = main.element("span");
  			t2 = main.text(t2_value);
  			t3 = main.space();
  			div1 = main.element("div");
  			div0 = main.element("div");
  			t4 = main.text(t4_value);
  			t5 = main.space();
  			a = main.element("a");
  			i = main.element("i");
  			t6 = main.space();
  			img = main.element("img");
  			t7 = main.space();
  			audio = main.element("audio");
  			source = main.element("source");
  			t8 = main.space();
  			this.h();
  		},
  		l: function claim(nodes) {
  			section = main.claim_element(nodes, "SECTION", { role: true, tabindex: true, class: true });
  			var section_nodes = main.children(section);
  			h3 = main.claim_element(section_nodes, "H3", { class: true });
  			var h3_nodes = main.children(h3);
  			span0 = main.claim_element(h3_nodes, "SPAN", { class: true });
  			var span0_nodes = main.children(span0);
  			t0 = main.claim_text(span0_nodes, t0_value);
  			span0_nodes.forEach(main.detach_dev);
  			t1 = main.claim_text(h3_nodes, " by\n      ");
  			span1 = main.claim_element(h3_nodes, "SPAN", { class: true });
  			var span1_nodes = main.children(span1);
  			t2 = main.claim_text(span1_nodes, t2_value);
  			span1_nodes.forEach(main.detach_dev);
  			h3_nodes.forEach(main.detach_dev);
  			t3 = main.claim_space(section_nodes);
  			div1 = main.claim_element(section_nodes, "DIV", { class: true });
  			var div1_nodes = main.children(div1);
  			div0 = main.claim_element(div1_nodes, "DIV", { class: true });
  			var div0_nodes = main.children(div0);
  			t4 = main.claim_text(div0_nodes, t4_value);
  			div0_nodes.forEach(main.detach_dev);
  			t5 = main.claim_space(div1_nodes);
  			a = main.claim_element(div1_nodes, "A", { target: true, href: true, class: true });
  			var a_nodes = main.children(a);
  			i = main.claim_element(a_nodes, "I", { class: true });
  			main.children(i).forEach(main.detach_dev);
  			a_nodes.forEach(main.detach_dev);
  			div1_nodes.forEach(main.detach_dev);
  			t6 = main.claim_space(section_nodes);

  			img = main.claim_element(section_nodes, "IMG", {
  				src: true,
  				height: true,
  				width: true,
  				alt: true
  			});

  			t7 = main.claim_space(section_nodes);
  			audio = main.claim_element(section_nodes, "AUDIO", {});
  			var audio_nodes = main.children(audio);
  			source = main.claim_element(audio_nodes, "SOURCE", { src: true, type: true });
  			audio_nodes.forEach(main.detach_dev);
  			t8 = main.claim_space(section_nodes);
  			section_nodes.forEach(main.detach_dev);
  			this.h();
  		},
  		h: function hydrate() {
  			main.attr_dev(span0, "class", "svelte-1kyf0m7");
  			main.add_location(span0, file$6, 28, 6, 700);
  			main.attr_dev(span1, "class", "svelte-1kyf0m7");
  			main.add_location(span1, file$6, 29, 6, 735);
  			main.attr_dev(h3, "class", "svelte-1kyf0m7");
  			main.add_location(h3, file$6, 27, 4, 689);
  			main.attr_dev(div0, "class", "length");
  			main.add_location(div0, file$6, 33, 6, 815);
  			main.attr_dev(i, "class", "fab fa-spotify");
  			main.add_location(i, file$6, 37, 8, 993);
  			main.attr_dev(a, "target", "_blank");
  			main.attr_dev(a, "href", a_href_value = /*song*/ ctx[6]?.external_urls?.spotify);
  			main.attr_dev(a, "class", "svelte-1kyf0m7");
  			main.add_location(a, file$6, 36, 6, 904);
  			main.attr_dev(div1, "class", "info svelte-1kyf0m7");
  			main.add_location(div1, file$6, 32, 4, 790);
  			if (!main.src_url_equal(img.src, img_src_value = /*song*/ ctx[6].album?.images[1]?.url)) main.attr_dev(img, "src", img_src_value);
  			main.attr_dev(img, "height", img_height_value = /*song*/ ctx[6].album?.images[1]?.height);
  			main.attr_dev(img, "width", img_width_value = /*song*/ ctx[6].album?.images[1]?.height);
  			main.attr_dev(img, "alt", img_alt_value = `Album cover of ${/*song*/ ctx[6].name}`);
  			main.add_location(img, file$6, 41, 4, 1049);
  			if (!main.src_url_equal(source.src, source_src_value = /*song*/ ctx[6].preview_url)) main.attr_dev(source, "src", source_src_value);
  			main.attr_dev(source, "type", "audio/mpeg");
  			main.add_location(source, file$6, 48, 6, 1266);
  			audio.controls = "controls";
  			main.add_location(audio, file$6, 47, 4, 1232);
  			main.attr_dev(section, "role", "button");
  			main.attr_dev(section, "tabindex", "0");
  			main.attr_dev(section, "class", "svelte-1kyf0m7");
  			main.toggle_class(section, "show", /*song*/ ctx[6]);
  			main.add_location(section, file$6, 21, 2, 540);
  		},
  		m: function mount(target, anchor) {
  			main.insert_hydration_dev(target, section, anchor);
  			main.append_hydration_dev(section, h3);
  			main.append_hydration_dev(h3, span0);
  			main.append_hydration_dev(span0, t0);
  			main.append_hydration_dev(h3, t1);
  			main.append_hydration_dev(h3, span1);
  			main.append_hydration_dev(span1, t2);
  			main.append_hydration_dev(section, t3);
  			main.append_hydration_dev(section, div1);
  			main.append_hydration_dev(div1, div0);
  			main.append_hydration_dev(div0, t4);
  			main.append_hydration_dev(div1, t5);
  			main.append_hydration_dev(div1, a);
  			main.append_hydration_dev(a, i);
  			main.append_hydration_dev(section, t6);
  			main.append_hydration_dev(section, img);
  			main.append_hydration_dev(section, t7);
  			main.append_hydration_dev(section, audio);
  			main.append_hydration_dev(audio, source);
  			main.append_hydration_dev(section, t8);

  			if (!mounted) {
  				dispose = [
  					main.listen_dev(a, "click", main.stop_propagation(/*click_handler*/ ctx[2]), false, false, true),
  					main.listen_dev(section, "keydown", keydown_handler, false, false, false),
  					main.listen_dev(section, "click", click_handler_1, false, false, false)
  				];

  				mounted = true;
  			}
  		},
  		p: function update(new_ctx, dirty) {
  			ctx = new_ctx;
  			if (dirty & /*data*/ 1 && t0_value !== (t0_value = /*song*/ ctx[6]?.name + "")) main.set_data_dev(t0, t0_value);
  			if (dirty & /*data*/ 1 && t2_value !== (t2_value = helpers.getArtists(/*song*/ ctx[6].artists) + "")) main.set_data_dev(t2, t2_value);
  			if (dirty & /*data*/ 1 && t4_value !== (t4_value = transformSongLength(/*song*/ ctx[6]?.duration_ms) + "")) main.set_data_dev(t4, t4_value);

  			if (dirty & /*data*/ 1 && a_href_value !== (a_href_value = /*song*/ ctx[6]?.external_urls?.spotify)) {
  				main.attr_dev(a, "href", a_href_value);
  			}

  			if (dirty & /*data*/ 1 && !main.src_url_equal(img.src, img_src_value = /*song*/ ctx[6].album?.images[1]?.url)) {
  				main.attr_dev(img, "src", img_src_value);
  			}

  			if (dirty & /*data*/ 1 && img_height_value !== (img_height_value = /*song*/ ctx[6].album?.images[1]?.height)) {
  				main.attr_dev(img, "height", img_height_value);
  			}

  			if (dirty & /*data*/ 1 && img_width_value !== (img_width_value = /*song*/ ctx[6].album?.images[1]?.height)) {
  				main.attr_dev(img, "width", img_width_value);
  			}

  			if (dirty & /*data*/ 1 && img_alt_value !== (img_alt_value = `Album cover of ${/*song*/ ctx[6].name}`)) {
  				main.attr_dev(img, "alt", img_alt_value);
  			}

  			if (dirty & /*data*/ 1 && !main.src_url_equal(source.src, source_src_value = /*song*/ ctx[6].preview_url)) {
  				main.attr_dev(source, "src", source_src_value);
  			}

  			if (dirty & /*data*/ 1) {
  				main.toggle_class(section, "show", /*song*/ ctx[6]);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) main.detach_dev(section);
  			mounted = false;
  			main.run_all(dispose);
  		}
  	};

  	main.dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block$1.name,
  		type: "each",
  		source: "(21:0) {#each data as song}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$6(ctx) {
  	let each_1_anchor;
  	let each_value = /*data*/ ctx[0];
  	main.validate_each_argument(each_value);
  	let each_blocks = [];

  	for (let i = 0; i < each_value.length; i += 1) {
  		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
  	}

  	const block = {
  		c: function create() {
  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].c();
  			}

  			each_1_anchor = main.empty();
  		},
  		l: function claim(nodes) {
  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].l(nodes);
  			}

  			each_1_anchor = main.empty();
  		},
  		m: function mount(target, anchor) {
  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].m(target, anchor);
  			}

  			main.insert_hydration_dev(target, each_1_anchor, anchor);
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*data, returnData, transformSongLength, getArtists*/ 3) {
  				each_value = /*data*/ ctx[0];
  				main.validate_each_argument(each_value);
  				let i;

  				for (i = 0; i < each_value.length; i += 1) {
  					const child_ctx = get_each_context$1(ctx, each_value, i);

  					if (each_blocks[i]) {
  						each_blocks[i].p(child_ctx, dirty);
  					} else {
  						each_blocks[i] = create_each_block$1(child_ctx);
  						each_blocks[i].c();
  						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
  					}
  				}

  				for (; i < each_blocks.length; i += 1) {
  					each_blocks[i].d(1);
  				}

  				each_blocks.length = each_value.length;
  			}
  		},
  		i: main.noop,
  		o: main.noop,
  		d: function destroy(detaching) {
  			main.destroy_each(each_blocks, detaching);
  			if (detaching) main.detach_dev(each_1_anchor);
  		}
  	};

  	main.dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$6.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function transformSongLength(ms) {
  	const seconds = ms / 1000;
  	const minutes = seconds / 60;
  	const remainingSeconds = seconds % 60;
  	return `${minutes.toFixed(0)}:${remainingSeconds.toFixed(0) < 10 ? "0" : ""}${remainingSeconds.toFixed(0)}`;
  }

  function instance$6($$self, $$props, $$invalidate) {
  	let { $$slots: slots = {}, $$scope } = $$props;
  	main.validate_slots('SpotifyResponse', slots, []);
  	let { data } = $$props;
  	const dispatch = main.createEventDispatcher();
  	const returnData = song => dispatch("song", song);
  	const writable_props = ['data'];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SpotifyResponse> was created with unknown prop '${key}'`);
  	});

  	function click_handler(event) {
  		main.bubble.call(this, $$self, event);
  	}

  	const keydown_handler = song => returnData(song);
  	const click_handler_1 = song => returnData(song);

  	$$self.$$set = $$props => {
  		if ('data' in $$props) $$invalidate(0, data = $$props.data);
  	};

  	$$self.$capture_state = () => ({
  		createEventDispatcher: main.createEventDispatcher,
  		getArtists: helpers.getArtists,
  		data,
  		transformSongLength,
  		dispatch,
  		returnData
  	});

  	$$self.$inject_state = $$props => {
  		if ('data' in $$props) $$invalidate(0, data = $$props.data);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [data, returnData, click_handler, keydown_handler, click_handler_1];
  }

  class SpotifyResponse extends main.SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		main.init(this, options, instance$6, create_fragment$6, main.safe_not_equal, { data: 0 });

  		main.dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "SpotifyResponse",
  			options,
  			id: create_fragment$6.name
  		});

  		const { ctx } = this.$$;
  		const props = options.props || {};

  		if (/*data*/ ctx[0] === undefined && !('data' in props)) {
  			console.warn("<SpotifyResponse> was created without expected prop 'data'");
  		}
  	}

  	get data() {
  		throw new Error("<SpotifyResponse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set data(value) {
  		throw new Error("<SpotifyResponse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* src/components/Input.svelte generated by Svelte v3.47.0 */
  const file$5 = "src/components/Input.svelte";

  // (16:2) {#if error}
  function create_if_block$2(ctx) {
  	let div;
  	let t;

  	const block = {
  		c: function create() {
  			div = main.element("div");
  			t = main.text(/*error*/ ctx[2]);
  			this.h();
  		},
  		l: function claim(nodes) {
  			div = main.claim_element(nodes, "DIV", { class: true });
  			var div_nodes = main.children(div);
  			t = main.claim_text(div_nodes, /*error*/ ctx[2]);
  			div_nodes.forEach(main.detach_dev);
  			this.h();
  		},
  		h: function hydrate() {
  			main.attr_dev(div, "class", "error svelte-1nsq3fe");
  			main.add_location(div, file$5, 16, 4, 378);
  		},
  		m: function mount(target, anchor) {
  			main.insert_hydration_dev(target, div, anchor);
  			main.append_hydration_dev(div, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*error*/ 4) main.set_data_dev(t, /*error*/ ctx[2]);
  		},
  		d: function destroy(detaching) {
  			if (detaching) main.detach_dev(div);
  		}
  	};

  	main.dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$2.name,
  		type: "if",
  		source: "(16:2) {#if error}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$5(ctx) {
  	let div;
  	let input;
  	let t0;
  	let label_1;
  	let t1;
  	let t2;
  	let mounted;
  	let dispose;
  	let if_block = /*error*/ ctx[2] && create_if_block$2(ctx);

  	const block = {
  		c: function create() {
  			div = main.element("div");
  			input = main.element("input");
  			t0 = main.space();
  			label_1 = main.element("label");
  			t1 = main.text(/*label*/ ctx[1]);
  			t2 = main.space();
  			if (if_block) if_block.c();
  			this.h();
  		},
  		l: function claim(nodes) {
  			div = main.claim_element(nodes, "DIV", { class: true });
  			var div_nodes = main.children(div);
  			input = main.claim_element(div_nodes, "INPUT", { id: true, class: true });
  			t0 = main.claim_space(div_nodes);
  			label_1 = main.claim_element(div_nodes, "LABEL", { for: true, class: true });
  			var label_1_nodes = main.children(label_1);
  			t1 = main.claim_text(label_1_nodes, /*label*/ ctx[1]);
  			label_1_nodes.forEach(main.detach_dev);
  			t2 = main.claim_space(div_nodes);
  			if (if_block) if_block.l(div_nodes);
  			div_nodes.forEach(main.detach_dev);
  			this.h();
  		},
  		h: function hydrate() {
  			main.attr_dev(input, "id", /*inputID*/ ctx[4]);
  			main.attr_dev(input, "class", "svelte-1nsq3fe");
  			main.add_location(input, file$5, 12, 2, 240);
  			main.attr_dev(label_1, "for", /*inputID*/ ctx[4]);
  			main.attr_dev(label_1, "class", "svelte-1nsq3fe");
  			main.toggle_class(label_1, "flying-label", /*value*/ ctx[0]);
  			main.add_location(label_1, file$5, 13, 2, 295);
  			main.attr_dev(div, "class", "input-container svelte-1nsq3fe");
  			main.add_location(div, file$5, 11, 0, 208);
  		},
  		m: function mount(target, anchor) {
  			main.insert_hydration_dev(target, div, anchor);
  			main.append_hydration_dev(div, input);
  			main.set_input_value(input, /*value*/ ctx[0]);
  			main.append_hydration_dev(div, t0);
  			main.append_hydration_dev(div, label_1);
  			main.append_hydration_dev(label_1, t1);
  			main.append_hydration_dev(div, t2);
  			if (if_block) if_block.m(div, null);

  			if (!mounted) {
  				dispose = [
  					main.listen_dev(
  						input,
  						"input",
  						function () {
  							if (main.is_function(/*onInput*/ ctx[3])) /*onInput*/ ctx[3].apply(this, arguments);
  						},
  						false,
  						false,
  						false
  					),
  					main.listen_dev(input, "input", /*input_input_handler*/ ctx[5])
  				];

  				mounted = true;
  			}
  		},
  		p: function update(new_ctx, [dirty]) {
  			ctx = new_ctx;

  			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
  				main.set_input_value(input, /*value*/ ctx[0]);
  			}

  			if (dirty & /*label*/ 2) main.set_data_dev(t1, /*label*/ ctx[1]);

  			if (dirty & /*value*/ 1) {
  				main.toggle_class(label_1, "flying-label", /*value*/ ctx[0]);
  			}

  			if (/*error*/ ctx[2]) {
  				if (if_block) {
  					if_block.p(ctx, dirty);
  				} else {
  					if_block = create_if_block$2(ctx);
  					if_block.c();
  					if_block.m(div, null);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}
  		},
  		i: main.noop,
  		o: main.noop,
  		d: function destroy(detaching) {
  			if (detaching) main.detach_dev(div);
  			if (if_block) if_block.d();
  			mounted = false;
  			main.run_all(dispose);
  		}
  	};

  	main.dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$5.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$5($$self, $$props, $$invalidate) {
  	let { $$slots: slots = {}, $$scope } = $$props;
  	main.validate_slots('Input', slots, []);
  	let { value } = $$props;
  	let { label } = $$props;
  	let { error = null } = $$props;
  	let { onInput = null } = $$props;
  	let inputID = `${label}-${helpers.createID()}`;
  	const writable_props = ['value', 'label', 'error', 'onInput'];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Input> was created with unknown prop '${key}'`);
  	});

  	function input_input_handler() {
  		value = this.value;
  		$$invalidate(0, value);
  	}

  	$$self.$$set = $$props => {
  		if ('value' in $$props) $$invalidate(0, value = $$props.value);
  		if ('label' in $$props) $$invalidate(1, label = $$props.label);
  		if ('error' in $$props) $$invalidate(2, error = $$props.error);
  		if ('onInput' in $$props) $$invalidate(3, onInput = $$props.onInput);
  	};

  	$$self.$capture_state = () => ({
  		createID: helpers.createID,
  		value,
  		label,
  		error,
  		onInput,
  		inputID
  	});

  	$$self.$inject_state = $$props => {
  		if ('value' in $$props) $$invalidate(0, value = $$props.value);
  		if ('label' in $$props) $$invalidate(1, label = $$props.label);
  		if ('error' in $$props) $$invalidate(2, error = $$props.error);
  		if ('onInput' in $$props) $$invalidate(3, onInput = $$props.onInput);
  		if ('inputID' in $$props) $$invalidate(4, inputID = $$props.inputID);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [value, label, error, onInput, inputID, input_input_handler];
  }

  class Input extends main.SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		main.init(this, options, instance$5, create_fragment$5, main.safe_not_equal, { value: 0, label: 1, error: 2, onInput: 3 });

  		main.dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Input",
  			options,
  			id: create_fragment$5.name
  		});

  		const { ctx } = this.$$;
  		const props = options.props || {};

  		if (/*value*/ ctx[0] === undefined && !('value' in props)) {
  			console.warn("<Input> was created without expected prop 'value'");
  		}

  		if (/*label*/ ctx[1] === undefined && !('label' in props)) {
  			console.warn("<Input> was created without expected prop 'label'");
  		}
  	}

  	get value() {
  		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set value(value) {
  		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get label() {
  		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set label(value) {
  		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get error() {
  		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set error(value) {
  		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get onInput() {
  		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set onInput(value) {
  		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* src/components/Loading.svelte generated by Svelte v3.47.0 */

  const file$4 = "src/components/Loading.svelte";

  function create_fragment$4(ctx) {
  	let div;
  	let span;
  	let t0;
  	let t1;
  	let i;

  	const block = {
  		c: function create() {
  			div = main.element("div");
  			span = main.element("span");
  			t0 = main.text(/*text*/ ctx[0]);
  			t1 = main.space();
  			i = main.element("i");
  			this.h();
  		},
  		l: function claim(nodes) {
  			div = main.claim_element(nodes, "DIV", { class: true });
  			var div_nodes = main.children(div);
  			span = main.claim_element(div_nodes, "SPAN", {});
  			var span_nodes = main.children(span);
  			t0 = main.claim_text(span_nodes, /*text*/ ctx[0]);
  			span_nodes.forEach(main.detach_dev);
  			t1 = main.claim_space(div_nodes);
  			i = main.claim_element(div_nodes, "I", { class: true });
  			main.children(i).forEach(main.detach_dev);
  			div_nodes.forEach(main.detach_dev);
  			this.h();
  		},
  		h: function hydrate() {
  			main.add_location(span, file$4, 5, 2, 78);
  			main.attr_dev(i, "class", "fa fa-spinner fa-spin");
  			main.add_location(i, file$4, 5, 22, 98);
  			main.attr_dev(div, "class", "loading svelte-fp2n7");
  			main.add_location(div, file$4, 4, 0, 54);
  		},
  		m: function mount(target, anchor) {
  			main.insert_hydration_dev(target, div, anchor);
  			main.append_hydration_dev(div, span);
  			main.append_hydration_dev(span, t0);
  			main.append_hydration_dev(div, t1);
  			main.append_hydration_dev(div, i);
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*text*/ 1) main.set_data_dev(t0, /*text*/ ctx[0]);
  		},
  		i: main.noop,
  		o: main.noop,
  		d: function destroy(detaching) {
  			if (detaching) main.detach_dev(div);
  		}
  	};

  	main.dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$4.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$4($$self, $$props, $$invalidate) {
  	let { $$slots: slots = {}, $$scope } = $$props;
  	main.validate_slots('Loading', slots, []);
  	let { text = "Loading..." } = $$props;
  	const writable_props = ['text'];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Loading> was created with unknown prop '${key}'`);
  	});

  	$$self.$$set = $$props => {
  		if ('text' in $$props) $$invalidate(0, text = $$props.text);
  	};

  	$$self.$capture_state = () => ({ text });

  	$$self.$inject_state = $$props => {
  		if ('text' in $$props) $$invalidate(0, text = $$props.text);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [text];
  }

  class Loading extends main.SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		main.init(this, options, instance$4, create_fragment$4, main.safe_not_equal, { text: 0 });

  		main.dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Loading",
  			options,
  			id: create_fragment$4.name
  		});
  	}

  	get text() {
  		throw new Error("<Loading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set text(value) {
  		throw new Error("<Loading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* src/components/Error.svelte generated by Svelte v3.47.0 */

  const { Error: Error_1$2, console: console_1$1 } = main.globals;
  const file$3 = "src/components/Error.svelte";

  function create_fragment$3(ctx) {
  	let div;
  	let t;

  	const block = {
  		c: function create() {
  			div = main.element("div");
  			t = main.text(/*errorMessage*/ ctx[0]);
  			this.h();
  		},
  		l: function claim(nodes) {
  			div = main.claim_element(nodes, "DIV", { class: true });
  			var div_nodes = main.children(div);
  			t = main.claim_text(div_nodes, /*errorMessage*/ ctx[0]);
  			div_nodes.forEach(main.detach_dev);
  			this.h();
  		},
  		h: function hydrate() {
  			main.attr_dev(div, "class", "svelte-3sgp1q");
  			main.toggle_class(div, "show", /*error*/ ctx[1]);
  			main.add_location(div, file$3, 7, 0, 152);
  		},
  		m: function mount(target, anchor) {
  			main.insert_hydration_dev(target, div, anchor);
  			main.append_hydration_dev(div, t);
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*errorMessage*/ 1) main.set_data_dev(t, /*errorMessage*/ ctx[0]);

  			if (dirty & /*error*/ 2) {
  				main.toggle_class(div, "show", /*error*/ ctx[1]);
  			}
  		},
  		i: main.noop,
  		o: main.noop,
  		d: function destroy(detaching) {
  			if (detaching) main.detach_dev(div);
  		}
  	};

  	main.dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$3.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$3($$self, $$props, $$invalidate) {
  	let { $$slots: slots = {}, $$scope } = $$props;
  	main.validate_slots('Error', slots, []);
  	let { errorMessage = "Sorry, something went wrong ðŸ˜”" } = $$props;
  	let { error = null } = $$props;
  	const writable_props = ['errorMessage', 'error'];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<Error> was created with unknown prop '${key}'`);
  	});

  	$$self.$$set = $$props => {
  		if ('errorMessage' in $$props) $$invalidate(0, errorMessage = $$props.errorMessage);
  		if ('error' in $$props) $$invalidate(1, error = $$props.error);
  	};

  	$$self.$capture_state = () => ({ errorMessage, error });

  	$$self.$inject_state = $$props => {
  		if ('errorMessage' in $$props) $$invalidate(0, errorMessage = $$props.errorMessage);
  		if ('error' in $$props) $$invalidate(1, error = $$props.error);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty & /*error*/ 2) {
  			error ? console.error(error) : null;
  		}
  	};

  	return [errorMessage, error];
  }

  class Error$1 extends main.SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		main.init(this, options, instance$3, create_fragment$3, main.safe_not_equal, { errorMessage: 0, error: 1 });

  		main.dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Error",
  			options,
  			id: create_fragment$3.name
  		});
  	}

  	get errorMessage() {
  		throw new Error_1$2("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set errorMessage(value) {
  		throw new Error_1$2("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get error() {
  		throw new Error_1$2("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set error(value) {
  		throw new Error_1$2("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* src/pages/NewLesson/SpotifySearch.svelte generated by Svelte v3.47.0 */

  const { Error: Error_1$1 } = main.globals;
  const file$2 = "src/pages/NewLesson/SpotifySearch.svelte";

  // (51:2) {#if loading}
  function create_if_block_1(ctx) {
  	let loading_1;
  	let current;

  	loading_1 = new Loading({
  			props: { text: "Searching Spotify..." },
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			main.create_component(loading_1.$$.fragment);
  		},
  		l: function claim(nodes) {
  			main.claim_component(loading_1.$$.fragment, nodes);
  		},
  		m: function mount(target, anchor) {
  			main.mount_component(loading_1, target, anchor);
  			current = true;
  		},
  		i: function intro(local) {
  			if (current) return;
  			main.transition_in(loading_1.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			main.transition_out(loading_1.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			main.destroy_component(loading_1, detaching);
  		}
  	};

  	main.dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1.name,
  		type: "if",
  		source: "(51:2) {#if loading}",
  		ctx
  	});

  	return block;
  }

  // (57:2) {#if spotifyResponse}
  function create_if_block$1(ctx) {
  	let div;
  	let spotifyresponse;
  	let current;

  	spotifyresponse = new SpotifyResponse({
  			props: { data: /*spotifyResponse*/ ctx[3] },
  			$$inline: true
  		});

  	spotifyresponse.$on("song", /*song_handler*/ ctx[6]);

  	const block = {
  		c: function create() {
  			div = main.element("div");
  			main.create_component(spotifyresponse.$$.fragment);
  			this.h();
  		},
  		l: function claim(nodes) {
  			div = main.claim_element(nodes, "DIV", { class: true });
  			var div_nodes = main.children(div);
  			main.claim_component(spotifyresponse.$$.fragment, div_nodes);
  			div_nodes.forEach(main.detach_dev);
  			this.h();
  		},
  		h: function hydrate() {
  			main.attr_dev(div, "class", "search-results svelte-1pkvtmg");
  			main.add_location(div, file$2, 57, 4, 1499);
  		},
  		m: function mount(target, anchor) {
  			main.insert_hydration_dev(target, div, anchor);
  			main.mount_component(spotifyresponse, div, null);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const spotifyresponse_changes = {};
  			if (dirty & /*spotifyResponse*/ 8) spotifyresponse_changes.data = /*spotifyResponse*/ ctx[3];
  			spotifyresponse.$set(spotifyresponse_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			main.transition_in(spotifyresponse.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			main.transition_out(spotifyresponse.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) main.detach_dev(div);
  			main.destroy_component(spotifyresponse);
  		}
  	};

  	main.dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$1.name,
  		type: "if",
  		source: "(57:2) {#if spotifyResponse}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$2(ctx) {
  	let input;
  	let updating_value;
  	let t0;
  	let div;
  	let t1;
  	let error_1;
  	let t2;
  	let current;

  	function input_value_binding(value) {
  		/*input_value_binding*/ ctx[5](value);
  	}

  	let input_props = {
  		label: "Song",
  		onInput: helpers.debounce(/*searchSpotify*/ ctx[4])
  	};

  	if (/*songName*/ ctx[0] !== void 0) {
  		input_props.value = /*songName*/ ctx[0];
  	}

  	input = new Input({ props: input_props, $$inline: true });
  	main.binding_callbacks.push(() => main.bind(input, 'value', input_value_binding));
  	let if_block0 = /*loading*/ ctx[1] && create_if_block_1(ctx);

  	error_1 = new Error$1({
  			props: { error: /*error*/ ctx[2] },
  			$$inline: true
  		});

  	let if_block1 = /*spotifyResponse*/ ctx[3] && create_if_block$1(ctx);

  	const block = {
  		c: function create() {
  			main.create_component(input.$$.fragment);
  			t0 = main.space();
  			div = main.element("div");
  			if (if_block0) if_block0.c();
  			t1 = main.space();
  			main.create_component(error_1.$$.fragment);
  			t2 = main.space();
  			if (if_block1) if_block1.c();
  			this.h();
  		},
  		l: function claim(nodes) {
  			main.claim_component(input.$$.fragment, nodes);
  			t0 = main.claim_space(nodes);
  			div = main.claim_element(nodes, "DIV", {});
  			var div_nodes = main.children(div);
  			if (if_block0) if_block0.l(div_nodes);
  			t1 = main.claim_space(div_nodes);
  			main.claim_component(error_1.$$.fragment, div_nodes);
  			t2 = main.claim_space(div_nodes);
  			if (if_block1) if_block1.l(div_nodes);
  			div_nodes.forEach(main.detach_dev);
  			this.h();
  		},
  		h: function hydrate() {
  			main.add_location(div, file$2, 49, 0, 1375);
  		},
  		m: function mount(target, anchor) {
  			main.mount_component(input, target, anchor);
  			main.insert_hydration_dev(target, t0, anchor);
  			main.insert_hydration_dev(target, div, anchor);
  			if (if_block0) if_block0.m(div, null);
  			main.append_hydration_dev(div, t1);
  			main.mount_component(error_1, div, null);
  			main.append_hydration_dev(div, t2);
  			if (if_block1) if_block1.m(div, null);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			const input_changes = {};

  			if (!updating_value && dirty & /*songName*/ 1) {
  				updating_value = true;
  				input_changes.value = /*songName*/ ctx[0];
  				main.add_flush_callback(() => updating_value = false);
  			}

  			input.$set(input_changes);

  			if (/*loading*/ ctx[1]) {
  				if (if_block0) {
  					if (dirty & /*loading*/ 2) {
  						main.transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_1(ctx);
  					if_block0.c();
  					main.transition_in(if_block0, 1);
  					if_block0.m(div, t1);
  				}
  			} else if (if_block0) {
  				main.group_outros();

  				main.transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				main.check_outros();
  			}

  			const error_1_changes = {};
  			if (dirty & /*error*/ 4) error_1_changes.error = /*error*/ ctx[2];
  			error_1.$set(error_1_changes);

  			if (/*spotifyResponse*/ ctx[3]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty & /*spotifyResponse*/ 8) {
  						main.transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block$1(ctx);
  					if_block1.c();
  					main.transition_in(if_block1, 1);
  					if_block1.m(div, null);
  				}
  			} else if (if_block1) {
  				main.group_outros();

  				main.transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				main.check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			main.transition_in(input.$$.fragment, local);
  			main.transition_in(if_block0);
  			main.transition_in(error_1.$$.fragment, local);
  			main.transition_in(if_block1);
  			current = true;
  		},
  		o: function outro(local) {
  			main.transition_out(input.$$.fragment, local);
  			main.transition_out(if_block0);
  			main.transition_out(error_1.$$.fragment, local);
  			main.transition_out(if_block1);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			main.destroy_component(input, detaching);
  			if (detaching) main.detach_dev(t0);
  			if (detaching) main.detach_dev(div);
  			if (if_block0) if_block0.d();
  			main.destroy_component(error_1);
  			if (if_block1) if_block1.d();
  		}
  	};

  	main.dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$2.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$2($$self, $$props, $$invalidate) {
  	let $spotifyToken;
  	main.validate_store(main.spotifyToken, 'spotifyToken');
  	main.component_subscribe($$self, main.spotifyToken, $$value => $$invalidate(7, $spotifyToken = $$value));
  	let { $$slots: slots = {}, $$scope } = $$props;
  	main.validate_slots('SpotifySearch', slots, []);
  	let { songName = "" } = $$props;
  	let loading = false;
  	let error = null;
  	let spotifyResponse = null;

  	async function searchSpotify() {
  		if ($spotifyToken && songName.length > 1) {
  			$$invalidate(2, error = null);
  			$$invalidate(1, loading = true);

  			try {
  				const { data } = await helpers.axios("https://api.spotify.com/v1/search", {
  					headers: {
  						Authorization: `Authorization: Bearer ${$spotifyToken}`
  					},
  					params: { q: songName, type: "track", limit: 5 }
  				});

  				$$invalidate(3, spotifyResponse = data?.tracks?.items);
  			} catch(err) {
  				$$invalidate(2, error = err);
  			} finally {
  				$$invalidate(1, loading = false);
  			}
  		}
  	}

  	main.onMount(() => {
  		(async function init() {
  			if (!$spotifyToken) {
  				const credentials = await helpers.authenticateSpotify();
  				main.spotifyToken.set(credentials?.data?.access_token);
  			}
  		})();
  	});

  	const writable_props = ['songName'];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SpotifySearch> was created with unknown prop '${key}'`);
  	});

  	function input_value_binding(value) {
  		songName = value;
  		$$invalidate(0, songName);
  	}

  	function song_handler(event) {
  		main.bubble.call(this, $$self, event);
  	}

  	$$self.$$set = $$props => {
  		if ('songName' in $$props) $$invalidate(0, songName = $$props.songName);
  	};

  	$$self.$capture_state = () => ({
  		onMount: main.onMount,
  		axios: helpers.axios,
  		SpotifyResponse,
  		Input,
  		Loading,
  		Error: Error$1,
  		spotifyToken: main.spotifyToken,
  		authenticateSpotify: helpers.authenticateSpotify,
  		debounce: helpers.debounce,
  		songName,
  		loading,
  		error,
  		spotifyResponse,
  		searchSpotify,
  		$spotifyToken
  	});

  	$$self.$inject_state = $$props => {
  		if ('songName' in $$props) $$invalidate(0, songName = $$props.songName);
  		if ('loading' in $$props) $$invalidate(1, loading = $$props.loading);
  		if ('error' in $$props) $$invalidate(2, error = $$props.error);
  		if ('spotifyResponse' in $$props) $$invalidate(3, spotifyResponse = $$props.spotifyResponse);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [
  		songName,
  		loading,
  		error,
  		spotifyResponse,
  		searchSpotify,
  		input_value_binding,
  		song_handler
  	];
  }

  class SpotifySearch extends main.SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		main.init(this, options, instance$2, create_fragment$2, main.safe_not_equal, { songName: 0 });

  		main.dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "SpotifySearch",
  			options,
  			id: create_fragment$2.name
  		});
  	}

  	get songName() {
  		throw new Error_1$1("<SpotifySearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set songName(value) {
  		throw new Error_1$1("<SpotifySearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* src/pages/NewLesson/YoutubeSearch.svelte generated by Svelte v3.47.0 */

  const { Error: Error_1 } = main.globals;
  const file$1 = "src/pages/NewLesson/YoutubeSearch.svelte";

  function get_each_context(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[11] = list[i];
  	return child_ctx;
  }

  // (58:2) {#each searchResult as video}
  function create_each_block(ctx) {
  	let li;
  	let videosnippet;
  	let t;
  	let li_title_value;
  	let current;
  	let mounted;
  	let dispose;

  	videosnippet = new VideoSnippet.VideoSnippet({
  			props: { snippet: /*video*/ ctx[11].snippet },
  			$$inline: true
  		});

  	function click_handler() {
  		return /*click_handler*/ ctx[9](/*video*/ ctx[11]);
  	}

  	const block = {
  		c: function create() {
  			li = main.element("li");
  			main.create_component(videosnippet.$$.fragment);
  			t = main.space();
  			this.h();
  		},
  		l: function claim(nodes) {
  			li = main.claim_element(nodes, "LI", { title: true, class: true, role: true });
  			var li_nodes = main.children(li);
  			main.claim_component(videosnippet.$$.fragment, li_nodes);
  			t = main.claim_space(li_nodes);
  			li_nodes.forEach(main.detach_dev);
  			this.h();
  		},
  		h: function hydrate() {
  			main.attr_dev(li, "title", li_title_value = `Click to ${/*findID*/ ctx[3](/*video*/ ctx[11].id.videoId)
			? "un"
			: ""}select`);

  			main.attr_dev(li, "class", "empty-button svelte-krholc");
  			main.attr_dev(li, "role", "button");
  			main.toggle_class(li, "selected", /*findID*/ ctx[3](/*video*/ ctx[11].id.videoId));
  			main.add_location(li, file$1, 58, 4, 1591);
  		},
  		m: function mount(target, anchor) {
  			main.insert_hydration_dev(target, li, anchor);
  			main.mount_component(videosnippet, li, null);
  			main.append_hydration_dev(li, t);
  			current = true;

  			if (!mounted) {
  				dispose = main.listen_dev(li, "click", click_handler, false, false, false);
  				mounted = true;
  			}
  		},
  		p: function update(new_ctx, dirty) {
  			ctx = new_ctx;
  			const videosnippet_changes = {};
  			if (dirty & /*searchResult*/ 2) videosnippet_changes.snippet = /*video*/ ctx[11].snippet;
  			videosnippet.$set(videosnippet_changes);

  			if (!current || dirty & /*findID, searchResult*/ 10 && li_title_value !== (li_title_value = `Click to ${/*findID*/ ctx[3](/*video*/ ctx[11].id.videoId)
			? "un"
			: ""}select`)) {
  				main.attr_dev(li, "title", li_title_value);
  			}

  			if (dirty & /*findID, searchResult*/ 10) {
  				main.toggle_class(li, "selected", /*findID*/ ctx[3](/*video*/ ctx[11].id.videoId));
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			main.transition_in(videosnippet.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			main.transition_out(videosnippet.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) main.detach_dev(li);
  			main.destroy_component(videosnippet);
  			mounted = false;
  			dispose();
  		}
  	};

  	main.dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block.name,
  		type: "each",
  		source: "(58:2) {#each searchResult as video}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$1(ctx) {
  	let input;
  	let updating_value;
  	let t0;
  	let error;
  	let t1;
  	let ul;
  	let current;

  	function input_value_binding(value) {
  		/*input_value_binding*/ ctx[8](value);
  	}

  	let input_props = {
  		label: "Search Youtube",
  		onInput: /*debouncedSearch*/ ctx[5]
  	};

  	if (/*videoSearch*/ ctx[0] !== void 0) {
  		input_props.value = /*videoSearch*/ ctx[0];
  	}

  	input = new Input({ props: input_props, $$inline: true });
  	main.binding_callbacks.push(() => main.bind(input, 'value', input_value_binding));

  	error = new Error$1({
  			props: { error: /*videoError*/ ctx[2] },
  			$$inline: true
  		});

  	let each_value = /*searchResult*/ ctx[1];
  	main.validate_each_argument(each_value);
  	let each_blocks = [];

  	for (let i = 0; i < each_value.length; i += 1) {
  		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  	}

  	const out = i => main.transition_out(each_blocks[i], 1, 1, () => {
  		each_blocks[i] = null;
  	});

  	const block = {
  		c: function create() {
  			main.create_component(input.$$.fragment);
  			t0 = main.space();
  			main.create_component(error.$$.fragment);
  			t1 = main.space();
  			ul = main.element("ul");

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].c();
  			}

  			this.h();
  		},
  		l: function claim(nodes) {
  			main.claim_component(input.$$.fragment, nodes);
  			t0 = main.claim_space(nodes);
  			main.claim_component(error.$$.fragment, nodes);
  			t1 = main.claim_space(nodes);
  			ul = main.claim_element(nodes, "UL", { class: true });
  			var ul_nodes = main.children(ul);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].l(ul_nodes);
  			}

  			ul_nodes.forEach(main.detach_dev);
  			this.h();
  		},
  		h: function hydrate() {
  			main.attr_dev(ul, "class", "search-result svelte-krholc");
  			main.toggle_class(ul, "show", /*searchResult*/ ctx[1]);
  			main.add_location(ul, file$1, 56, 0, 1502);
  		},
  		m: function mount(target, anchor) {
  			main.mount_component(input, target, anchor);
  			main.insert_hydration_dev(target, t0, anchor);
  			main.mount_component(error, target, anchor);
  			main.insert_hydration_dev(target, t1, anchor);
  			main.insert_hydration_dev(target, ul, anchor);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].m(ul, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			const input_changes = {};

  			if (!updating_value && dirty & /*videoSearch*/ 1) {
  				updating_value = true;
  				input_changes.value = /*videoSearch*/ ctx[0];
  				main.add_flush_callback(() => updating_value = false);
  			}

  			input.$set(input_changes);
  			const error_changes = {};
  			if (dirty & /*videoError*/ 4) error_changes.error = /*videoError*/ ctx[2];
  			error.$set(error_changes);

  			if (dirty & /*findID, searchResult, handleClick*/ 26) {
  				each_value = /*searchResult*/ ctx[1];
  				main.validate_each_argument(each_value);
  				let i;

  				for (i = 0; i < each_value.length; i += 1) {
  					const child_ctx = get_each_context(ctx, each_value, i);

  					if (each_blocks[i]) {
  						each_blocks[i].p(child_ctx, dirty);
  						main.transition_in(each_blocks[i], 1);
  					} else {
  						each_blocks[i] = create_each_block(child_ctx);
  						each_blocks[i].c();
  						main.transition_in(each_blocks[i], 1);
  						each_blocks[i].m(ul, null);
  					}
  				}

  				main.group_outros();

  				for (i = each_value.length; i < each_blocks.length; i += 1) {
  					out(i);
  				}

  				main.check_outros();
  			}

  			if (dirty & /*searchResult*/ 2) {
  				main.toggle_class(ul, "show", /*searchResult*/ ctx[1]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			main.transition_in(input.$$.fragment, local);
  			main.transition_in(error.$$.fragment, local);

  			for (let i = 0; i < each_value.length; i += 1) {
  				main.transition_in(each_blocks[i]);
  			}

  			current = true;
  		},
  		o: function outro(local) {
  			main.transition_out(input.$$.fragment, local);
  			main.transition_out(error.$$.fragment, local);
  			each_blocks = each_blocks.filter(Boolean);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				main.transition_out(each_blocks[i]);
  			}

  			current = false;
  		},
  		d: function destroy(detaching) {
  			main.destroy_component(input, detaching);
  			if (detaching) main.detach_dev(t0);
  			main.destroy_component(error, detaching);
  			if (detaching) main.detach_dev(t1);
  			if (detaching) main.detach_dev(ul);
  			main.destroy_each(each_blocks, detaching);
  		}
  	};

  	main.dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$1.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$1($$self, $$props, $$invalidate) {
  	let findID;
  	let { $$slots: slots = {}, $$scope } = $$props;
  	main.validate_slots('YoutubeSearch', slots, []);
  	let { videos } = $$props;
  	let { videoSearch } = $$props;
  	let { startSearch = false } = $$props;
  	let searchResult = [];
  	let videoError;

  	async function searchYoutube() {
  		if (videoSearch?.length > 2) {
  			try {
  				const res = await helpers.apiCall("https://www.googleapis.com/youtube/v3/search", {
  					q: videoSearch,
  					type: "video",
  					key: "AIzaSyAViHdvitELO2-jct4oVozhk8Wq3hCkjRk",
  					part: "snippet",
  					maxResults: 7,
  					topicId: "/m/04rlf"
  				});

  				$$invalidate(1, searchResult = res.items);
  				$$invalidate(2, videoError = null);
  				$$invalidate(7, startSearch = false);
  			} catch(error) {
  				$$invalidate(2, videoError = error);
  			}
  		}
  	}

  	function handleClick(video) {
  		if (videos.length > 0) {
  			const alreadyIn = findID(video.id.videoId);

  			if (alreadyIn) {
  				$$invalidate(6, videos = videos.filter(vid => vid != alreadyIn));
  			} else {
  				$$invalidate(6, videos = [...videos, video.id.videoId]);
  			}
  		} else {
  			$$invalidate(6, videos = [video.id.videoId]);
  		}
  	}

  	const debouncedSearch = helpers.debounce(searchYoutube);
  	const writable_props = ['videos', 'videoSearch', 'startSearch'];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<YoutubeSearch> was created with unknown prop '${key}'`);
  	});

  	function input_value_binding(value) {
  		videoSearch = value;
  		$$invalidate(0, videoSearch);
  	}

  	const click_handler = video => handleClick(video);

  	$$self.$$set = $$props => {
  		if ('videos' in $$props) $$invalidate(6, videos = $$props.videos);
  		if ('videoSearch' in $$props) $$invalidate(0, videoSearch = $$props.videoSearch);
  		if ('startSearch' in $$props) $$invalidate(7, startSearch = $$props.startSearch);
  	};

  	$$self.$capture_state = () => ({
  		VideoSnippet: VideoSnippet.VideoSnippet,
  		Input,
  		Error: Error$1,
  		debounce: helpers.debounce,
  		apiCall: helpers.apiCall,
  		videos,
  		videoSearch,
  		startSearch,
  		searchResult,
  		videoError,
  		searchYoutube,
  		handleClick,
  		debouncedSearch,
  		findID
  	});

  	$$self.$inject_state = $$props => {
  		if ('videos' in $$props) $$invalidate(6, videos = $$props.videos);
  		if ('videoSearch' in $$props) $$invalidate(0, videoSearch = $$props.videoSearch);
  		if ('startSearch' in $$props) $$invalidate(7, startSearch = $$props.startSearch);
  		if ('searchResult' in $$props) $$invalidate(1, searchResult = $$props.searchResult);
  		if ('videoError' in $$props) $$invalidate(2, videoError = $$props.videoError);
  		if ('findID' in $$props) $$invalidate(3, findID = $$props.findID);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty & /*videos*/ 64) {
  			$$invalidate(3, findID = id => videos?.find(videoID => id == videoID));
  		}

  		if ($$self.$$.dirty & /*startSearch*/ 128) {
  			startSearch ? searchYoutube() : null;
  		}
  	};

  	return [
  		videoSearch,
  		searchResult,
  		videoError,
  		findID,
  		handleClick,
  		debouncedSearch,
  		videos,
  		startSearch,
  		input_value_binding,
  		click_handler
  	];
  }

  class YoutubeSearch extends main.SvelteComponentDev {
  	constructor(options) {
  		super(options);

  		main.init(this, options, instance$1, create_fragment$1, main.safe_not_equal, {
  			videos: 6,
  			videoSearch: 0,
  			startSearch: 7
  		});

  		main.dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "YoutubeSearch",
  			options,
  			id: create_fragment$1.name
  		});

  		const { ctx } = this.$$;
  		const props = options.props || {};

  		if (/*videos*/ ctx[6] === undefined && !('videos' in props)) {
  			console.warn("<YoutubeSearch> was created without expected prop 'videos'");
  		}

  		if (/*videoSearch*/ ctx[0] === undefined && !('videoSearch' in props)) {
  			console.warn("<YoutubeSearch> was created without expected prop 'videoSearch'");
  		}
  	}

  	get videos() {
  		throw new Error_1("<YoutubeSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set videos(value) {
  		throw new Error_1("<YoutubeSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get videoSearch() {
  		throw new Error_1("<YoutubeSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set videoSearch(value) {
  		throw new Error_1("<YoutubeSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get startSearch() {
  		throw new Error_1("<YoutubeSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set startSearch(value) {
  		throw new Error_1("<YoutubeSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* src/pages/NewLesson/index.svelte generated by Svelte v3.47.0 */

  const { console: console_1 } = main.globals;
  const file = "src/pages/NewLesson/index.svelte";

  // (147:6) {:else}
  function create_else_block(ctx) {
  	let span;
  	let t;

  	const block = {
  		c: function create() {
  			span = main.element("span");
  			t = main.text("Save Lesson");
  			this.h();
  		},
  		l: function claim(nodes) {
  			span = main.claim_element(nodes, "SPAN", {});
  			var span_nodes = main.children(span);
  			t = main.claim_text(span_nodes, "Save Lesson");
  			span_nodes.forEach(main.detach_dev);
  			this.h();
  		},
  		h: function hydrate() {
  			main.add_location(span, file, 147, 8, 4082);
  		},
  		m: function mount(target, anchor) {
  			main.insert_hydration_dev(target, span, anchor);
  			main.append_hydration_dev(span, t);
  		},
  		i: main.noop,
  		o: main.noop,
  		d: function destroy(detaching) {
  			if (detaching) main.detach_dev(span);
  		}
  	};

  	main.dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block.name,
  		type: "else",
  		source: "(147:6) {:else}",
  		ctx
  	});

  	return block;
  }

  // (145:6) {#if loading}
  function create_if_block(ctx) {
  	let loading_1;
  	let current;
  	loading_1 = new Loading({ props: { text: "" }, $$inline: true });

  	const block = {
  		c: function create() {
  			main.create_component(loading_1.$$.fragment);
  		},
  		l: function claim(nodes) {
  			main.claim_component(loading_1.$$.fragment, nodes);
  		},
  		m: function mount(target, anchor) {
  			main.mount_component(loading_1, target, anchor);
  			current = true;
  		},
  		i: function intro(local) {
  			if (current) return;
  			main.transition_in(loading_1.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			main.transition_out(loading_1.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			main.destroy_component(loading_1, detaching);
  		}
  	};

  	main.dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block.name,
  		type: "if",
  		source: "(145:6) {#if loading}",
  		ctx
  	});

  	return block;
  }

  function create_fragment(ctx) {
  	let section;
  	let h1;
  	let t0;
  	let t1;
  	let form;
  	let spotifysearch;
  	let updating_songName;
  	let t2;
  	let input0;
  	let updating_value;
  	let t3;
  	let youtubesearch;
  	let updating_videoSearch;
  	let updating_startSearch;
  	let updating_videos;
  	let t4;
  	let input1;
  	let updating_value_1;
  	let t5;
  	let button;
  	let current_block_type_index;
  	let if_block;
  	let button_disabled_value;
  	let current;
  	let mounted;
  	let dispose;

  	function spotifysearch_songName_binding(value) {
  		/*spotifysearch_songName_binding*/ ctx[6](value);
  	}

  	let spotifysearch_props = {};

  	if (/*songData*/ ctx[3].title !== void 0) {
  		spotifysearch_props.songName = /*songData*/ ctx[3].title;
  	}

  	spotifysearch = new SpotifySearch({
  			props: spotifysearch_props,
  			$$inline: true
  		});

  	main.binding_callbacks.push(() => main.bind(spotifysearch, 'songName', spotifysearch_songName_binding));
  	spotifysearch.$on("song", /*song_handler*/ ctx[7]);

  	function input0_value_binding(value) {
  		/*input0_value_binding*/ ctx[8](value);
  	}

  	let input0_props = { label: "Artist" };

  	if (/*songData*/ ctx[3].artist !== void 0) {
  		input0_props.value = /*songData*/ ctx[3].artist;
  	}

  	input0 = new Input({ props: input0_props, $$inline: true });
  	main.binding_callbacks.push(() => main.bind(input0, 'value', input0_value_binding));

  	function youtubesearch_videoSearch_binding(value) {
  		/*youtubesearch_videoSearch_binding*/ ctx[9](value);
  	}

  	function youtubesearch_startSearch_binding(value) {
  		/*youtubesearch_startSearch_binding*/ ctx[10](value);
  	}

  	function youtubesearch_videos_binding(value) {
  		/*youtubesearch_videos_binding*/ ctx[11](value);
  	}

  	let youtubesearch_props = {};

  	if (/*videoSearch*/ ctx[0] !== void 0) {
  		youtubesearch_props.videoSearch = /*videoSearch*/ ctx[0];
  	}

  	if (/*startSearch*/ ctx[1] !== void 0) {
  		youtubesearch_props.startSearch = /*startSearch*/ ctx[1];
  	}

  	if (/*songData*/ ctx[3].videos !== void 0) {
  		youtubesearch_props.videos = /*songData*/ ctx[3].videos;
  	}

  	youtubesearch = new YoutubeSearch({
  			props: youtubesearch_props,
  			$$inline: true
  		});

  	main.binding_callbacks.push(() => main.bind(youtubesearch, 'videoSearch', youtubesearch_videoSearch_binding));
  	main.binding_callbacks.push(() => main.bind(youtubesearch, 'startSearch', youtubesearch_startSearch_binding));
  	main.binding_callbacks.push(() => main.bind(youtubesearch, 'videos', youtubesearch_videos_binding));

  	function input1_value_binding(value) {
  		/*input1_value_binding*/ ctx[12](value);
  	}

  	let input1_props = {
  		label: "Enter Url of chord site like https://azchords.com/"
  	};

  	if (/*songData*/ ctx[3].tab !== void 0) {
  		input1_props.value = /*songData*/ ctx[3].tab;
  	}

  	input1 = new Input({ props: input1_props, $$inline: true });
  	main.binding_callbacks.push(() => main.bind(input1, 'value', input1_value_binding));
  	const if_block_creators = [create_if_block, create_else_block];
  	const if_blocks = [];

  	function select_block_type(ctx, dirty) {
  		if (/*loading*/ ctx[2]) return 0;
  		return 1;
  	}

  	current_block_type_index = select_block_type(ctx);
  	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

  	const block = {
  		c: function create() {
  			section = main.element("section");
  			h1 = main.element("h1");
  			t0 = main.text("Create a new Lesson");
  			t1 = main.space();
  			form = main.element("form");
  			main.create_component(spotifysearch.$$.fragment);
  			t2 = main.space();
  			main.create_component(input0.$$.fragment);
  			t3 = main.space();
  			main.create_component(youtubesearch.$$.fragment);
  			t4 = main.space();
  			main.create_component(input1.$$.fragment);
  			t5 = main.space();
  			button = main.element("button");
  			if_block.c();
  			this.h();
  		},
  		l: function claim(nodes) {
  			section = main.claim_element(nodes, "SECTION", { id: true, class: true });
  			var section_nodes = main.children(section);
  			h1 = main.claim_element(section_nodes, "H1", {});
  			var h1_nodes = main.children(h1);
  			t0 = main.claim_text(h1_nodes, "Create a new Lesson");
  			h1_nodes.forEach(main.detach_dev);
  			t1 = main.claim_space(section_nodes);
  			form = main.claim_element(section_nodes, "FORM", { class: true });
  			var form_nodes = main.children(form);
  			main.claim_component(spotifysearch.$$.fragment, form_nodes);
  			t2 = main.claim_space(form_nodes);
  			main.claim_component(input0.$$.fragment, form_nodes);
  			t3 = main.claim_space(form_nodes);
  			main.claim_component(youtubesearch.$$.fragment, form_nodes);
  			t4 = main.claim_space(form_nodes);
  			main.claim_component(input1.$$.fragment, form_nodes);
  			t5 = main.claim_space(form_nodes);
  			button = main.claim_element(form_nodes, "BUTTON", { type: true });
  			var button_nodes = main.children(button);
  			if_block.l(button_nodes);
  			button_nodes.forEach(main.detach_dev);
  			form_nodes.forEach(main.detach_dev);
  			section_nodes.forEach(main.detach_dev);
  			this.h();
  		},
  		h: function hydrate() {
  			main.add_location(h1, file, 106, 2, 2768);
  			button.disabled = button_disabled_value = !/*songData*/ ctx[3].title || /*loading*/ ctx[2];
  			main.attr_dev(button, "type", "submit");
  			main.add_location(button, file, 143, 4, 3951);
  			main.attr_dev(form, "class", "svelte-lqnpzt");
  			main.add_location(form, file, 108, 2, 2800);
  			main.attr_dev(section, "id", "container");
  			main.attr_dev(section, "class", "svelte-lqnpzt");
  			main.add_location(section, file, 105, 0, 2741);
  		},
  		m: function mount(target, anchor) {
  			main.insert_hydration_dev(target, section, anchor);
  			main.append_hydration_dev(section, h1);
  			main.append_hydration_dev(h1, t0);
  			main.append_hydration_dev(section, t1);
  			main.append_hydration_dev(section, form);
  			main.mount_component(spotifysearch, form, null);
  			main.append_hydration_dev(form, t2);
  			main.mount_component(input0, form, null);
  			main.append_hydration_dev(form, t3);
  			main.mount_component(youtubesearch, form, null);
  			main.append_hydration_dev(form, t4);
  			main.mount_component(input1, form, null);
  			main.append_hydration_dev(form, t5);
  			main.append_hydration_dev(form, button);
  			if_blocks[current_block_type_index].m(button, null);
  			current = true;

  			if (!mounted) {
  				dispose = main.listen_dev(form, "submit", main.prevent_default(/*handleSubmit*/ ctx[4]), false, true, false);
  				mounted = true;
  			}
  		},
  		p: function update(ctx, [dirty]) {
  			const spotifysearch_changes = {};

  			if (!updating_songName && dirty & /*songData*/ 8) {
  				updating_songName = true;
  				spotifysearch_changes.songName = /*songData*/ ctx[3].title;
  				main.add_flush_callback(() => updating_songName = false);
  			}

  			spotifysearch.$set(spotifysearch_changes);
  			const input0_changes = {};

  			if (!updating_value && dirty & /*songData*/ 8) {
  				updating_value = true;
  				input0_changes.value = /*songData*/ ctx[3].artist;
  				main.add_flush_callback(() => updating_value = false);
  			}

  			input0.$set(input0_changes);
  			const youtubesearch_changes = {};

  			if (!updating_videoSearch && dirty & /*videoSearch*/ 1) {
  				updating_videoSearch = true;
  				youtubesearch_changes.videoSearch = /*videoSearch*/ ctx[0];
  				main.add_flush_callback(() => updating_videoSearch = false);
  			}

  			if (!updating_startSearch && dirty & /*startSearch*/ 2) {
  				updating_startSearch = true;
  				youtubesearch_changes.startSearch = /*startSearch*/ ctx[1];
  				main.add_flush_callback(() => updating_startSearch = false);
  			}

  			if (!updating_videos && dirty & /*songData*/ 8) {
  				updating_videos = true;
  				youtubesearch_changes.videos = /*songData*/ ctx[3].videos;
  				main.add_flush_callback(() => updating_videos = false);
  			}

  			youtubesearch.$set(youtubesearch_changes);
  			const input1_changes = {};

  			if (!updating_value_1 && dirty & /*songData*/ 8) {
  				updating_value_1 = true;
  				input1_changes.value = /*songData*/ ctx[3].tab;
  				main.add_flush_callback(() => updating_value_1 = false);
  			}

  			input1.$set(input1_changes);
  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type(ctx);

  			if (current_block_type_index !== previous_block_index) {
  				main.group_outros();

  				main.transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				main.check_outros();
  				if_block = if_blocks[current_block_type_index];

  				if (!if_block) {
  					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block.c();
  				}

  				main.transition_in(if_block, 1);
  				if_block.m(button, null);
  			}

  			if (!current || dirty & /*songData, loading*/ 12 && button_disabled_value !== (button_disabled_value = !/*songData*/ ctx[3].title || /*loading*/ ctx[2])) {
  				main.prop_dev(button, "disabled", button_disabled_value);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			main.transition_in(spotifysearch.$$.fragment, local);
  			main.transition_in(input0.$$.fragment, local);
  			main.transition_in(youtubesearch.$$.fragment, local);
  			main.transition_in(input1.$$.fragment, local);
  			main.transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			main.transition_out(spotifysearch.$$.fragment, local);
  			main.transition_out(input0.$$.fragment, local);
  			main.transition_out(youtubesearch.$$.fragment, local);
  			main.transition_out(input1.$$.fragment, local);
  			main.transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) main.detach_dev(section);
  			main.destroy_component(spotifysearch);
  			main.destroy_component(input0);
  			main.destroy_component(youtubesearch);
  			main.destroy_component(input1);
  			if_blocks[current_block_type_index].d();
  			mounted = false;
  			dispose();
  		}
  	};

  	main.dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance($$self, $$props, $$invalidate) {
  	let $spotifyToken;
  	main.validate_store(main.spotifyToken, 'spotifyToken');
  	main.component_subscribe($$self, main.spotifyToken, $$value => $$invalidate(13, $spotifyToken = $$value));
  	let { $$slots: slots = {}, $$scope } = $$props;
  	main.validate_slots('NewLesson', slots, []);
  	let videoSearch;
  	let startSearch = false;
  	let loading = false;

  	let songData = {
  		title: null,
  		artist: null,
  		videos: [],
  		tab: null,
  		coordinates: [{ 0: {}, 1: {}, 2: {}, 3: {}, 4: {}, 5: {} }]
  	};

  	// let tabSearch;
  	// let tabs;
  	// let tabError;
  	// async function searchSongsterr() {
  	//   if (tabSearch && tabSearch.length > 3) {
  	//     songData.tab = null;
  	//     videos = null;
  	//     try {
  	//       const res = await apiCall("http://www.songsterr.com/a/ra/songs.json", {
  	//         pattern: tabSearch,
  	//       });
  	//       console.log("FIRE: searchSongsterr -> res", res);
  	//       tabs = res > 7 ? res.slice(0, 7) : res;
  	//       tabError = null;
  	//     } catch (error) {
  	//       tabError = "Oops, couldn't get data from songsterr. Sorry :-(";
  	//     }
  	//   }
  	// }
  	const handleSubmit = async () => {
  		if ($spotifyToken) {
  			try {
  				$$invalidate(2, loading = true);

  				const { data } = await helpers.axios("https://api.spotify.com/v1/audio-features", {
  					headers: {
  						"Content-Type": "application/json",
  						Authorization: `Authorization: Bearer ${$spotifyToken}`
  					},
  					params: { ids: songData.spotifyID }
  				});

  				if (data?.audio_features[0]) {
  					$$invalidate(3, songData = {
  						...songData,
  						audioFeatures: data?.audio_features[0]
  					});
  				}
  			} catch(err) {
  				console.error(err);
  			} finally {
  				$$invalidate(2, loading = false);
  			}
  		}

  		try {
  			$$invalidate(3, songData.id = `${songData.title}-${helpers.createID()}`, songData);
  			let lessons;
  			const stringifiedLessons = await localStorage.getItem(helpers.LESSONS);

  			if (stringifiedLessons) {
  				lessons = JSON.parse(stringifiedLessons);
  				lessons.push(songData);
  			} else {
  				lessons = [songData];
  			}

  			await localStorage.setItem(helpers.LESSONS, JSON.stringify(lessons));
  			main.push(`#/lesson/${encodeURIComponent(songData.id)}`);
  		} catch(err) {
  			console.error(err);
  		}
  	};

  	function handleSpotifySearchClick(data) {
  		$$invalidate(3, songData = {
  			...songData,
  			...data,
  			title: data.name,
  			spotifyID: data.id
  		});

  		$$invalidate(3, songData.artist = helpers.getArtists(data.artists), songData);
  		$$invalidate(0, videoSearch = `${songData.name} guitar tutorial`);
  		$$invalidate(1, startSearch = true);
  	}

  	const writable_props = [];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<NewLesson> was created with unknown prop '${key}'`);
  	});

  	function spotifysearch_songName_binding(value) {
  		if ($$self.$$.not_equal(songData.title, value)) {
  			songData.title = value;
  			$$invalidate(3, songData);
  		}
  	}

  	const song_handler = e => handleSpotifySearchClick(e.detail);

  	function input0_value_binding(value) {
  		if ($$self.$$.not_equal(songData.artist, value)) {
  			songData.artist = value;
  			$$invalidate(3, songData);
  		}
  	}

  	function youtubesearch_videoSearch_binding(value) {
  		videoSearch = value;
  		$$invalidate(0, videoSearch);
  	}

  	function youtubesearch_startSearch_binding(value) {
  		startSearch = value;
  		$$invalidate(1, startSearch);
  	}

  	function youtubesearch_videos_binding(value) {
  		if ($$self.$$.not_equal(songData.videos, value)) {
  			songData.videos = value;
  			$$invalidate(3, songData);
  		}
  	}

  	function input1_value_binding(value) {
  		if ($$self.$$.not_equal(songData.tab, value)) {
  			songData.tab = value;
  			$$invalidate(3, songData);
  		}
  	}

  	$$self.$capture_state = () => ({
  		axios: helpers.axios,
  		push: main.push,
  		spotifyToken: main.spotifyToken,
  		SpotifySearch,
  		YoutubeSearch,
  		Input,
  		Loading,
  		getArtists: helpers.getArtists,
  		createID: helpers.createID,
  		LESSONS: helpers.LESSONS,
  		videoSearch,
  		startSearch,
  		loading,
  		songData,
  		handleSubmit,
  		handleSpotifySearchClick,
  		$spotifyToken
  	});

  	$$self.$inject_state = $$props => {
  		if ('videoSearch' in $$props) $$invalidate(0, videoSearch = $$props.videoSearch);
  		if ('startSearch' in $$props) $$invalidate(1, startSearch = $$props.startSearch);
  		if ('loading' in $$props) $$invalidate(2, loading = $$props.loading);
  		if ('songData' in $$props) $$invalidate(3, songData = $$props.songData);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [
  		videoSearch,
  		startSearch,
  		loading,
  		songData,
  		handleSubmit,
  		handleSpotifySearchClick,
  		spotifysearch_songName_binding,
  		song_handler,
  		input0_value_binding,
  		youtubesearch_videoSearch_binding,
  		youtubesearch_startSearch_binding,
  		youtubesearch_videos_binding,
  		input1_value_binding
  	];
  }

  class NewLesson extends main.SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		main.init(this, options, instance, create_fragment, main.safe_not_equal, {});

  		main.dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "NewLesson",
  			options,
  			id: create_fragment.name
  		});
  	}
  }

  exports["default"] = NewLesson;

}));
//# sourceMappingURL=index-9f34d39c.js.map
